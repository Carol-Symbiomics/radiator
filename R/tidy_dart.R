# Import, filter and transform a dart output file to different formats

#' @name tidy_dart

#' @title Tidy \href{http://www.diversityarrays.com}{DArT} output file.

#' @description Used internally in \href{https://github.com/thierrygosselin/radiator}{radiator}
#' and might be of interest for users. The function generate a tidy dataset using
#' \href{http://www.diversityarrays.com}{DArT} file.

#' @param data DArT output file. Note that most popular format used by DArT are
#' recognised (1- and 2- row format,also called binary, and count data.).
#' If you encounter a problem, sent me your data so that I can update
#' the function. The data is a tab delimited file ending with \code{.tsv}.

#' @param strata A tab delimited file with columns header:
#' \code{INDIVIDUALS} and \code{STRATA}.
#' Note: the column \code{STRATA} refers to any grouping of individuals.
#' You need to make sure that
#' the column \code{INDIVIDUALS} match the id used by DArT. Sometimes it's a
#' DArT DB integer name.
#' Use a third column in the strata, named \code{NEW_ID}, to replace the
#' \code{INDIVIDUALS} column in the main data file.

#' @inheritParams tidy_genomic_data

#' @return A tidy dataframe with these columns:
#' \enumerate{
#' \item MARKERS: generated by radiator and correspond to CHROM + LOCUS + POS separated by 2 underscores.
#' \item CHROM: the chromosome, for de novo: CHROM_1.
#' \item LOCUS: the locus.
#' \item POS: the SNP id on the LOCUS.
#' \item REF: the reference allele.
#' \item ALT: the alternate allele.
#' \item INDIVIDUALS: the sample name.
#' \item POP_ID: populations id of the sample.
#' \item GT: the genotype in 6 digit format Ã  la genepop.
#' \item GT_VCF: the genotype in VCF format.
#' \item GT_VCF_NUC: the genotype in VCF format, but keeping the nucleotide information.
#' \item GT_BIN: the genotype in binary format similar to PLINK. The number correspond to the number of alternate allele in the genotype.
#' \item CALL_RATE: call rate output specific of DArT.
#' \item AVG_COUNT_REF: the coverage for the reference allele, output specific of DArT.
#' \item AVG_COUNT_SNP: the coverage for the alternate allele, output specific of DArT.
#' \item REP_AVG: the reproducibility average, output specific of DArT.
#' }

#' @export
#' @rdname tidy_dart
#' @importFrom dplyr group_by select rename filter mutate summarise distinct n_distinct arrange left_join semi_join anti_join inner_join full_join tally bind_rows
#' @importFrom parallel detectCores
#' @importFrom stringi stri_replace_all_fixed stri_join stri_sub stri_replace_na stri_pad_left
#' @importFrom purrr discard
#' @importFrom data.table fread melt.data.table as.data.table dcast.data.table
#' @importFrom readr read_tsv write_tsv
#' @importFrom tibble as_data_frame data_frame
#' @importFrom tidyr spread gather unite separate

#' @examples
#' \dontrun{
#' clownfish.dart.tidy <- radiator::tidy_dart(
#' data = "clownfish.dart.tsv",
#' strata = "clownfish.strata.tsv",
#' verbose = TRUE)
#' }

#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com} and Peter Grewe \email{peter.grewe@csiro.au}

tidy_dart <- function(
  data,
  strata,
  verbose = FALSE,
  parallel.core = parallel::detectCores() - 1
) {
  opt.change <- getOption("width")
  options(width = 70)
  # for timing
  timing <- proc.time()

  # Checking for missing and/or default arguments ------------------------------
  if (missing(data)) stop("Input file missing")
  if (missing(strata)) stop("strata file missing")

  # Check DArT format file -----------------------------------------------------
  data.type <- readChar(con = data, nchars = 16L, useBytes = TRUE)
  dart.with.header <- stringi::stri_detect_fixed(str = data.type, pattern = "*\t")
  if (dart.with.header) {
    temp.file <- suppressWarnings(suppressMessages(readr::read_table(file = data, n_max = 20, col_names = "HEADER")))
    skip.number <- which(stringi::stri_detect_fixed(str = temp.file$HEADER,
                                                    pattern = "AlleleID")) - 1
    data.type <- readr::read_lines(file = data, skip = skip.number, n_max = skip.number + 1)[1] %>%
      stringi::stri_sub(str = ., from = 1, to = 16)
  } else {
    skip.number <- 0
  }
  temp.file <- NULL
  dart.clone.id <- stringi::stri_detect_fixed(str = data.type, pattern = "CloneID")
  dart.allele.id <- stringi::stri_detect_fixed(str = data.type, pattern = "AlleleID")

  if (dart.clone.id || dart.allele.id) {
    data.type <- "dart"
  } else {
    stop("Contact author to show your DArT data, problem duting import")
  }
  if (verbose) message("Importing DArT data")

  # Strata file ------------------------------------------------------------------
  strata.df <- suppressMessages(readr::read_tsv(file = strata, col_names = TRUE)) %>%
    dplyr::mutate_all(.tbl = ., .funs = as.character)

  # Import data ---------------------------------------------------------------
  colnames.keeper <- c(c("AlleleID", "SNP", "SnpPosition", "CallRate",
                         "AvgCountRef", "AvgCountSnp", "RepAvg"),
                       strata.df$INDIVIDUALS)
  # Catch error while importing DArT with fread
  import_dart <- function(data, skip.number, colnames.keeper) {
    input <- suppressWarnings(
      data.table::fread(
        input = data,
        skip = skip.number,
        sep = "\t",
        stringsAsFactors = FALSE,
        header = TRUE,
        na.strings = "-",
        strip.white = TRUE,
        select = colnames.keeper,
        showProgress = TRUE,
        verbose = FALSE
      ) %>%
        tibble::as_data_frame(.) %>%
        dplyr::rename(LOCUS = AlleleID, POS = SnpPosition, CALL_RATE = CallRate,
                      AVG_COUNT_REF = AvgCountRef, AVG_COUNT_SNP = AvgCountSnp,
                      REP_AVG = RepAvg) %>%
        dplyr::arrange(LOCUS, POS)
    )
  }#End import_dart
  safe_dart <- purrr::safely(.f = import_dart)
  import.test <- safe_dart(data, skip.number, colnames.keeper)

  if (is.null(import.test$error)) {
    input <- import.test$result
  } else {# plan B using readr
    input <- suppressMessages(suppressWarnings(
      readr::read_tsv(file = data, skip = skip.number, na = "-"))) %>%
      dplyr::select(dplyr::one_of(colnames.keeper)) %>%
      dplyr::rename(LOCUS = AlleleID, POS = SnpPosition, CALL_RATE = CallRate,
                    AVG_COUNT_REF = AvgCountRef, AVG_COUNT_SNP = AvgCountSnp,
                    REP_AVG = RepAvg) %>%
      dplyr::arrange(LOCUS, POS)
  }
  safe_dart <- import.test <- NULL

  # Screen for duplicate names -------------------------------------------------
  remove.list <- c("LOCUS", "SNP", "POS", "CALL_RATE", "AVG_COUNT_REF",
                   "AVG_COUNT_SNP", "REP_AVG")
  individuals.df <- tibble::data_frame(
    INDIVIDUALS = purrr::discard(.x = colnames(input),
                                 .p = colnames(input) %in% remove.list))
  duplicate.individuals <- length(individuals.df$INDIVIDUALS) - dplyr::n_distinct(individuals.df$INDIVIDUALS)
  if (duplicate.individuals > 0) {
    stop(stringi::stri_join("Duplicated individuals names found in the data set.\nNumber of duplicate names = ", duplicate.individuals))
  }
  # removing unused object
  remove.list <- individuals.df <- duplicate.individuals <- NULL

  # Tidying data ---------------------------------------------------------------
  input <- suppressWarnings(
    input %>%
      tidyr::separate(col = LOCUS, into = c("LOCUS", "NOT_USEFUL"), sep = "\\|", extra = "drop") %>%
      dplyr::select(-NOT_USEFUL) %>%
      tidyr::separate(col = SNP, into = c("NOT_USEFUL", "KEEPER"), sep = ":", extra = "drop") %>%
      dplyr::select(-NOT_USEFUL) %>%
      tidyr::separate(col = KEEPER, into = c("REF", "ALT"), sep = ">") %>%
      dplyr::mutate(
        CHROM = rep("CHROM_1", n()),
        MARKERS = stringi::stri_join(CHROM, LOCUS, POS, sep = "__")) %>%
      dplyr::select(MARKERS, CHROM, LOCUS, POS, REF, ALT, CALL_RATE, AVG_COUNT_REF,
                    AVG_COUNT_SNP, REP_AVG, dplyr::everything()) %>%
      dplyr::mutate_at(.tbl = ., .vars = c("MARKERS", "CHROM", "LOCUS", "POS"), .funs = as.character)
  )

  # Determine the type of DArT file: 1 or 2-row format (binary)
  binary <- anyDuplicated(input$LOCUS) == 2

  if (!binary) {
    if (verbose) message("Tidying DArT data...")

    input <- data.table::melt.data.table(
      data = data.table::as.data.table(input),
      id.vars = c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "CALL_RATE",
                  "AVG_COUNT_REF", "AVG_COUNT_SNP", "REP_AVG"),
      variable.name = "INDIVIDUALS",
      variable.factor = FALSE,
      value.name = "GT"
    ) %>%
      tibble::as_data_frame(.)

    # generate the split vector
    split.vec <- split_vec_row(x = input, cpu.rounds = 3, parallel.core = parallel.core)

    dart2gt <- function(x) {
      res <- x %>%
        dplyr::mutate(
          R = REF,
          A = ALT,
          R = stringi::stri_replace_all_fixed(
            str = R, pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"), vectorize_all = FALSE),
          A = stringi::stri_replace_all_fixed(
            str = A, pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"), vectorize_all = FALSE),
          GT = as.character(GT),
          GT = stringi::stri_replace_all_fixed(
            str = GT, pattern = c("0", "1", "2"),
            replacement = c("RR", "AA", "RA"),
            vectorize_all = FALSE),
          GT_BIN = dplyr::if_else(GT == "RR", 0, dplyr::if_else(GT == "AA", 2, 1)),
          GT_VCF = dplyr::if_else(GT == "RR", "0/0",
                                  dplyr::if_else(GT == "AA", "1/1", "0/1"), missing = "./."),
          GT_VCF_NUC = dplyr::if_else(GT == "RR", stringi::stri_join(REF, REF, sep = "/"),
                                      dplyr::if_else(GT_VCF == "1/1", stringi::stri_join(ALT, ALT, sep = "/"),
                                                     stringi::stri_join(REF, ALT, sep = "/")), missing = "./."),
          GT = dplyr::if_else(GT == "RR", stringi::stri_join(R, R, sep = ""),
                              dplyr::if_else(GT == "AA", stringi::stri_join(A, A, sep = ""),
                                             stringi::stri_join(R, A, sep = "")), "000000")
        ) %>%
        dplyr::select(GT, GT_VCF, GT_VCF_NUC, GT_BIN)
      return(res)
    }#End dart2gt

    input <- dplyr::bind_cols(
      dplyr::select(input, -GT),
      dplyr::select(input, GT, REF, ALT) %>%
        split(x = ., f = split.vec) %>%
        .radiator_parallel(
          X = ., FUN = dart2gt, mc.cores = parallel.core) %>%
        dplyr::bind_rows(.)
    )
    split.vec <- NULL
  }#End 1 row format DArT file

  if (binary) {
    if (verbose) message("Tidying DArT 2-row-format data...")

    # To do: merge these 2 functions and simplify codes
    dart_binary <- function(x) {
      res <- dplyr::select(x, -SPLIT_VEC) %>%
        data.table::as.data.table(.) %>%
        data.table::dcast.data.table(
          data = .,
          formula = MARKERS + INDIVIDUALS + REF + ALT ~ ALLELES,
          fun.aggregate = function(y) paste(y, collapse = "_"),
          value.var = "GT"
        ) %>%
        tibble::as_data_frame(.) %>%
        dplyr::mutate(
          R = REF,
          A = ALT,
          R = stringi::stri_replace_all_fixed(
            str = R, pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"), vectorize_all = FALSE),
          A = stringi::stri_replace_all_fixed(
            str = A, pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"), vectorize_all = FALSE),
          GT = dplyr::if_else(GT == "1_0", "RR",
                              dplyr::if_else(GT == "0_1", "AA",
                                             dplyr::if_else(GT == "1_1", "RA", NA_character_))),
          GT_BIN = dplyr::if_else(GT == "RR", 0, dplyr::if_else(GT == "AA", 2, 1)),
          GT_VCF = dplyr::if_else(GT == "RR", "0/0",
                                  dplyr::if_else(GT == "AA", "1/1", "0/1"), missing = "./."),
          GT_VCF_NUC = dplyr::if_else(GT == "RR", stringi::stri_join(REF, REF, sep = "/"),
                                      dplyr::if_else(GT_VCF == "1/1", stringi::stri_join(ALT, ALT, sep = "/"),
                                                     stringi::stri_join(REF, ALT, sep = "/")), missing = "./."),
          GT = dplyr::if_else(GT == "RR", stringi::stri_join(R, R, sep = ""),
                              dplyr::if_else(GT == "AA", stringi::stri_join(A, A, sep = ""),
                                             stringi::stri_join(R, A, sep = "")), missing = "000000")
        ) %>%
        dplyr::select(MARKERS, INDIVIDUALS, GT, GT_VCF, GT_VCF_NUC, GT_BIN)
      return(res)
    }#End dart_binary
    dart_count <- function(x) {
      x <- dplyr::select(x, -SPLIT_VEC) %>%
        dplyr::arrange(MARKERS, REF) %>%
        dplyr::mutate(TEMP = rep(1:2, n()/2)) %>%
        dplyr::select(dplyr::one_of(c("TEMP", "MARKERS", "REF", "ALT")), dplyr::everything())

      x <- dplyr::bind_cols(
        dplyr::filter(x, TEMP == 1) %>%
          dplyr::arrange(MARKERS) %>%
          dplyr::select(-TEMP) %>%
          tidyr::gather(data = .,
                        key = INDIVIDUALS,
                        value = ALLELE_ALT_DEPTH,
                        -dplyr::one_of(c("MARKERS", "REF", "ALT"))) %>%
          dplyr::arrange(MARKERS, INDIVIDUALS),
        dplyr::filter(x, TEMP == 2) %>%
          dplyr::arrange(MARKERS) %>%
          dplyr::select(-dplyr::one_of(c("TEMP", "REF", "ALT"))) %>%
          tidyr::gather(data = .,
                        key = INDIVIDUALS,
                        value = ALLELE_REF_DEPTH,
                        -MARKERS) %>%
          dplyr::arrange(MARKERS, INDIVIDUALS) %>%
          dplyr::select(ALLELE_REF_DEPTH)) %>%
        dplyr::mutate(
          A1 = dplyr::if_else(ALLELE_REF_DEPTH > 0, REF, NA_character_),
          A2 = dplyr::if_else(ALLELE_ALT_DEPTH > 0, ALT, NA_character_),
          VCF_A1 = dplyr::if_else(is.na(A1), NA_integer_, 0L),
          VCF_A2 = dplyr::if_else(is.na(A2), NA_integer_, 1L)
        ) %>%
        dplyr::arrange(MARKERS, INDIVIDUALS) %>%
        dplyr::mutate(
          A1 = dplyr::if_else(is.na(A1), A2, A1),
          A2 = dplyr::if_else(is.na(A2), A1, A2),
          GT_VCF_NUC = stringi::stri_join(A1, A2, sep = "/"),
          GT_VCF_NUC = stringi::stri_replace_na(str = GT_VCF_NUC, replacement = "./."),
          GT_1 = stringi::stri_replace_all_fixed(
            str = A1,
            pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"),
            vectorize_all = FALSE),
          GT_2 = stringi::stri_replace_all_fixed(
            str = A2,
            pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"),
            vectorize_all = FALSE),
          GT = stringi::stri_join(GT_1, GT_2),
          GT = stringi::stri_replace_na(str = GT, replacement = "000000")) %>%
        dplyr::select(-c(A1, A2, GT_1, GT_2)) %>%
        dplyr::mutate(
          VCF_A1 = dplyr::if_else(is.na(VCF_A1), VCF_A2, VCF_A1),
          VCF_A2 = dplyr::if_else(is.na(VCF_A2), VCF_A1, VCF_A2),
          GT_VCF = stringi::stri_join(VCF_A1, VCF_A2, sep = "/"),
          GT_VCF = stringi::stri_replace_na(str = GT_VCF, replacement = "./.")
        ) %>%
        dplyr::select(-c(VCF_A1, VCF_A2)) %>%
        dplyr::mutate(
          GT_BIN = as.numeric(
            stringi::stri_replace_all_fixed(
              str = GT_VCF,
              pattern = c("0/0", "1/1", "0/1", "1/0", "./."),
              replacement = c("0", "2", "1", "1", NA),
              vectorize_all = FALSE)))
      return(x)
    }#End dart_count

    # keep one marker and check if genotypes are count data
    gt.counts <- 0 #required to start the while loop
    while (gt.counts == 0) {
      gt.counts <- dplyr::select(
        input,
        -c(MARKERS, CHROM, LOCUS, POS, CALL_RATE, AVG_COUNT_REF,
           AVG_COUNT_SNP, REP_AVG, REF, ALT)) %>%
        dplyr::sample_n(tbl = ., size = 1) %>%
        purrr::flatten_chr(.) %>%
        as.integer %>%
        unique %>% sum(na.rm = TRUE)
    }
    count.data <- gt.counts > 3
    n.markers <- dplyr::n_distinct(input$MARKERS)
    n.individuals <- length(colnames(input)) - 10
    grouping.col <- c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "CALL_RATE", "AVG_COUNT_REF", "AVG_COUNT_SNP", "REP_AVG")

    if (!count.data) {#Genotypes coded 0, 1, 2
      # necessary to deal with the duplication of lines because of the GT in 2 lines
      grouping.column <- dplyr::ungroup(input) %>%
        dplyr::select(dplyr::one_of(grouping.col)) %>%
        dplyr::filter(!is.na(REF) | !is.na(ALT)) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE) %>%
        dplyr::arrange(MARKERS)

      ref.info <- dplyr::distinct(grouping.column, MARKERS, REF, ALT) %>%
        dplyr::arrange(MARKERS)

      markers.split <- dplyr::distinct(ref.info, MARKERS) %>%
        dplyr::mutate(SPLIT_VEC = as.integer(floor((parallel.core * 100 * (1:n() - 1) / n()) + 1)))

      input <- dplyr::select(
        input,
        -c(CHROM, LOCUS, POS, CALL_RATE, AVG_COUNT_REF, AVG_COUNT_SNP,
           REP_AVG, REF, ALT)) %>%
        tidyr::gather(INDIVIDUALS, GT, -MARKERS) %>%
        dplyr::mutate(
          GT = as.character(GT),
          ALLELES = rep("GT", n())
        ) %>%
        dplyr::left_join(ref.info, by = "MARKERS") %>%
        dplyr::left_join(markers.split, by = "MARKERS") %>%
        split(x = ., f = .$SPLIT_VEC) %>%
        .radiator_parallel(
          X = ., FUN = dart_binary, mc.cores = parallel.core) %>%
        dplyr::bind_rows(.) %>%
        dplyr::left_join(grouping.column, by = "MARKERS") %>%
        dplyr::select(MARKERS, CHROM, LOCUS, POS, REF, ALT, INDIVIDUALS, GT,
                      GT_VCF, GT_VCF_NUC, GT_BIN, CALL_RATE, AVG_COUNT_REF,
                      AVG_COUNT_SNP, REP_AVG)

      grouping.column <- ref.info <- markers.split <- NULL # remove unused object

    } else {
      if (verbose) message("DArT genotype field is count information")
      grouping.column <- dplyr::ungroup(input) %>%
        dplyr::select(dplyr::one_of(grouping.col)) %>%
        dplyr::filter(!is.na(REF) | !is.na(ALT)) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE) %>%
        dplyr::arrange(MARKERS) %>%
        dplyr::select(-REF, -ALT)
      grouping.column <- dplyr::bind_rows(replicate(n.individuals, grouping.column, simplify = FALSE)) %>%
        dplyr::arrange(MARKERS)

      markers.split <- dplyr::distinct(input, MARKERS) %>%
        dplyr::mutate(SPLIT_VEC = split_vec_row(., 10, parallel.core = parallel.core))

      input <- input %>%
        dplyr::select(-dplyr::one_of(
          c("CHROM", "LOCUS", "POS", "CALL_RATE", "AVG_COUNT_REF",
            "AVG_COUNT_SNP", "REP_AVG"))) %>%
        dplyr::arrange(MARKERS, REF) %>%
        dplyr::left_join(markers.split, by = "MARKERS") %>%
        split(x = ., f = .$SPLIT_VEC) %>%
        .radiator_parallel_mc(X = ., FUN = dart_count, mc.cores = parallel.core) %>%
        dplyr::bind_rows(.) %>%
        dplyr::bind_cols(grouping.column) %>%
        dplyr::select(MARKERS, CHROM, LOCUS, POS, REF, ALT, INDIVIDUALS, GT,
                      GT_VCF, GT_VCF_NUC, GT_BIN, ALLELE_REF_DEPTH,
                      ALLELE_ALT_DEPTH, CALL_RATE, AVG_COUNT_REF, AVG_COUNT_SNP,
                      REP_AVG)
      grouping.column <- markers.split <- NULL

    }
  }#End binary (2-row format) DArT file


  # Strata file ----------------------------------------------------------------
  # ind.char <- unique(stringi::stri_detect_regex(
  #   str = unique(input$INDIVIDUALS),
  #   pattern = "[A-Za-z]"))
  # input.ind.class <- is.character(input$INDIVIDUALS)
  # if (input.ind.class && !ind.char) input$INDIVIDUALS <- as.integer(input$INDIVIDUALS)

  input <- dplyr::left_join(input, strata.df, by = "INDIVIDUALS")

  if (tibble::has_name(input, "NEW_ID")) {
    input <- input %>%
      dplyr::select(-INDIVIDUALS) %>%
      dplyr::rename(INDIVIDUALS = NEW_ID)
  }

  if (tibble::has_name(input, "STRATA")) {
    input <- dplyr::rename(input, POP_ID = STRATA)
  }

  input <- dplyr::select(
    input,
    MARKERS, CHROM, LOCUS, POS, REF, ALT, INDIVIDUALS, POP_ID,
    GT, GT_VCF, GT_VCF_NUC, GT_BIN,
    CALL_RATE, AVG_COUNT_REF, AVG_COUNT_SNP, REP_AVG, dplyr::everything())

  # Results --------------------------------------------------------------------
  if (verbose) {
    n.pop <- dplyr::n_distinct(input$POP_ID)
    n.ind <- dplyr::n_distinct(input$INDIVIDUALS)
    n.chrom <- dplyr::n_distinct(input$CHROM)
    n.locus <- dplyr::n_distinct(input$LOCUS)
    n.snp <- dplyr::n_distinct(input$MARKERS)
    message("Number of populations: ", n.pop)
    message("Number of individuals: ", n.ind)
    message("Number of chrom: ", n.chrom)
    message("Number of locus: ", n.locus)
    message("Number of SNPs: ", n.snp)
    timing <- proc.time() - timing
    message("\nComputation time: ", round(timing[[3]]), " sec")
  }
  options(width = opt.change)
  return(input)
}#End tidy_dart
