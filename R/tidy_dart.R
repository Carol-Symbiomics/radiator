# Import, filter and transform a dart output file to different formats

#' @name tidy_dart

#' @title Tidy \href{http://www.diversityarrays.com}{DArT} output file.

#' @description Used internally in \href{https://github.com/thierrygosselin/radiator}{radiator}
#' and might be of interest for users. The function generate a tidy dataset using
#' \href{http://www.diversityarrays.com}{DArT} file.

#' @param data DArT output file. Note that most popular format used by DArT are
#' recognised. If you encounter a problem, sent me your data so that I can update
#' the function. The data is a tab delimited file (.tsv).

#' @param strata A tab delimited file with columns header:
#' \code{INDIVIDUALS} and \code{STRATA}.
#' Note: the column \code{STRATA} refers to any grouping of individuals. If a third column
#' named \code{NEW_ID} is used, this column will be used to replace the
#' \code{INDIVIDUALS} column in the main data file.

#' @inheritParams tidy_genomic_data

#' @return A tidy dataframe with these columns:
#' \enumerate{
#' \item MARKERS: generated by radiator and correspond to CHROM + LOCUS + POS separated by 2 underscores.
#' \item CHROM: the chromosome, for de novo: CHROM_1.
#' \item LOCUS: the locus.
#' \item POS: the SNP id on the LOCUS.
#' \item REF: the reference allele.
#' \item ALT: the alternate allele.
#' \item INDIVIDUALS: the sample name.
#' \item POP_ID: populations id of the sample.
#' \item GT: the genotype in 6 digit format Ã  la genepop.
#' \item GT_VCF: the genotype in VCF format.
#' \item GT_VCF_NUC: the genotype in VCF format, but keeping the nucleotide information.
#' \item GT_BIN: the genotype in binary format similar to PLINK. The number correspond to the number of alternate allele in the genotype.
#' \item CALL_RATE: call rate output specific of DArT.
#' \item AVG_COUNT_REF: the coverage for the reference allele, output specific of DArT.
#' \item AVG_COUNT_SNP: the coverage for the alternate allele, output specific of DArT.
#' \item REP_AVG: the reproducibility average, output specific of DArT.
#' }

#' @export
#' @rdname tidy_dart
#' @importFrom dplyr group_by select rename filter mutate summarise distinct n_distinct arrange left_join semi_join anti_join inner_join full_join tally bind_rows
#' @importFrom parallel detectCores
#' @importFrom stringi stri_replace_all_fixed stri_join stri_sub stri_replace_na stri_pad_left
#' @importFrom purrr discard
#' @importFrom data.table fread melt.data.table as.data.table dcast.data.table
#' @importFrom readr read_tsv write_tsv
#' @importFrom tibble as_data_frame data_frame
#' @importFrom tidyr spread gather unite separate

#' @examples
#' \dontrun{
#' clownfish.dart.tidy <- radiator::tidy_dart(
#' data = "clownfish.dart.tsv",
#' strata = "clownfish.strata.tsv",
#' verbose = TRUE)
#' }

#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com} and Peter Grewe \email{peter.grewe@csiro.au}

tidy_dart <- function(
  data,
  strata,
  verbose = FALSE,
  parallel.core = parallel::detectCores() - 1
) {
  opt.change <- getOption("width")
  options(width = 70)
  # for timing
  timing <- proc.time()

  # Checking for missing and/or default arguments ------------------------------
  if (missing(data)) stop("Input file missing")
  if (missing(strata)) stop("strata file missing")

  # Check DArT format file -----------------------------------------------------
  data.type <- readChar(con = data, nchars = 16L, useBytes = TRUE)
  dart.with.header <- stringi::stri_detect_fixed(str = data.type, pattern = "*\t")
  if (dart.with.header) {
    temp.file <- suppressWarnings(suppressMessages(readr::read_table(file = data, n_max = 20, col_names = "HEADER")))
    skip.number <- which(stringi::stri_detect_fixed(str = temp.file$HEADER,
                                                    pattern = "AlleleID")) - 1
    data.type <- readr::read_lines(file = data, skip = skip.number, n_max = skip.number + 1)[1] %>%
      stringi::stri_sub(str = ., from = 1, to = 16)
  } else {
    skip.number <- 0
  }
  dart.clone.id <- stringi::stri_detect_fixed(str = data.type, pattern = "CloneID")
  dart.allele.id <- stringi::stri_detect_fixed(str = data.type, pattern = "AlleleID")

  if (dart.clone.id || dart.allele.id) {
    data.type <- "dart"
  } else {
    stop("Contact author to show your DArT data, problem duting import")
  }
  if (verbose) message("Importing DArT data")

  # Strata file ------------------------------------------------------------------
  strata.df <- suppressMessages(readr::read_tsv(file = strata, col_names = TRUE))

  # Import data ---------------------------------------------------------------
  colnames.keeper <- c(c("AlleleID", "SNP", "SnpPosition", "CallRate",
                         "AvgCountRef", "AvgCountSnp", "RepAvg"),
                       strata.df$INDIVIDUALS)

  input <- suppressWarnings(
    data.table::fread(
      input = data,
      skip = skip.number,
      sep = "\t",
      stringsAsFactors = FALSE,
      header = TRUE,
      na.strings = "-",
      strip.white = TRUE,
      select = colnames.keeper,
      showProgress = TRUE,
      verbose = FALSE
    ) %>%
      tibble::as_data_frame(.) %>%
      dplyr::rename(LOCUS = AlleleID, POS = SnpPosition, CALL_RATE = CallRate,
                    AVG_COUNT_REF = AvgCountRef, AVG_COUNT_SNP = AvgCountSnp,
                    REP_AVG = RepAvg) %>%
      dplyr::arrange(LOCUS, POS)
  )

  # Screen for duplicate names -------------------------------------------------
  remove.list <- c("LOCUS", "SNP", "POS", "CALL_RATE", "AVG_COUNT_REF",
                   "AVG_COUNT_SNP", "REP_AVG")
  individuals.df <- tibble::data_frame(
    INDIVIDUALS = purrr::discard(.x = colnames(input),
                                 .p = colnames(input) %in% remove.list))
  duplicate.individuals <- length(individuals.df$INDIVIDUALS) - dplyr::n_distinct(individuals.df$INDIVIDUALS)
  if (duplicate.individuals > 0) {
    stop(stringi::stri_join("Duplicated individuals names found in the data set.\nNumber of duplicate names = ", duplicate.individuals))
  }
  # removing unused object
  remove.list <- individuals.df <- duplicate.individuals <- NULL

  # Tidying data ---------------------------------------------------------------
  input <- suppressWarnings(
    input %>%
      tidyr::separate(col = LOCUS, into = c("LOCUS", "NOT_USEFUL"), sep = "\\|", extra = "drop") %>%
      dplyr::select(-NOT_USEFUL) %>%
      tidyr::separate(col = SNP, into = c("NOT_USEFUL", "KEEPER"), sep = ":", extra = "drop") %>%
      dplyr::select(-NOT_USEFUL) %>%
      tidyr::separate(col = KEEPER, into = c("REF", "ALT"), sep = ">") %>%
      dplyr::mutate(
        CHROM = rep("CHROM_1", n()),
        MARKERS = stringi::stri_join(CHROM, LOCUS, POS, sep = "__"))
  )

  # Determine the type of DArT file
  # binary = 2-row-format

  binary <- anyDuplicated(input$LOCUS)

  if (binary != 2) {
    if (verbose) message("Tidying DArT data...")

    input <- data.table::melt.data.table(
      data = data.table::as.data.table(input),
      id.vars = c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "CALL_RATE", "AVG_COUNT_REF", "AVG_COUNT_SNP", "REP_AVG"),
      variable.name = "INDIVIDUALS",
      variable.factor = FALSE,
      value.name = "GT"
    ) %>%
      tibble::as_data_frame(.)

    n.row <- nrow(input)
    # as.integer is usually twice as light as numeric vector...
    split.vec <- as.integer(floor((parallel.core * 3 * (1:n.row - 1) / n.row) + 1))
    n.row <- NULL

    dart2gt <- function(x) {
      res <- x %>%
        dplyr::mutate(
          R = REF,
          A = ALT,
          R = stringi::stri_replace_all_fixed(
            str = R, pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"), vectorize_all = FALSE),
          A = stringi::stri_replace_all_fixed(
            str = A, pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"), vectorize_all = FALSE),
          GT = as.character(GT),
          GT = stringi::stri_replace_all_fixed(
            str = GT, pattern = c("0", "1", "2"),
            replacement = c("RR", "AA", "RA"),
            vectorize_all = FALSE),
          GT_BIN = dplyr::if_else(GT == "RR", 0, dplyr::if_else(GT == "AA", 2, 1)),
          GT_VCF = dplyr::if_else(GT == "RR", "0/0",
                                  dplyr::if_else(GT == "AA", "1/1", "0/1"), missing = "./."),
          GT_VCF_NUC = dplyr::if_else(GT == "RR", stringi::stri_join(REF, REF, sep = "/"),
                                      dplyr::if_else(GT_VCF == "1/1", stringi::stri_join(ALT, ALT, sep = "/"),
                                                     stringi::stri_join(REF, ALT, sep = "/")), missing = "./."),
          GT = dplyr::if_else(GT == "RR", stringi::stri_join(R, R, sep = ""),
                              dplyr::if_else(GT == "AA", stringi::stri_join(A, A, sep = ""),
                                             stringi::stri_join(R, A, sep = "")), "000000")
        ) %>%
        dplyr::select(GT, GT_VCF, GT_VCF_NUC, GT_BIN)
      return(res)
    }

    input <- dplyr::bind_cols(
      dplyr::select(input, -GT),
      dplyr::select(input, GT, REF, ALT) %>%
        split(x = ., f = split.vec) %>%
        .radiator_parallel(
          X = ., FUN = dart2gt, mc.cores = parallel.core) %>%
        dplyr::bind_rows(.)
    )
    split.vec <- NULL
  }

  if (binary == 2) {
    if (verbose) message("Tidying DArT 2-row-format data...")

    # necessary to deal with the duplication of lines because of the GT in 2 lines
    grouping.col <- c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT",
                      "CALL_RATE", "AVG_COUNT_REF", "AVG_COUNT_SNP", "REP_AVG")

    grouping.column <- dplyr::ungroup(input) %>%
      dplyr::select(dplyr::one_of(grouping.col)) %>%
      dplyr::filter(!is.na(REF) | !is.na(ALT)) %>%
      dplyr::distinct(MARKERS, CHROM, LOCUS, POS, REF, ALT, CALL_RATE, AVG_COUNT_REF,
                      AVG_COUNT_SNP, REP_AVG, .keep_all = TRUE)

    ref.info <- dplyr::distinct(grouping.column, MARKERS, REF, ALT)

    markers.split <- dplyr::distinct(grouping.column, MARKERS) %>%
      dplyr::mutate(SPLIT_VEC = as.integer(floor((parallel.core * 100 * (1:n() - 1) / n()) + 1)))

    dart_binary <- function(x) {
      res <- dplyr::select(x, -SPLIT_VEC) %>%
        data.table::as.data.table(.) %>%
        data.table::dcast.data.table(
          data = .,
          formula = MARKERS + INDIVIDUALS + REF + ALT ~ ALLELES,
          fun.aggregate = function(y) paste(y, collapse = "_"),
          value.var = "GT"
        ) %>%
        tibble::as_data_frame(.) %>%
        dplyr::mutate(
          R = REF,
          A = ALT,
          R = stringi::stri_replace_all_fixed(
            str = R, pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"), vectorize_all = FALSE),
          A = stringi::stri_replace_all_fixed(
            str = A, pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"), vectorize_all = FALSE),
          GT = dplyr::if_else(GT == "1_0", "RR",
                              dplyr::if_else(GT == "0_1", "AA",
                                             dplyr::if_else(GT == "1_1", "RA", NA_character_))),
          GT_BIN = dplyr::if_else(GT == "RR", 0, dplyr::if_else(GT == "AA", 2, 1)),
          GT_VCF = dplyr::if_else(GT == "RR", "0/0",
                                  dplyr::if_else(GT == "AA", "1/1", "0/1"), missing = "./."),
          GT_VCF_NUC = dplyr::if_else(GT == "RR", stringi::stri_join(REF, REF, sep = "/"),
                                      dplyr::if_else(GT_VCF == "1/1", stringi::stri_join(ALT, ALT, sep = "/"),
                                                     stringi::stri_join(REF, ALT, sep = "/")), missing = "./."),
          GT = dplyr::if_else(GT == "RR", stringi::stri_join(R, R, sep = ""),
                              dplyr::if_else(GT == "AA", stringi::stri_join(A, A, sep = ""),
                                             stringi::stri_join(R, A, sep = "")), missing = "000000")
        ) %>%
        dplyr::select(MARKERS, INDIVIDUALS, GT, GT_VCF, GT_VCF_NUC, GT_BIN)
      return(res)
    }

    input <- input %>%
      dplyr::select(-c(CHROM, LOCUS, POS, CALL_RATE, AVG_COUNT_REF,
                       AVG_COUNT_SNP, REP_AVG, REF, ALT)) %>%
      tidyr::gather(INDIVIDUALS, GT, -MARKERS) %>%
      dplyr::mutate(
        GT = as.character(GT),
        ALLELES = rep("GT", n())
      ) %>%
      dplyr::left_join(ref.info, by = "MARKERS") %>%
      dplyr::left_join(markers.split, by = "MARKERS") %>%
      split(x = ., f = .$SPLIT_VEC) %>%
      .radiator_parallel(
        X = ., FUN = dart_binary, mc.cores = parallel.core) %>%
      dplyr::bind_rows(.) %>%
      dplyr::left_join(grouping.column, by = "MARKERS") %>%
      dplyr::select(MARKERS, CHROM, LOCUS, POS, REF, ALT, INDIVIDUALS, GT,
                    GT_VCF, GT_VCF_NUC, GT_BIN, CALL_RATE, AVG_COUNT_REF,
                    AVG_COUNT_SNP, REP_AVG)

    grouping.column <- ref.info <- markers.split <- NULL # remove unused object
  }

  # Strata file ----------------------------------------------------------------
  input <- dplyr::left_join(input, strata.df, by = "INDIVIDUALS")

  if (ncol(strata.df) == 3) {
    input <- input %>%
      dplyr::select(-INDIVIDUALS) %>%
      dplyr::rename(INDIVIDUALS = NEW_ID)
  }

  if (tibble::has_name(input, "STRATA")) {
    input <- dplyr::rename(input, POP_ID = STRATA)
  }

  input <- dplyr::select(
    input,
    MARKERS, CHROM, LOCUS, POS, REF, ALT, INDIVIDUALS, POP_ID,
    GT, GT_VCF, GT_VCF_NUC, GT_BIN,
    CALL_RATE, AVG_COUNT_REF, AVG_COUNT_SNP, REP_AVG, dplyr::everything())

  # Results --------------------------------------------------------------------
  if (verbose) {
    n.pop <- dplyr::n_distinct(input$POP_ID)
    n.ind <- dplyr::n_distinct(input$INDIVIDUALS)
    n.chrom <- dplyr::n_distinct(input$CHROM)
    n.locus <- dplyr::n_distinct(input$LOCUS)
    n.snp <- dplyr::n_distinct(input$MARKERS)
    message("Number of populations: ", n.pop)
    message("Number of individuals: ", n.ind)
    message("Number of chrom: ", n.chrom)
    message("Number of locus: ", n.locus)
    message("Number of SNPs: ", n.snp)
    timing <- proc.time() - timing
    message("\nComputation time: ", round(timing[[3]]), " sec")
  }
  options(width = opt.change)
  return(input)
}#End tidy_dart
