# Filter/blacklist individuals

#' @name filter_individuals

#' @title Filter individuals based on genotyping/missingness rate,
#' heterozygosity and total coverage

#' @description Remove individuals with bad QC based on:
#' \itemize{
#' \item missingness (genotyping rate)
#' \item heterozygosity
#' \item coverage (total)
#' }
#'
#' \strong{Filter targets}: Individuals
#'
#' \strong{Statistics}: Missingness, heterozygosity and total coverage
#'
#' Used internally in \href{https://github.com/thierrygosselin/radiator}{radiator}
#' and might be of interest for users who wants to blacklist individuals.

#' @param data (2 options) A Genomic Data Structure (GDS)
#' file or object generated by radiator.
#'
#' \emph{How to get GDS?}
#' Look into:
#' \code{\link{write_seqarray}} or
#' \code{\link{tidy_vcf}}.


#' @param filter.individuals.missing (optional, double) A proportion above which the individuals are
#' blacklisted and removed from the dataset.
#' Default: \code{filter.individuals.missing = NULL}.

#' @param filter.individuals.heterozygosity (optional, string of doubles) A proportion below and
#' above which the individuals are blacklisted and removed from the dataset.
#' Default: \code{filter.individuals.heterozygosity = NULL}.

#' @param filter.individuals.coverage.total (optional, string of doubles) A proportion below and
#' above which the individuals are blacklisted and removed from the dataset.
#' Default: \code{filter.individuals.coverage.total = NULL}.

#' @inheritParams radiator_common_arguments

#' @return A list with the filtered input and blacklist of individuals.

#' @export
#' @rdname filter_individuals

#' @seealso
#' \code{\link{filter_rad}}
#' \code{\link{tidy_genomic_data}}, \code{\link{write_seqarray}},
#' \code{\link{tidy_vcf}}.

#' @examples
#' \dontrun{
#' require(SeqVarTools)
#'
#' # blacklisting outliers individuals:
#' id.qc <- radiator::filter_individuals(
#'     data = "my.radiator.gds.rad",
#'     filter.individuals.missing = "outliers",
#'     filter.individuals.heterozygosity = "outliers",
#'     filter.individuals.coverage.total = "outliers")
#'
#' # using values to blacklist individuals:
#' id.qc <- radiator::filter_individuals(
#'     data = "my.radiator.gds.rad",
#'     filter.individuals.missing = 0.5,
#'     filter.individuals.heterozygosity = c(0.02, 0.03),
#'     filter.individuals.coverage.total = c(900000, 5000000))
#'
#' }

#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com}


filter_individuals <- function(
  interactive.filter = TRUE,
  data,
  filter.individuals.missing = NULL,
  filter.individuals.heterozygosity = NULL,
  # coverage.mean = NULL,
  filter.individuals.coverage.total = NULL,
  parallel.core = parallel::detectCores() - 1,
  verbose = TRUE,
  ...
) {
  if (interactive.filter ||
      !is.null(filter.individuals.missing) ||
      !is.null(filter.individuals.heterozygosity) ||
      !is.null(filter.individuals.coverage.total)
  ) {
    if (interactive.filter) verbose <- TRUE
    if (verbose) {
      cat("################################################################################\n")
      cat("######################### radiator::filter_individuals #########################\n")
      cat("################################################################################\n")
    }
    # Cleanup---------------------------------------------------------------------
    file.date <- format(Sys.time(), "%Y%m%d@%H%M")
    if (verbose) message("Execution date/time: ", file.date)
    old.dir <- getwd()
    opt.change <- getOption("width")
    options(width = 70)
    timing <- proc.time()# for timing
    #back to the original directory and options
    on.exit(setwd(old.dir), add = TRUE)
    on.exit(options(width = opt.change), add = TRUE)
    on.exit(timing <- proc.time() - timing, add = TRUE)
    on.exit(if (verbose) message("\nComputation time, overall: ", round(timing[[3]]), " sec"), add = TRUE)
    on.exit(if (verbose) cat("################################## completed ###################################\n"), add = TRUE)

    # Function call and dotslist -------------------------------------------------
    rad.dots <- radiator_dots(
      fd = rlang::fn_fmls_names(),
      args.list = as.list(environment()),
      dotslist = rlang::dots_list(..., .homonyms = "error", .check_assign = TRUE),
      keepers = c("id.stats", "path.folder", "parameters", "dp", "subsample", "subsample.markers.stats", "internal"),
      verbose = verbose
    )

    # Checking for missing and/or default arguments ----------------------------
    if (missing(data)) rlang::abort("data is missing")

    # Folders---------------------------------------------------------------------
    path.folder <- generate_folder(
      f = path.folder,
      rad.folder = "filter_individuals",
      internal = internal,
      file.date = file.date,
      verbose = verbose)

    # write the dots file
    write_rad(
      data = rad.dots,
      path = path.folder,
      filename = stringi::stri_join("radiator_filter_individuals_args_", file.date, ".tsv"),
      tsv = TRUE,
      internal = internal,
      verbose = verbose
    )

    # Message about steps taken during the process -----------------------------
    if (interactive.filter) {
      message("Interactive mode: on\n")
      message("Step 1. Visualization")
      message("Step 2. Missingness")
      message("Step 3. Heterozygosity")
      message("Step 4. Total Coverage (if available)\n\n")
    }

    # Detect format --------------------------------------------------------------
    data.type <- radiator::detect_genomic_format(data)

    # Import data ---------------------------------------------------------------
    if (!data.type %in% c("SeqVarGDSClass", "gds.file")) {
      rlang::abort("Input not supported for this function: read function documentation")
    }
    if (data.type == "gds.file") {
      data <- radiator::read_rad(data, verbose = verbose)
      data.type <- "SeqVarGDSClass"
    }
    if (!"SeqVarTools" %in% utils::installed.packages()[,"Package"]) {
      rlang::abort('Please install SeqVarTools for this option:\n
         install.packages("BiocManager")
         BiocManager::install("SeqVarTools")')
    }


    # Filter parameter file: generate and initiate -------------------------------
    filters.parameters <- update_parameters(
      generate = TRUE,
      initiate = TRUE,
      update = FALSE,
      parameter.obj = parameters,
      data = data,
      path.folder = path.folder,
      file.date = file.date,
      verbose = verbose)

    # stats  ---------------------------------------------------------------------
    # Step 1. Visuals ----------------------------------------------------------
    if (interactive.filter) message("\nStep 1. Visualization of samples QC\n")
    if (is.null(id.stats)) {
      if (is.null(subsample)) {
        if (is.null(subsample.markers.stats)) subsample.markers.stats <- 0.2
        variant.id <- SeqArray::seqGetData(
          gdsfile = data, var.name = "variant.id")
        n.markers <- length(variant.id)
        if (n.markers > 200000) {
          variant.select <- sample(
            x = variant.id,
            size = round(subsample.markers.stats * n.markers, 0))
        } else {
          subsample <- FALSE
          variant.select <- NULL
        }
      } else {
        variant.select <- subsample
      }


      id.stats <- generate_id_stats(
        gds = data,
        subsample = variant.select,
        depth.info = dp,
        path.folder = path.folder,
        file.date = file.date,
        parallel.core = parallel.core,
        verbose = verbose)
      print(id.stats$fig)
      # res$individuals <- id.stats$info %>%
      #   readr::write_tsv(x = ., path = file.path(path.folder, ind.file))
    }
    # Step 2. Missingness-----------------------------------------------------------------
    if (interactive.filter) {
      message("\nStep 2. Filtering markers based individual missingness/genotyping\n")

      filter.individuals.missing <- interactive_question(
        x = "Do you want to blacklist samples based on missingness ? (y/n):",
        answer.opt = c("y", "n"))

      if (filter.individuals.missing == "y") {
        outlier.stats <- interactive_question(
          x = "Do you want to remove samples based on the outlier statistics or not (y/n) ?
(n: next question will be to enter your own threshold)", answer.opt = c("y", "n"))
        if (outlier.stats == "y") {
          filter.individuals.missing <- "outliers"
        } else {
          filter.individuals.missing <- interactive_question(
            x = "Enter the proportion threshold (0-1)
The maximum amount of missingness you tolerate for a sample:", minmax = c(0, 1))
        }
        outlier.stats <- NULL
      } else {
        filter.individuals.missing <- NULL
      }
    }
    if (!is.null(filter.individuals.missing)) {

      if (!purrr::is_double(filter.individuals.missing)) {
        outlier.id.missing <- floor(id.stats$stats$OUTLIERS_HIGH[1]*100)/100
        message("\nRemoving outliers individuals based on genotyping statistics: ", outlier.id.missing)
        filter.individuals.missing <- outlier.id.missing
      } else {
        message("\nRemoving individuals based on genotyping statistics: ", filter.individuals.missing)
      }

      bl <- id.stats$info %>%
        dplyr::filter(MISSING_PROP > filter.individuals.missing) %>%
        dplyr::ungroup(.) %>%
        dplyr::distinct(INDIVIDUALS) %>%
        dplyr::mutate(FILTER = "filter.individuals.missing")
      n.bl <- nrow(bl)
      if (n.bl > 0) {
        if (verbose) message("    number of individuals blacklisted based on missing genotypes: ", n.bl)
        bl.filename <- stringi::stri_join("blacklist.individuals.missing_", file.date, ".tsv")
        readr::write_tsv(x = bl, path = file.path(path.folder, bl.filename))
        bl.i <- update_bl_individuals(gds = data, update = bl)

        id.stats$info  %<>%
          dplyr::filter(!INDIVIDUALS %in% bl$INDIVIDUALS)

        radiator.gds <- gdsfmt::index.gdsn(
          node = data, path = "radiator", silent = TRUE)

        # update the GDS
        gdsfmt::add.gdsn(
          node = radiator.gds,
          name = "individuals",
          val = id.stats$info,
          replace = TRUE,
          compress = "ZIP_RA",
          closezip = TRUE)

        sync_gds(gds = data, samples = id.stats$info$INDIVIDUALS)

        # Filter parameter file: update
        filters.parameters <- update_parameters(
          generate = FALSE,
          initiate = FALSE,
          update = TRUE,
          parameter.obj = filters.parameters,
          data = data,
          filter.name = "Filter individuals based on missingness (with outlier stats or values)",
          param.name = "filter.individuals.missing",
          values = filter.individuals.missing,
          path.folder = path.folder,
          file.date = file.date,
          verbose = verbose)

        if (verbose) {
          message("Number of individuals / strata / chrom / locus / SNP:")
          message("    Before: ", filters.parameters$filters.parameters$BEFORE)
          message("    Blacklisted: ", filters.parameters$filters.parameters$BLACKLIST)
          message("    After: ", filters.parameters$filters.parameters$AFTER)
        }
      }
    }#End filter.individuals.missing

    # Step 3. Heterozygosity------------------------------------------------------------
    if (interactive.filter) {
      message("\nStep 3. Filtering markers based on individual heterozygosity\n")

      filter.individuals.heterozygosity <- interactive_question(
        x = "Do you want to blacklist samples based on heterozygosity ? (y/n):",
        answer.opt = c("y", "n"))

      if (filter.individuals.heterozygosity == "y") {
        outlier.stats <- interactive_question(
          x = "Do you want to remove samples based on the outliers statistics or not (y/n) ?
(n: next questions will be to enter your own thresholds)", answer.opt = c("y", "n"))
        if (outlier.stats == "y") {
          filter.individuals.heterozygosity <- "outliers"
        } else {
          filter.individuals.heterozygosity <- c(0,1)
          filter.individuals.heterozygosity[1] <- interactive_question(
            x = "Enter the min proportion threshold (0-1)
The minimum amount of heterozygosity you tolerate for a sample:", minmax = c(0, 1))
          filter.individuals.heterozygosity[2] <- interactive_question(
            x = "Enter the max proportion threshold (0-1)
The maximum amount of heterozygosity you tolerate for a sample:", minmax = c(0, 1))
        }
        outlier.stats <- NULL
      } else {
        filter.individuals.heterozygosity <- NULL
      }
    }
    if (!is.null(filter.individuals.heterozygosity)) {
      if (length(filter.individuals.heterozygosity) > 1) {
        het.low <- filter.individuals.heterozygosity[1]
        het.high <- filter.individuals.heterozygosity[2]
        if (verbose) message("\nRemoving individuals based on heterozygosity statistics: ", het.low, " / ", het.high)
      } else {
        if (is.character(filter.individuals.heterozygosity)) {
          het.low <- floor(id.stats$stats$OUTLIERS_LOW[2]*1000)/1000
          het.high <- floor(id.stats$stats$OUTLIERS_HIGH[2]*1000)/1000
          if (verbose) message("\nRemoving outliers individuals based on heterozygosity statistics: ", het.low, " / ", het.high)
        } else {
          rlang::abort("Unknown filter.individuals.heterozygosity thresholds used")
        }
      }

      bl <- id.stats$info %>%
        dplyr::filter(HETEROZYGOSITY > het.high | HETEROZYGOSITY < het.low) %>%
        dplyr::ungroup(.) %>%
        dplyr::distinct(INDIVIDUALS) %>%
        dplyr::mutate(FILTER = "filter.individuals.heterozygosity")
      n.bl <- nrow(bl)
      if (n.bl > 0) {
        if (verbose) message("    number of individuals blacklisted based on heterozygosity: ", n.bl)
        bl.filename <- stringi::stri_join("blacklist.individuals.heterozygosity_", file.date, ".tsv")
        readr::write_tsv(x = bl, path = file.path(path.folder, bl.filename))
        bl.i <- update_bl_individuals(gds = data, update = bl)
        id.stats$info  %<>%
          dplyr::filter(!INDIVIDUALS %in% bl$INDIVIDUALS)

        update_radiator_gds(gds = data, node.name = "individuals", value = id.stats$info, sync = TRUE)


        # radiator.gds <- gdsfmt::index.gdsn(
        #   node = data, path = "radiator", silent = TRUE)
        #
        # # update the GDS
        # gdsfmt::add.gdsn(
        #   node = radiator.gds,
        #   name = "individuals",
        #   val = id.stats$info,
        #   replace = TRUE,
        #   compress = "ZIP_RA",
        #   closezip = TRUE)

        # sync_gds(gds = data, samples = id.stats$info$INDIVIDUALS)

        # Filter parameter file: update
        filters.parameters <- update_parameters(
          generate = FALSE,
          initiate = FALSE,
          update = TRUE,
          parameter.obj = filters.parameters,
          data = data,
          filter.name = "Filter individuals based on heterozygosity (with outlier stats or values)",
          param.name = "filter.individuals.heterozygosity",
          values = paste(het.low, het.high, collapse = " / "),
          path.folder = path.folder,
          file.date = file.date,
          verbose = verbose)

        if (verbose) {
          message("Number of individuals / strata / chrom / locus / SNP:")
          message("    Before: ", filters.parameters$filters.parameters$BEFORE)
          message("    Blacklisted: ", filters.parameters$filters.parameters$BLACKLIST)
          message("    After: ", filters.parameters$filters.parameters$AFTER)
        }
      }
    }#End filter.individuals.heterozygosity

    # Step 4. Coverage total--------------------------------------------------------------
    if (dp) {
      if (interactive.filter) {
        message("\nStep 4. Filtering markers based on individual's total coverage\n")

        filter.individuals.coverage.total <- interactive_question(
          x = "Do you want to blacklist samples based on total coverage ? (y/n):",
          answer.opt = c("y", "n"))

        if (filter.individuals.coverage.total == "y") {
          outlier.stats <- interactive_question(
            x = "Do you want to remove samples based on the outliers statistics or not (y/n) ?
          (n: next questions will be to enter your own thresholds)", answer.opt = c("y", "n"))
          if (outlier.stats == "y") {
            filter.individuals.coverage.total <- "outliers"
          } else {
            filter.individuals.coverage.total <- c(0,10000000000000000000000)
            filter.individuals.coverage.total[1] <- interactive_question(
              x = "Enter the min proportion threshold (0-1)
            The minimum amount of coverage you tolerate for a sample:", minmax = c(0, 10000000000000000000000))
            filter.individuals.coverage.total[2] <- interactive_question(
              x = "Enter the max proportion threshold (0-1)
            The maximum amount of coverage you tolerate for a sample:", minmax = c(0, 10000000000000000000000))
          }
          outlier.stats <- NULL
        } else {
          filter.individuals.coverage.total <- NULL
        }
      }
      if (!is.null(filter.individuals.coverage.total)) {
        if (length(filter.individuals.coverage.total) > 1) {
          cov.low <- filter.individuals.coverage.total[1]
          cov.high <- filter.individuals.coverage.total[2]
          if (verbose) message("\nRemoving individuals based on total coverage statistics: ", cov.low, " / ", cov.high)
        } else {
          if (is.character(filter.individuals.coverage.total)) {
            cov.low <- floor(id.stats$stats$OUTLIERS_LOW[3]*1000)/1000
            cov.high <- floor(id.stats$stats$OUTLIERS_HIGH[3]*1000)/1000
            if (verbose) message("\nRemoving outliers individuals based on total coverage statistics: ", cov.low, " / ", cov.high)
          } else {
            rlang::abort("Unknown coverage total thresholds used")
          }
        }
        bl <- id.stats$info %>%
          dplyr::filter(COVERAGE_TOTAL > cov.high | COVERAGE_TOTAL < cov.low) %>%
          dplyr::ungroup(.) %>%
          dplyr::distinct(INDIVIDUALS) %>%
          dplyr::mutate(FILTER = "filter.individuals.coverage.total")
        n.bl <- nrow(bl)
        if (n.bl > 0) {
          if (verbose) message("    number of individuals blacklisted based on total coverage: ", n.bl)
          bl.filename <- stringi::stri_join("blacklist.individuals.coverate.total_", file.date, ".tsv")
          readr::write_tsv(x = bl, path = file.path(path.folder, bl.filename))
          bl.i <- update_bl_individuals(gds = data, update = bl)
          id.stats$info  %<>%
            dplyr::filter(!INDIVIDUALS %in% bl$INDIVIDUALS)

          radiator.gds <- gdsfmt::index.gdsn(
            node = data, path = "radiator", silent = TRUE)

          # update the GDS
          gdsfmt::add.gdsn(
            node = radiator.gds,
            name = "individuals",
            val = id.stats$info,
            replace = TRUE,
            compress = "ZIP_RA",
            closezip = TRUE)

          sync_gds(gds = data, samples = id.stats$info$INDIVIDUALS)

          # Filter parameter file: update
          filters.parameters <- update_parameters(
            generate = FALSE,
            initiate = FALSE,
            update = TRUE,
            parameter.obj = filters.parameters,
            data = data,
            filter.name = "Filter individuals based on total coverage (with outlier stats or values)",
            param.name = "filter.individuals.coverage.total",
            values = paste(cov.low, cov.high, collapse = " / "),
            path.folder = path.folder,
            file.date = file.date,
            verbose = verbose)

          if (verbose) {
            cat("################################### RESULTS ####################################\n")
            message("Filter individuals:")
            message("Number of individuals / strata / chrom / locus / SNP:")
            message("    Before: ", filters.parameters$filters.parameters$BEFORE)
            message("    Blacklisted: ", filters.parameters$filters.parameters$BLACKLIST)
            message("    After: ", filters.parameters$filters.parameters$AFTER)
          }
        }

      }#End coverage total
    }
    # MONOMORPHIC MARKERS --------------------------------------------------
    data <- filter_monomorphic(
      data = data,
      parallel.core = parallel.core,
      verbose = verbose,
      parameters = filters.parameters,
      path.folder = path.folder,
      internal = TRUE)
  }
  return(data)
}#End filter_individuals
