# Make genomic input file tidy

#' @name tidy_genomic_data
#' @title Transform common genomic dataset format in a tidy data frame
#' @description Transform genomic data set produced by massive parallel
#' sequencing pipeline (e.g.GBS/RADseq,
#' SNP chip, DArT, etc) into a tidy format. The use of blacklist and whitelist along
#' several filtering options are available to prune the dataset.
#' Several arguments are available to make your data population-wise and easily
#' rename the pop id.
#' Used internally in \href{https://github.com/thierrygosselin/radiator}{radiator}
#' and \href{https://github.com/thierrygosselin/assigner}{assigner}
#' and might be of interest for users.

#' @param data 12 options: VCF (SNPs or Haplotypes,
#' to make the vcf population ready, see details below),
#' plink, stacks haplotype file, genind (library(adegenet)),
#' genlight (library(adegenet)), gtypes (library(strataG)), genepop, DArT,
#' and a data frame in long/tidy or wide format.
#' \emph{See details} of \code{\link[radiator]{tidy_genomic_data}}.

#' @param vcf.metadata (optional, logical or string) For VCF files only.
#' With \code{logical, TRUE/FALSE}, \code{vcf.metadata = FALSE}, only the genotype
#' information is kept (GT field). With \code{vcf.metadata = TRUE},
#' all the metadata contained in the \code{FORMAT} field will be kept in
#' the tidy data file. radiator is currently keeping/cleaning only these metadata:
#' \code{"DP", "AD", "GL", "PL", "GQ", "GOF", "NR", "NV"}.
#' If you need different one, submit a request.
#' With \code{string}, explicitely ask for a particular FORMAT field you want
#' to keep (except the GT field that is always imported).
#' e.g. \code{vcf.metadata = "PL"} or \code{vcf.metadata = c("DP", "GL")}.
#' Default: \code{vcf.metadata = FALSE}.

#' @param whitelist.markers (optional) A whitelist containing CHROM (character
#' or integer) and/or LOCUS (integer) and/or
#' POS (integer) columns header. To filter by chromosome and/or locus and/or by snp.
#' The whitelist is an object in your
#' global environment or a file in the working directory (e.g. "whitelist.txt").
#' Note that \emph{de novo} CHROM column with 'un' need to be changed to 1.
#' In the VCF, the column ID is the LOCUS identification (VCF generated from
#' stacks have the SNP position on the read embedded in the ID,
#' so the ID = no longer represent the LOCUS). Marker names are cleaned of
#' separators that interfere with some packages or codes:
#' \code{/}, \code{:}, \code{-} and \code{.} are changed to an underscore
#' \code{_}.
#' Default \code{whitelist.markers = NULL} for no whitelist of markers.

#' @param monomorphic.out (optional) Should the monomorphic
#' markers present in the dataset be filtered out ?
#' Default: \code{monomorphic.out = TRUE}.

#' @param blacklist.genotype (optional) Useful to erase genotype with below
#' average quality, e.g. genotype with more than 2 alleles in diploid likely
#' sequencing errors or genotypes with poor genotype likelihood or coverage.
#' The blacklist has a minimum of 2 column headers (markers and individuals).
#' Markers can be 1 column (CHROM or LOCUS or POS),
#' a combination of 2 (e.g. CHROM and POS or CHROM and LOCUS or LOCUS and POS) or
#' all 3 (CHROM, LOCUS, POS). The markers columns must be designated: CHROM (character
#' or integer) and/or LOCUS (integer) and/or POS (integer). The id column designated
#' INDIVIDUALS (character) columns header.
#' The blacklist is an object in your global environment or
#' a file in the working directory (e.g. "blacklist.genotype.txt").
#' For de novo VCF, CHROM column
#' with 'un' need to be changed to 1.
#' Marker names are cleaned of
#' separators that interfere with some packages or codes:
#' \code{/}, \code{:}, \code{-} and \code{.} are changed to an underscore
#' \code{_}.
#' Ids are also cleaned of separators that interfere with some packages or codes:
#' \code{_} and \code{:} are changed to a dash \code{-}.
#' Default: \code{blacklist.genotype = NULL} for no blacklist of
#' genotypes to erase.

#' @param snp.ld (optional) \strong{For data with locus and SNP info, like VCF and DArT file}.
#' SNP short distance linkage disequilibrium pruning. With anonymous markers from
#' RADseq/GBS de novo discovery, you can minimize linkage disequilibrium (LD) by
#' choosing among these 4 options:
#' \code{snp.ld = "random"} for a random selection of 1 SNP on the read,
#' \code{snp.ld = "first"} for the first one on the read...,
#' \code{snp.ld = "last"} for the last SNP on the read and
#' \code{snp.ld = "middle"} for locus with > 2 SNPs/read the option to select at random
#' one SNP between the first and the last SNP on the read. If the locus as <= 2
#' SNPs on the read, the first one is selected. Note that for that last option,
#' the numbers are reported. For long distance linkage
#' disequilibrium pruning, see details below.
#' Default: \code{snp.ld = NULL}.

#' @param common.markers (optional) Logical. Default: \code{common.markers = TRUE},
#' will only keep markers in common (genotyped) between all the populations.

#' @param maf.thresholds (string, double, optional) String with
#' local/populations and global/overall maf thresholds, respectively.
#' e.g. \code{maf.thresholds = c(0.05, 0.1)} for a local maf threshold
#' of 0.05 and a global threshold of 0.1. Available for VCF, PLINK and data frame
#' files.
#' Default: \code{maf.thresholds = NULL}.

#' @param maf.approach (character, optional).
#' \code{maf.approach = "haplotype"} : looks at the minimum MAF found on the
#' read/haplotype. Using this option will discard all the markers/snp on
#' that read based on the thresholds chosen. This method is only available
#' for VCF and haplotype files, or tidy data frame from those file types.
#' \code{maf.approach = "SNP"} : treats all the SNP on the same
#' haplotype/read as independent. Doesn't work with haplotype file,
#' but does work for all other file type.
#' Default is \code{maf.approach = "SNP"}.

#' @param maf.operator (character, optional) \code{maf.operator = "AND"} or
#' default \code{maf.operator = "OR"}.
#' When filtering over LOCUS or SNP, do you want the local \code{"AND"}
#' global MAF to pass the thresholds, or ... you want the local \code{"OR"}
#' global MAF to pass the thresholds, to keep the marker?

#' @param maf.pop.num.threshold (integer, optional) When maf thresholds are used,
#' this argument is for the number of pop required to pass the maf thresholds
#' to keep the locus. Default: \code{maf.pop.num.threshold = 1}

#' @param max.marker (integer, optional) For large PLINK files,
#' useful to subsample marker number. e.g. if the data set
#' contains 200 000 markers and \code{max.marker = 10000}, 10000 markers are
#' subsampled randomly from the 200000 markers. If you need specific markers,
#' use \code{whitelist.markers} argument.
#' Default: \code{max.marker = NULL}.

#' @param blacklist.id (optional) A blacklist with individual ID and
#' a column header 'INDIVIDUALS'. The blacklist is an object in your
#' global environment or a file in the working directory
#' (e.g. "blacklist.txt").
#' Default: \code{blacklist.id = NULL}.

#' @param pop.levels (optional, string) This refers to the levels in a factor. In this
#' case, the id of the pop.
#' Use this argument to have the pop ordered your way instead of the default
#' alphabetical or numerical order. e.g. \code{pop.levels = c("QUE", "ONT", "ALB")}
#' instead of the default \code{pop.levels = c("ALB", "ONT", "QUE")}.
#' White spaces in population names are replaced by underscore.
#' Default: \code{pop.levels = NULL}.


#' @param pop.labels (optional, string) Use this argument to rename/relabel
#' your pop or combine your pop. e.g. To combine \code{"QUE"} and \code{"ONT"}
#' into a new pop called \code{"NEW"}:
#' (1) First, define the levels for your pop with \code{pop.levels} argument:
#' \code{pop.levels = c("QUE", "ONT", "ALB")}.
#' (2) then, use \code{pop.labels} argument:
#' \code{pop.levels = c("NEW", "NEW", "ALB")}.
#' To rename \code{"QUE"} to \code{"TAS"}:
#' \code{pop.labels = c("TAS", "ONT", "ALB")}.
#' Default: \code{pop.labels = NULL}. If you find this too complicated,
#' there is also the \code{strata} argument that can do the same thing,
#' see below.
#' White spaces in population names are replaced by underscore.


#' @param strata (optional/required) Required for VCF and haplotypes files,
#' optional for the other formats supported.
#'
#' The strata file is a tab delimited file with a minimum of 2 columns headers:
#' \code{INDIVIDUALS} and \code{STRATA}.
#' If a \code{strata} file is specified with all file formats that don't
#' require it, the strata argument will have precedence on the population
#' groupings used internally in those file formats.
#' The \code{STRATA} column can be any hierarchical grouping.
#' To create a strata file see \code{\link[radiator]{individuals2strata}}.
#' If you have already run
#' \href{http://catchenlab.life.illinois.edu/stacks/}{stacks} on your data,
#' the strata file is similar to a stacks \emph{population map file},
#' make sure you
#' have the required column names (\code{INDIVIDUALS} and \code{STRATA}).
#' The strata column is cleaned of a white spaces that interfere with some
#' packages or codes: space is changed to an underscore \code{_}
#' Default: \code{strata = NULL}.

#' @param pop.select (string, optional) Selected list of populations for
#' the analysis. e.g. \code{pop.select = c("QUE", "ONT")} to select \code{QUE}
#' and \code{ONT} population samples (out of 20 pops).
#' Default: \code{pop.select = NULL}

#' @param filename (optional) The function uses \code{\link[fst]{write.fst}},
#' to write the tidy data frame in
#' the working directory. The file extension appended to
#' the \code{filename} provided is \code{.rad}.
#' With default: \code{filename = NULL}, the tidy data frame is
#' in the global environment only (i.e. not written in the working directory...).

#' @param parallel.core (optional) The number of core used for parallel
#' execution during vcf import.
#' Default: \code{parallel::detectCores() - 1}.


#' @param verbose (optional, logical) When \code{verbose = TRUE}
#' the function is a little more chatty during execution.
#' Default: \code{verbose = TRUE}.


#' @details
#' \strong{Long distance SNP linkage disequilibrium pruning}
#' If you have markers position on a genome or a linkage map,
#' you can go further in removing linked markers by using
#' \href{https://github.com/zhengxwen/SNPRelate}{SNPRelate} or
#' \href{http://pngu.mgh.harvard.edu/~purcell/plink/}{PLINK}, \emph{linkage
#' disequilibrium based SNP pruning} option.
#'
#' \strong{Input files:}
#' \enumerate{
#' \item VCF biallelic file (e.g. \code{data = "batch_1.vcf"})
#' To make the VCF population ready, you need the \code{strata} argument.
#'
#' \item VCF haplotypic file (e.g. \code{data = "batch_1.haplotypes.vcf"})
#' To make the VCF population ready, you need the \code{strata} argument.
#'
#' \item haplotype file created in STACKS (e.g. \code{data = "batch_1.haplotypes.tsv"}).
#' To make the haplotype file population ready, you need the \code{strata} argument.
#'
#' \item Data frame
#' To discriminate the long from the wide format,
#' the function \pkg{radiator} \code{\link[radiator]{tidy_wide}} searches
#' for \code{MARKERS or LOCUS} in column names (TRUE = long format).
#' The data frame is tab delimitted.

#' \strong{Wide format:}
#' The wide format cannot store metadata info.
#' The wide format starts with these 2 id columns:
#' \code{INDIVIDUALS}, \code{POP_ID} (that refers to any grouping of individuals),
#' the remaining columns are the markers in separate columns storing genotypes.
#'
#' \strong{Long/Tidy format:}
#' The long format is considered to be a tidy data frame and can store metadata info.
#' (e.g. from a VCF see \pkg{radiator} \code{\link[radiator]{tidy_genomic_data}}). A minimum of 4 columns
#' are required in the long format: \code{INDIVIDUALS}, \code{POP_ID},
#' \code{MARKERS or LOCUS} and \code{GENOTYPE or GT}. The rest are considered metata info.
#'
#' \strong{2 genotypes formats are available:}
#' 6 characters no separator: e.g. \code{001002 of 111333} (for heterozygote individual).
#' 6 characters WITH separator: e.g. \code{001/002 of 111/333} (for heterozygote individual).
#' The separator can be any of these: \code{"/", ":", "_", "-", "."}.
#'
#' \emph{How to get a tidy data frame ?}
#' \pkg{radiator} \code{\link[radiator]{tidy_genomic_data}} can transform 11 genomic
#' data formats in a tidy data frame.
#'
#' \item PLINK file in
#' \code{tped/tfam} format (e.g. \code{data =  "data.assignment.tped"}).
#' The \code{tfam} file is found based on the name prefix of the supplied
#' \code{tped} file. The first 2 columns of the \code{tfam} file will be used
#' for the \code{strata} (population identification), unless the \code{strata}
#' argument is provided.
#' Columns 1, 3 and 4 of the \code{tped} are discarded. The remaining columns
#' correspond to the genotype in the format \code{01/04}
#' where \code{A = 01, C = 02, G = 03 and T = 04}. For \code{A/T} format, use
#' PLINK or bash to convert.
#' Use \href{http://vcftools.sourceforge.net/}{VCFTOOLS} with \code{--plink-tped}
#' to convert very large VCF file. For \code{.ped} file conversion to
#' \code{.tped} use \href{http://pngu.mgh.harvard.edu/~purcell/plink/}{PLINK}
#' with \code{--recode transpose}
#'
#' \item \code{\link[adegenet]{genind}} object from \code{\link[adegenet]{adegenet}}.
#'
#' \item \code{\link[adegenet]{genlight}} object from \code{\link[adegenet]{adegenet}}.
#'
#' \item \code{\link[strataG]{gtypes}} object from \code{\link[strataG]{strataG}}.
#'
#' \item \href{http://www.diversityarrays.com}{DArT} file.
#'
#' \item genepop data file (e.g. \code{data = "kiwi_data.gen"}). Here, the function can only use
#' alleles encoded with 3 digits.
#' }
#'
#'
#' \strong{GATK VCF files:} Some VCF have an \code{ID} column filled with \code{.},
#' the LOCUS information is all contained along the linkage group in the
#' \code{CHROM} column. To make it work with
#' \href{https://github.com/thierrygosselin/radiator}{radiator},
#' the \code{ID} column is filled with the \code{POS} column info.
#'
#' \strong{platypus VCF files:} Some VCF files don't have an ID filed with values,
#' here the same thing as GATK VCF files above is done.


#' @return The output in your global environment is a tidy data frame.
#' If \code{filename} is provided, the tidy data frame is also
#' written in the working directory with file extension \code{.rad}.
#' The file is written with the
#' \href{https://github.com/fstpackage/fst}{Lightning Fast Serialization of Data Frames for R} package.
#' To read the file back in R use \code{\link[fst]{read.fst}}.

#' @export
#' @rdname tidy_genomic_data
#' @importFrom dplyr select distinct n_distinct group_by ungroup rename arrange tally filter if_else mutate summarise left_join inner_join right_join anti_join semi_join full_join funs
#' @importFrom adegenet genind2df
# @importFrom strataG as.data.frame
#' @importFrom stringi stri_join stri_replace_all_fixed stri_extract_all_fixed stri_replace_all_regex stri_sub stri_pad_left stri_count_fixed stri_replace_na
#' @importFrom stats var median quantile
#' @importFrom purrr map flatten keep discard
#' @importFrom data.table fread as.data.table
#' @importFrom tidyr spread gather unite separate
#' @importFrom utils count.fields
#' @importFrom readr write_tsv read_tsv
#' @importFrom vcfR read.vcfR extract.gt vcf_field_names
#' @importFrom tibble as_data_frame has_name
#' @importFrom parallel detectCores
#' @importFrom pegas VCFloci read.vcf
#' @importFrom fst write.fst

#' @examples
#' \dontrun{
#' tidy.vcf <- tidy_genomic_data(
#' data = "batch_1.vcf",
#' whitelist.markers = "whitelist.vcf.txt",
#' snp.ld = NULL,
#' common.markers = TRUE,
#' blacklist.id = "blacklist.id.treefrog.tsv",
#' strata = "strata.treefrog.tsv",
#' pop.levels = c("PAN", "COS")
#' )
#' }


#' @references Catchen JM, Amores A, Hohenlohe PA et al. (2011)
#' Stacks: Building and Genotyping Loci De Novo From Short-Read Sequences.
#' G3, 1, 171-182.
#' @references Catchen JM, Hohenlohe PA, Bassham S, Amores A, Cresko WA (2013)
#' Stacks: an analysis tool set for population genomics.
#' Molecular Ecology, 22, 3124-3140.
#' @references Danecek P, Auton A, Abecasis G et al. (2011)
#' The variant call format and VCFtools.
#' Bioinformatics, 27, 2156-2158.
#' @references Purcell S, Neale B, Todd-Brown K, Thomas L, Ferreira MAR,
#' Bender D, et al.
#' PLINK: a tool set for whole-genome association and population-based linkage
#' analyses.
#' American Journal of Human Genetics. 2007: 81: 559–575. doi:10.1086/519795
#' @references Jombart T, Devillard S, Balloux F.
#' Discriminant analysis of principal components: a new method for the analysis
#' of genetically structured populations.
#' BMC Genet. 2010:11: 94. doi:10.1186/1471-2156-11-94
#' @references Jombart T, Ahmed I. adegenet 1.3-1: new tools for the analysis
#' of genome-wide SNP data.
#' Bioinformatics. 2011:27: 3070–3071. doi:10.1093/bioinformatics/btr521
#' @references Raymond M. & Rousset F, (1995).
#' GENEPOP (version 1.2): population genetics software for exact tests
#' and ecumenicism.
#' J. Heredity, 86:248-249
#' @references Archer FI, Adams PE, Schneiders BB.
#' strataG: An r package for manipulating, summarizing and analysing population
#' genetic data.
#' Molecular Ecology Resources. 2016. doi:10.1111/1755-0998.12559

#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com}

tidy_genomic_data <- function(
  data,
  vcf.metadata = FALSE,
  whitelist.markers = NULL,
  monomorphic.out = TRUE,
  blacklist.genotype = NULL,
  snp.ld = NULL,
  common.markers = TRUE,
  maf.thresholds = NULL,
  maf.pop.num.threshold = 1,
  maf.approach = "SNP",
  maf.operator = "OR",
  max.marker = NULL,
  blacklist.id = NULL,
  pop.levels = NULL,
  pop.labels = NULL,
  strata = NULL,
  pop.select = NULL,
  filename = NULL,
  parallel.core = parallel::detectCores() - 1,
  verbose = TRUE
) {
  if (verbose) {
    cat("#######################################################################\n")
    cat("##################### radiator::tidy_genomic_data #####################\n")
    cat("#######################################################################\n")
    timing <- proc.time()
  }
  opt.change <- getOption("width")
  options(width = 70)

  # Checking for missing and/or default arguments-------------------------------
  if (missing(data)) stop("Input file missing")

  # POP_ID in gsi_sim does not like spaces, we need to remove space in everything touching POP_ID...
  # pop.levels, pop.labels, pop.select, strata, etc
  if (!is.null(pop.levels) & is.null(pop.labels)) {
    pop.levels <- stringi::stri_replace_all_fixed(pop.levels, pattern = " ", replacement = "_", vectorize_all = FALSE)
    pop.labels <- pop.levels
  }

  if (!is.null(pop.labels) & is.null(pop.levels)) stop("pop.levels is required if you use pop.labels")

  if (!is.null(pop.labels)) {
    if (length(pop.labels) != length(pop.levels)) stop("pop.labels and pop.levels must have the same length (number of groups)")
    pop.labels <- stringi::stri_replace_all_fixed(pop.labels, pattern = " ", replacement = "_", vectorize_all = FALSE)
  }

  if (!is.null(pop.select)) {
    pop.select <- stringi::stri_replace_all_fixed(pop.select, pattern = " ", replacement = "_", vectorize_all = FALSE)
  }

  skip.tidy.wide <- NULL

  # File type detection----------------------------------------------------------

  data.type <- radiator::detect_genomic_format(data)

  if (data.type == "haplo.file") {
    if (verbose && !is.null(maf.thresholds)) {
      message("With stacks haplotype file the maf.approach is automatically set to: haplotype")
    }
    maf.approach <- "SNP"
    # confusing, but because the haplotpe file doesn't have snp info, only locus info
    # it's treated as markers/snp info and filtered the same way as the approach by SNP.
    # but it's really by haplotype
  }

  if (maf.approach == "haplotype") {
    if (data.type != "vcf.file" | data.type != "haplo.file") {
      stop("The haplotype approach during MAF filtering is for VCF and
           stacks haplotypes file, only. Use the snp approach for the other file types")
    }
  }


  # STRATA argument required for VCF and haplotypes files-----------------------
  if (data.type == "haplo.file" | data.type == "vcf.file") {
    if (is.null(strata)) stop("strata argument is required")
  }

  # Import whitelist of markers-------------------------------------------------
  if (!is.null(whitelist.markers)) {# with Whitelist of markers
    if (is.vector(whitelist.markers)) {
      whitelist.markers <- suppressMessages(readr::read_tsv(whitelist.markers, col_names = TRUE) %>%
        dplyr::mutate_all(.tbl = ., .funs = as.character))
    }
    columns.names.whitelist <- colnames(whitelist.markers)

    # haplo.file
    if (data.type == "haplo.file") {
      whitelist.markers <- dplyr::select(.data = whitelist.markers, LOCUS)
      columns.names.whitelist <- colnames(whitelist.markers)
    }
    nrow.before <- nrow(whitelist.markers)
    whitelist.markers <- dplyr::distinct(whitelist.markers)
    nrow.after <- nrow(whitelist.markers)
    duplicate.whitelist.markers <- nrow.before - nrow.after
    if (duplicate.whitelist.markers > 0) {
      message("Whitelist of markers with ", duplicate.whitelist.markers, " duplicated identifiers...")
      message("    Creating unique whitelist")
      message("    Warning: downstream results might be impacted by this, check how you made your VCF file...")
    }
    nrow.before <- nrow.after <- duplicate.whitelist.markers <- NULL

    whitelist.markers <- dplyr::mutate_all(
      .tbl = whitelist.markers, .funs = clean_markers_names)
  }
  # Import blacklist id --------------------------------------------------------
  if (!is.null(blacklist.id)) {# With blacklist of ID
    if (is.vector(blacklist.id)) {
      suppressMessages(blacklist.id <- readr::read_tsv(blacklist.id, col_names = TRUE))
    } else {
      if (!tibble::has_name(blacklist.id, "INDIVIDUALS")) {
        stop("Blacklist of individuals should have 1 column named: INDIVIDUALS")
      }
    }
    # not for plink file, where it's done after.
    # see plink section to understand
    blacklist.id$INDIVIDUALS <- radiator::clean_ind_names(blacklist.id$INDIVIDUALS)

    # remove potential duplicate id
    dup <- dplyr::distinct(.data = blacklist.id, INDIVIDUALS)
    blacklist.id.dup <- nrow(blacklist.id) - nrow(dup)
    if (blacklist.id.dup >1) {
      message("Duplicate id's in blacklist: ", blacklist.id.dup)
      blacklist.id <- dup
    }
    dup <- blacklist.id.dup <- NULL
    message("Number of individuals in blacklist: ", nrow(blacklist.id))
  }

  # population levels and strata------------------------------------------------
  if (!is.null(strata)) {
    if (is.vector(strata)) {
      # message("strata file: yes")
      # number.columns.strata <- max(
      #   utils::count.fields(strata, sep = "\t"), na.rm = TRUE)
      # col.types <- stringi::stri_join(
      #   rep("c", number.columns.strata), collapse = "")
      suppressMessages(
        strata.df <- readr::read_tsv(
          file = strata, col_names = TRUE,
          # col_types = col.types
          col_types = readr::cols(.default = readr::col_character())
          ) %>%
          dplyr::rename(POP_ID = STRATA))
    } else {
      # message("strata object: yes")
      colnames(strata) <- stringi::stri_replace_all_fixed(
        str = colnames(strata),
        pattern = "STRATA",
        replacement = "POP_ID",
        vectorize_all = FALSE
      )
      strata.df <- strata
    }

    # Remove potential whitespace in pop_id
    strata.df$POP_ID <- radiator::clean_pop_names(strata.df$POP_ID)
    colnames.strata <- colnames(strata.df)

    # clean ids
    strata.df$INDIVIDUALS <- radiator::clean_ind_names(strata.df$INDIVIDUALS)

    # filtering the strata if blacklist id available
    if (!is.null(blacklist.id)) {
      strata.df <- dplyr::anti_join(x = strata.df, y = blacklist.id, by = "INDIVIDUALS")
    }
  }

  # Import VCF------------------------------------------------------------------
  if (data.type == "vcf.file") { # VCF
    if (verbose) message("Importing and tidying the VCF...")
    input <- radiator::tidy_vcf(
      data = data,
      strata = strata.df,
      vcf.metadata = vcf.metadata,
      parallel.core = parallel.core,
      verbose = verbose,
      whitelist.markers = whitelist.markers,
      blacklist.id = blacklist.id,
      pop.select = pop.select,
      pop.levels = pop.levels,
      pop.labels = pop.labels
      )
    biallelic <- radiator::detect_biallelic_markers(input)
  } # End import VCF

  # Import PLINK ---------------------------------------------------------------
  if (data.type == "plink.file") { # PLINK
    if (verbose) message("Importing the PLINK files...")
    tfam <- data.table::fread(
      input = stringi::stri_replace_all_fixed(
        str = data,
        pattern = ".tped", replacement = ".tfam", vectorize_all = FALSE
      ),
      sep = " ",
      header = FALSE,
      stringsAsFactors = FALSE,
      verbose = FALSE,
      select = c(1,2),
      colClasses = list(character = c(1,2)),
      col.names = c("POP_ID", "INDIVIDUALS"),
      showProgress = TRUE,
      data.table = FALSE) %>%
      tibble::as_data_frame(.) %>%
      dplyr::mutate_at(.tbl = ., .vars = "INDIVIDUALS",
                       .funs = clean_ind_names) %>%
      dplyr::mutate_at(.tbl = ., .vars = "POP_ID",
                       .funs = clean_pop_names)

    # if no strata tfam = strata.df
    if (is.null(strata)) {
      strata.df <- tfam

      # Check with strata and pop.levels/pop.labels
      if (!is.null(pop.levels)) {
        if (length(levels(factor(strata.df$POP_ID))) != length(pop.levels)) {
          stop("The number of groups in your tfam file must match the number of groups in pop.levels")
        }
      }
    } else {
      # remove unwanted sep in individual name and replace with "-"
      strata.df$INDIVIDUALS <- radiator::clean_ind_names(strata.df$INDIVIDUALS)
    }

    tped.header.prep <- tfam %>%
      dplyr::select(INDIVIDUALS) %>%
      dplyr::mutate(
        NUMBER = seq(1, n()),
        ALLELE1 = rep("A1", n()), ALLELE2 = rep("A2", n())
      ) %>%
      tidyr::gather(ALLELES_GROUP, ALLELES, -c(INDIVIDUALS, NUMBER)) %>%
      dplyr::arrange(NUMBER) %>%
      dplyr::select(-ALLELES_GROUP) %>%
      tidyr::unite(INDIVIDUALS_ALLELES, c(INDIVIDUALS, ALLELES), sep = "_", remove = FALSE) %>%
      dplyr::arrange(NUMBER) %>%
      dplyr::mutate(NUMBER = seq(from = (1 + 4), to = n() + 4)) %>%
      dplyr::select(-ALLELES)

    tped.header.names <- c("LOCUS", tped.header.prep$INDIVIDUALS_ALLELES)
    tped.header.integer <- c(2, tped.header.prep$NUMBER)

    if (!is.null(blacklist.id)) { # using the blacklist of individuals
      whitelist.id <- tped.header.prep %>%
        dplyr::anti_join(blacklist.id, by = "INDIVIDUALS") %>%
        dplyr::arrange(NUMBER)
      tped.header.names <- c("LOCUS", whitelist.id$INDIVIDUALS_ALLELES)
      tped.header.integer <- c(2, whitelist.id$NUMBER)

      strata.df <- dplyr::anti_join(x = strata.df, y = blacklist.id, by = "INDIVIDUALS")
    }

    # import PLINK
    input <- data.table::fread(
      input = data,
      sep = " ",
      header = FALSE,
      stringsAsFactors = FALSE,
      verbose = FALSE,
      select = tped.header.integer,
      col.names = tped.header.names,
      showProgress = TRUE,
      data.table = FALSE) %>%
      tibble::as_data_frame(.) %>%
      dplyr::mutate(LOCUS = as.character(LOCUS))

    # Filter with whitelist of markers
    if (!is.null(whitelist.markers)) {
      if (verbose) message("Filtering with whitelist of markers")
      input <- suppressWarnings(
        dplyr::semi_join(input, whitelist.markers, by = columns.names.whitelist)
      )
    }

    # To reduce the size of the dataset we subsample the markers with max.marker
    if (!is.null(max.marker)) {
      if (verbose) message("Using the max.marker to reduce the size of the dataset")
      input <- dplyr::sample_n(tbl = input, size = max(as.numeric(max.marker)), replace = FALSE)

      max.marker.subsample.select <- input %>%
        dplyr::distinct(LOCUS, .keep_all = TRUE) %>%
        dplyr::arrange(LOCUS)

      readr::write_tsv(# save results
        x = max.marker.subsample.select,
        path = "max.marker.subsample.select.tsv")
    }

    # Make tidy
    if (verbose) message("Tidying the PLINK file ...")
    # Filling GT and new separating INDIVIDUALS from ALLELES
    # combining alleles
    input <- tidyr::gather(data = input, key = INDIVIDUALS_ALLELES, value = GT, -LOCUS)

    # detect GT coding
    if (verbose) message("Scanning for PLINK tped genotype coding")
    detect.gt.coding <- unique(sample(x = input$GT, size = 100, replace = FALSE))
    gt.letters <- c("A", "C", "G", "T")

    if (TRUE %in% unique(gt.letters %in% detect.gt.coding)) {
      if (verbose) message("    genotypes coded with letters")
      gt.letters.df <- tibble::data_frame(GT = c("A", "C", "G", "T", "0"), NEW_GT = c("001", "002", "003", "004", "000"))
      input <- dplyr::left_join(
        input,
        gt.letters.df, by = "GT") %>%
        dplyr::select(-GT) %>%
        dplyr::rename(GT = NEW_GT)
      gt.letters.df <- NULL
    } else {
      if (verbose) message("    genotypes coded with integers")
      input <- input %>%
        dplyr::mutate(GT = stringi::stri_pad_left(str = GT, width = 3, pad = "0"))
    }
    detect.gt.coding <- gt.letters <- NULL


    input <- input %>%
      tidyr::separate(
        data = .,
        col = INDIVIDUALS_ALLELES,
        into = c("INDIVIDUALS", "ALLELES"),
        sep = "_") %>%
      dplyr::group_by(LOCUS, INDIVIDUALS) %>%
      tidyr::spread(data = ., key = ALLELES, value = GT) %>%
      dplyr::ungroup(.) %>%
      tidyr::unite(data = ., col = GT, A1, A2, sep = "") %>%
      dplyr::select(LOCUS, INDIVIDUALS, GT)

    # population levels and strata
    if (verbose) message("Integrating the tfam/strata file...")

    input <- dplyr::left_join(x = input, y = strata.df, by = "INDIVIDUALS")

    # using pop.levels and pop.labels info if present
    input <- change_pop_names(data = input, pop.levels = pop.levels, pop.labels = pop.labels)

    # Pop select
    if (!is.null(pop.select)) {
      if (verbose) message(stringi::stri_join(length(pop.select), "population(s) selected", sep = " "))
      input <- suppressWarnings(input %>% dplyr::filter(POP_ID %in% pop.select))
      input$POP_ID <- droplevels(input$POP_ID)
    }

    # removing untyped markers across all-pop
    remove.missing.gt <- input %>%
      dplyr::select(LOCUS, GT) %>%
      dplyr::filter(GT != "000000")

    untyped.markers <- dplyr::n_distinct(input$LOCUS) - dplyr::n_distinct(remove.missing.gt$LOCUS)
    if (untyped.markers > 0) {
      if (verbose) message("Number of marker with 100 % missing genotypes: ", untyped.markers)
      input <- suppressWarnings(
        dplyr::semi_join(input,
                         remove.missing.gt %>%
                           dplyr::distinct(LOCUS, .keep_all = TRUE),
                         by = "LOCUS")
      )
    }

    # Unused objects
    tped.header.prep <- tped.header.integer <- tped.header.names <- remove.missing.gt <- NULL

    # detect if biallelic give vcf style genotypes
    # biallelic <- radiator::detect_biallelic_markers(input)
    input.temp <- radiator::change_alleles(data = input,
                                           verbose = verbose)
    input <- input.temp$input
    biallelic <- input.temp$biallelic
  } # End import PLINK

  # Import genepop--------------------------------------------------------------
  if (data.type == "genepop.file") {
    if (verbose) message("Tidying the genepop file ...")
    input <- radiator::tidy_genepop(data = data, tidy = TRUE)
    data.type <- "tbl_df"
    skip.tidy.wide <- TRUE
  }

  # Import DArT ----------------------------------------------------------------
  if (data.type == "dart") {
    if (verbose) message("Tidying DArT data...")
    input <- radiator::tidy_dart(
      data = data,
      strata = strata,
      verbose = FALSE,
      parallel.core = parallel.core)
    data.type <- "tbl_df"

    if (tibble::has_name(strata.df, "NEW_ID")) {
      strata.df <- strata.df %>%
        dplyr::select(-INDIVIDUALS) %>%
        dplyr::rename(INDIVIDUALS = NEW_ID)
    }
    skip.tidy.wide <- TRUE
  }

  # Import fst.file ------------------------------------------------------------
  if (data.type == "fst.file") {
    if (verbose) message("Importing the fst.file as a data frame...")
    input <- fst::read.fst(path = data)
    skip.tidy.wide <- TRUE
    data.type <- "tbl_df"
  }

  # Import DF-------------------------------------------------------------------
  if (data.type == "tbl_df") { # DATA FRAME OF GENOTYPES
    if (verbose) message("Importing the data frame ...")
    if (is.null(skip.tidy.wide)) skip.tidy.wide <- FALSE
    if (!skip.tidy.wide) {
      input <- radiator::tidy_wide(data = data, import.metadata = TRUE)
    }

    # For long tidy format, switch LOCUS to MARKERS column name, if found MARKERS not found
    if (tibble::has_name(input, "LOCUS") && !tibble::has_name(input, "MARKERS")) {
      input <- dplyr::rename(.data = input, MARKERS = LOCUS)
    }

    # Change individuals names containing special character
    input$INDIVIDUALS <- radiator::clean_ind_names(input$INDIVIDUALS)

    # Filter with whitelist of markers
    if (!is.null(whitelist.markers)) {
      if (verbose) message("Filtering with whitelist of markers")
      input <- suppressWarnings(dplyr::semi_join(input, whitelist.markers, by = columns.names.whitelist))
    }

    # Filter with blacklist of individuals
    if (!is.null(blacklist.id)) {
      if (verbose) message("Filtering with blacklist of individuals")
      input <- suppressWarnings(dplyr::anti_join(input, blacklist.id, by = "INDIVIDUALS"))
    }

    # population levels and strata
    if (!is.null(strata)) {
      strata.df$INDIVIDUALS <- radiator::clean_ind_names(strata.df$INDIVIDUALS)

      if (tibble::has_name(input, "POP_ID")) input <- dplyr::select(input, -POP_ID)
      input <- input %>%
        dplyr::left_join(strata.df, by = "INDIVIDUALS")
    }

    # Change potential problematic POP_ID space
    input$POP_ID <- radiator::clean_pop_names(input$POP_ID)

    # Check with strata and pop.levels/pop.labels
    if (!is.null(pop.levels)) {
      if (length(levels(factor(input$POP_ID))) != length(pop.levels)) {
        stop("The number of groups in your POP_ID column file must match the number of groups in pop.levels")
      }
    }

    # using pop.levels and pop.labels info if present
    input <- change_pop_names(data = input, pop.levels = pop.levels, pop.labels = pop.labels)

    # Pop select
    if (!is.null(pop.select)) {
      if (verbose) message(stringi::stri_join(length(pop.select), "population(s) selected", sep = " "))
      input <- suppressWarnings(input %>% dplyr::filter(POP_ID %in% pop.select))
    }

    input.temp <- radiator::change_alleles(data = input)
    input <- input.temp$input
    biallelic <- input.temp$biallelic
  } # End import data frame of genotypes

  # Import stacks haplotypes----------------------------------------------------
  if (data.type == "haplo.file") { # Haplotype file
    if (verbose) message("Importing STACKS haplotype file")
    # readr now faster/easier than fread...
    input <- readr::read_tsv(
      file = data, col_names = TRUE, na = "-",
      col_types = readr::cols(.default = readr::col_character())) %>%
      dplyr::select(-Cnt)

    if (tibble::has_name(input, "# Catalog ID") ||
        tibble::has_name(input, "Catalog ID") ||
        tibble::has_name(input, "# Catalog Locus ID")) {
      colnames(input) <- stringi::stri_replace_all_fixed(
        str = colnames(input),
        pattern = c("# Catalog ID", "Catalog ID", "# Catalog Locus ID"),
        replacement = c("LOCUS", "LOCUS", "LOCUS"), vectorize_all = FALSE
      )
    }

    if (tibble::has_name(input, "Seg Dist")) {
      input <- dplyr::select(.data = input, -`Seg Dist`)
    }

    n.catalog.locus <- dplyr::n_distinct(input$LOCUS)
    n.individuals <- ncol(input) - 1

    message("\nNumber of loci in catalog: ", n.catalog.locus)
    message("Number of individuals: ", n.individuals)
    input <- tidyr::gather(data = input,
                           key = "INDIVIDUALS",
                           value = "GT_VCF_NUC", # previously using "GT_HAPLO"
                           -LOCUS)


    input$INDIVIDUALS <- radiator::clean_ind_names(input$INDIVIDUALS)

    # Filter with whitelist of markers
    if (!is.null(whitelist.markers)) {
      if (verbose) message("Filtering with whitelist of markers")
      input <- suppressWarnings(dplyr::semi_join(input, whitelist.markers, by = columns.names.whitelist))
    }

    # Filter with blacklist of individuals
    if (!is.null(blacklist.id)) {
      if (verbose) message("Filtering with blacklist of individuals")
      input <- suppressWarnings(dplyr::anti_join(input, blacklist.id, by = "INDIVIDUALS"))
    }

    # remove consensus markers
    if (verbose) message("\nScanning for consensus markers...")
    consensus.markers <- dplyr::filter(input, GT_VCF_NUC == "consensus") %>%
      dplyr::distinct(LOCUS)

    if (length(consensus.markers$LOCUS) > 0) {
      input <- suppressWarnings(dplyr::anti_join(input, consensus.markers, by = "LOCUS"))
      readr::write_tsv(consensus.markers, "radiator.tidy.genomic.data.consensus.markers.tsv")
    }
    if (verbose) message("    number of consensus markers removed: ", dplyr::n_distinct(consensus.markers$LOCUS))
    consensus.markers <- NULL

    # population levels and strata
    strata.df$INDIVIDUALS <- radiator::clean_ind_names(strata.df$INDIVIDUALS)

    input <- dplyr::left_join(x = input, y = strata.df, by = "INDIVIDUALS")

    # using pop.levels and pop.labels info if present
    input <- change_pop_names(data = input, pop.levels = pop.levels, pop.labels = pop.labels)

    # Pop select
    if (!is.null(pop.select)) {
      if (verbose) message(stringi::stri_join(length(pop.select), "population(s) selected", sep = " "))
      input <- suppressWarnings(input %>% dplyr::filter(POP_ID %in% pop.select))
    }

    # removing errors and potential paralogs (GT with > 2 alleles)
    if (verbose) message("Scanning for artifactual genotypes...")
    input <- input %>%
      dplyr::mutate(POLYMORPHISM = stringi::stri_count_fixed(GT_VCF_NUC, "/"))

    blacklist.paralogs <- input %>%
      dplyr::filter(POLYMORPHISM > 1) %>%
      dplyr::select(LOCUS, INDIVIDUALS)

    if (verbose) message("    number of genotypes with more than 2 alleles: ", length(blacklist.paralogs$LOCUS))
    if (length(blacklist.paralogs$LOCUS) > 0) {
      input <- input %>%
        dplyr::mutate(GT_VCF_NUC = replace(GT_VCF_NUC, which(POLYMORPHISM > 1), NA)) %>%
        dplyr::select(-POLYMORPHISM)

      readr::write_tsv(blacklist.paralogs, "blacklist.genotypes.paralogs.tsv")
    }
    blacklist.paralogs <- NULL

    if (verbose) message("Calculating REF/ALT alleles...")
    # Prep for REF/ALT alleles and new genotype coding
    # part below could be parallelized if necessary, test with larger dataset for bottleneck...
    input <- input %>%
      dplyr::mutate(
        GT_VCF_NUC = dplyr::if_else(
          POLYMORPHISM == 0,
          stringi::stri_join(GT_VCF_NUC, "/", GT_VCF_NUC), GT_VCF_NUC,
          missing = "./."),
        GT_VCF_NUC = dplyr::if_else(stringi::stri_detect_fixed(GT_VCF_NUC, "N"),
                                    "./.", GT_VCF_NUC)
      ) %>%
      dplyr::select(-POLYMORPHISM)

    input.temp <- radiator::change_alleles(
      data = input,
      biallelic = FALSE,
      parallel.core = parallel.core,
      verbose = verbose)
    input <- input.temp$input
    input.temp <- NULL
    biallelic <- FALSE
    input <- dplyr::rename(input, LOCUS = MARKERS)
  } # End import haplotypes file

  # Import GENIND--------------------------------------------------------------
  if (data.type == "genind") { # DATA FRAME OF GENOTYPES
    if (verbose) message("Tidying the genind object ...")
    input <- adegenet::genind2df(data) %>%
      tibble::rownames_to_column("INDIVIDUALS") %>%
      dplyr::rename(POP_ID = pop)

    # scan for the number of character coding the allele
    allele.sep <- input %>% dplyr::select(-INDIVIDUALS, -POP_ID)
    allele.sep <- unique(nchar(allele.sep[!is.na(allele.sep)]))

    if (length(allele.sep) > 1) {
      stop("The number of character/integer string coding the allele is not identical accross markers")
    }

    input <- input %>%
      tidyr::gather(key = LOCUS, value = GT, -c(INDIVIDUALS, POP_ID)) %>%
      tidyr::separate(
        data = ., col = GT, into = c("A1", "A2"),
        sep = allele.sep/2, remove = TRUE, extra = "drop"
      ) %>%
      dplyr::mutate(
        A1 = stringi::stri_pad_left(str = A1, pad = "0", width = 3),
        A2 = stringi::stri_pad_left(str = A2, pad = "0", width = 3)
      ) %>%
      tidyr::unite(data = ., col = GT, A1, A2, sep = "") %>%
      dplyr::mutate(GT = replace(GT, which(GT == "NANA"), "000000"))

    # remove unwanted sep in id and pop.id names
    input <- input %>%
      dplyr::mutate_at(.tbl = ., .vars = "INDIVIDUALS",
                       .funs = clean_ind_names) %>%
      dplyr::mutate_at(.tbl = ., .vars = "POP_ID",
                       .funs = clean_pop_names)

    # Filter with whitelist of markers
    if (!is.null(whitelist.markers)) {
      if (verbose) message("Filtering with whitelist of markers")
      input <- suppressWarnings(dplyr::semi_join(input, whitelist.markers, by = columns.names.whitelist))
    }

    # Filter with blacklist of individuals
    if (!is.null(blacklist.id)) {
      if (verbose) message("Filtering with blacklist of individuals")
      input <- suppressWarnings(dplyr::anti_join(input, blacklist.id, by = "INDIVIDUALS"))
    }

    # population levels and strata
    if (!is.null(strata)) {
      input <- input %>%
        dplyr::select(-POP_ID) %>%
        dplyr::mutate(INDIVIDUALS =  as.character(INDIVIDUALS)) %>%
        dplyr::left_join(strata.df, by = "INDIVIDUALS")
    }

    # Change potential problematic POP_ID space
    input$POP_ID <- radiator::clean_pop_names(input$POP_ID)

    # Check with strata and pop.levels/pop.labels
    if (!is.null(pop.levels)) {
      if (length(levels(factor(input$POP_ID))) != length(pop.levels)) {
        stop("The number of groups in your POP_ID column must match the number of groups in pop.levels")
      }
    }

    # using pop.levels and pop.labels info if present
    input <- change_pop_names(data = input, pop.levels = pop.levels, pop.labels = pop.labels)

    # Pop select
    if (!is.null(pop.select)) {
      if (verbose) message(stringi::stri_join(length(pop.select), "population(s) selected", sep = " "))
      input <- suppressWarnings(input %>% dplyr::filter(POP_ID %in% pop.select))
    }

    # detect if biallelic give vcf style genotypes
    input.temp <- radiator::change_alleles(data = input, verbose = verbose)
    input <- input.temp$input
    biallelic <- input.temp$biallelic

    # Now the genind and genepop are like ordinary data frames
    data.type <- "tbl_df" # for subsequent steps

  } # End tidy genind

  # Import GENLIGHT ------------------------------------------------------------
  if (data.type == "genlight") { # DATA FRAME OF GENOTYPES
    if (verbose) message("Tidying the genlight object ...")
    input <- radiator::tidy_genlight(data = data)

    # remove unwanted sep in id and pop.id names
    input <- input %>%
      dplyr::mutate_at(.tbl = ., .vars = "INDIVIDUALS",
                       .funs = clean_ind_names) %>%
      dplyr::mutate_at(.tbl = ., .vars = "POP_ID",
                       .funs = clean_pop_names)

    # Filter with whitelist of markers
    if (!is.null(whitelist.markers)) {
      if (verbose) message("Filtering with whitelist of markers")
      input <- suppressWarnings(dplyr::semi_join(input, whitelist.markers, by = columns.names.whitelist))
    }

    # Filter with blacklist of individuals
    if (!is.null(blacklist.id)) {
      if (verbose) message("Filtering with blacklist of individuals")
      input <- suppressWarnings(dplyr::anti_join(input, blacklist.id, by = "INDIVIDUALS"))
    }

    # population levels and strata
    if (!is.null(strata)) {
      input <- input %>%
        dplyr::select(-POP_ID) %>%
        dplyr::mutate(INDIVIDUALS =  as.character(INDIVIDUALS)) %>%
        dplyr::left_join(strata.df, by = "INDIVIDUALS")
    }

    # Change potential problematic POP_ID space
    input$POP_ID <- radiator::clean_pop_names(input$POP_ID)

    # Check with strata and pop.levels/pop.labels
    if (!is.null(pop.levels)) {
      if (length(levels(factor(input$POP_ID))) != length(pop.levels)) {
        stop("The number of groups in your POP_ID column must match the number of groups in pop.levels")
      }
    }

    # using pop.levels and pop.labels info if present
    input <- change_pop_names(data = input, pop.levels = pop.levels, pop.labels = pop.labels)

    # Pop select
    if (!is.null(pop.select)) {
      if (verbose) message(stringi::stri_join(length(pop.select), "population(s) selected", sep = " "))
      input <- suppressWarnings(input %>% dplyr::filter(POP_ID %in% pop.select))
    }

    # Now the genind and genepop are like ordinary data frames
    data.type <- "tbl_df" # for subsequent steps
    biallelic <- TRUE
  } # End tidy genlight

  # Import STRATAG gtypes ------------------------------------------------------
  if (data.type == "gtypes") { # DATA FRAME OF GENOTYPES
    if (verbose) message("Tidying the gtypes object ...")
    input <- tidy_gtypes(data) %>%
      dplyr::mutate_at(.tbl = ., .vars = "INDIVIDUALS",
                       .funs = clean_ind_names) %>%
      dplyr::mutate_at(.tbl = ., .vars = "POP_ID",
                       .funs = clean_pop_names)

    # Filter with whitelist of markers
    if (!is.null(whitelist.markers)) {
      if (verbose) message("Filtering with whitelist of markers")
      input <- suppressWarnings(dplyr::semi_join(input, whitelist.markers, by = columns.names.whitelist))
    }

    # Filter with blacklist of individuals
    if (!is.null(blacklist.id)) {
      if (verbose) message("Filtering with blacklist of individuals")
      input <- suppressWarnings(dplyr::anti_join(input, blacklist.id, by = "INDIVIDUALS"))
    }

    # population levels and strata
    if (!is.null(strata)) {
      input <- input %>%
        dplyr::select(-POP_ID) %>%
        dplyr::mutate(INDIVIDUALS =  as.character(INDIVIDUALS)) %>%
        dplyr::left_join(strata.df, by = "INDIVIDUALS")
    }

    # Change potential problematic POP_ID space
    input$POP_ID <- radiator::clean_pop_names(input$POP_ID)

    # Check with strata and pop.levels/pop.labels
    if (!is.null(pop.levels)) {
      if (length(levels(factor(input$POP_ID))) != length(pop.levels)) {
        stop("The number of groups in your POP_ID column must match the number of groups in pop.levels")
      }
    }

    # using pop.levels and pop.labels info if present
    input <- change_pop_names(data = input, pop.levels = pop.levels, pop.labels = pop.labels)

    # Pop select
    if (!is.null(pop.select)) {
      if (verbose) message(stringi::stri_join(length(pop.select), "population(s) selected", sep = " "))
      input <- suppressWarnings(input %>% dplyr::filter(POP_ID %in% pop.select))
    }

    # detect if biallelic give vcf style genotypes
    # biallelic <- radiator::detect_biallelic_markers(input)
    input.temp <- radiator::change_alleles(data = input, verbose = verbose)
    input <- input.temp$input
    biallelic <- input.temp$biallelic

    # Now the gtypes are like ordinary data frames
    data.type <- "tbl_df" # for subsequent steps

  } # End tidy gtypes


  # END IMPORT DATA-------------------------------------------------------------

  # Arrange the id and create a strata after pop select ------------------------
  input$INDIVIDUALS <- radiator::clean_ind_names(input$INDIVIDUALS)

  strata.df <- dplyr::ungroup(input) %>%
    dplyr::distinct(POP_ID, INDIVIDUALS)

  # Blacklist genotypes --------------------------------------------------------
  if (is.null(blacklist.genotype)) { # no Whitelist
    if (verbose) message("Erasing genotype: no")
  } else {
    if (verbose) message("Erasing genotype: yes")
    want <- c("MARKERS", "CHROM", "LOCUS", "POS", "INDIVIDUALS")
    if (is.vector(blacklist.genotype)) {
      suppressWarnings(suppressMessages(
        blacklist.genotype <- readr::read_tsv(blacklist.genotype, col_names = TRUE)))
    }
    suppressWarnings(suppressMessages(
      blacklist.genotype <- blacklist.genotype %>%
        dplyr::mutate_at(.tbl = ., .vars = "INDIVIDUALS",
                         .funs = clean_ind_names) %>%
        dplyr::select(dplyr::one_of(want)) %>%
        dplyr::mutate_all(.tbl = ., .funs = as.character, exclude = NA)))
    columns.names.blacklist.genotype <- colnames(blacklist.genotype)

    if (data.type == "haplo.file") {
      blacklist.genotype <- dplyr::select(.data = blacklist.genotype, INDIVIDUALS, LOCUS)
      columns.names.blacklist.genotype <- colnames(blacklist.genotype)
    }

    # control check to keep only individuals in the strata.df
    blacklist.genotype <- suppressWarnings(
      blacklist.genotype  %>%
        dplyr::filter(INDIVIDUALS %in% strata.df$INDIVIDUALS)
    )

    # control check to keep only whitelisted markers from the blacklist of genotypes
    if (!is.null(whitelist.markers)) {
      blacklist.genotype <- blacklist.genotype
      if (verbose) message("Control check to keep only whitelisted markers present in the blacklist of genotypes to erase.")
      # updating the whitelist of markers to have all columns that id markers
      if (data.type == "vcf.file") {
        whitelist.markers.ind <- input %>% dplyr::distinct(CHROM, LOCUS, POS, INDIVIDUALS)
      } else {
        whitelist.markers.ind <- input %>% dplyr::distinct(LOCUS, INDIVIDUALS)
      }

      # updating the blacklist.genotype
      blacklist.genotype <- suppressWarnings(
        dplyr::semi_join(whitelist.markers.ind, blacklist.genotype,
                         by = columns.names.blacklist.genotype))
      columns.names.blacklist.genotype <- colnames(blacklist.genotype)
    }

    # Update column names
    columns.names.blacklist.genotype <- colnames(blacklist.genotype)

    blacklisted.gen.number <- nrow(blacklist.genotype)
    if (blacklisted.gen.number > 0) {
      message("    Number of genotype(s) to erase: ", blacklisted.gen.number)
      input.erase <- dplyr::semi_join(
        input, blacklist.genotype, by = columns.names.blacklist.genotype) %>%
        dplyr::mutate(GT = rep("000000", n()))
      input <- dplyr::anti_join(
        input, blacklist.genotype, by = columns.names.blacklist.genotype)
      if (tibble::has_name(input.erase, "GT_VCF")) {
        input.erase <- dplyr::mutate(input.erase, GT_VCF = rep("./.", n()))
      }

      if (tibble::has_name(input.erase, "GT_VCF_NUC")) {
        input.erase <- dplyr::mutate(input.erase, GT_VCF_NUC = rep("./.", n()))
      }

      if (tibble::has_name(input.erase, "GT_BIN")) {
        input.erase <- dplyr::mutate(input.erase, GT_BIN = rep(as.numeric(NA_character_), n()))
      }
      input <- dplyr::bind_rows(input, input.erase)
    } else {
      message("There are no genotype left in the blacklist: input file left intact")
    }


  } # End erase genotypes

  # dump unused object
  blacklist.id <- whitelist.markers <- whitelist.markers.ind <- NULL
  want <- blacklist.genotype <- NULL
  # SNP LD  --------------------------------------------------------------------
  if (!is.null(snp.ld)) {
    input <- radiator::snp_ld(data = input, snp.ld = snp.ld)
  } # End of snp.ld control

  # Unique markers id ----------------------------------------------------------
  # we want to keep LOCUS in the vcf, but not in the other type of input file
  if (tibble::has_name(input, "LOCUS") && !tibble::has_name(input, "MARKERS")) {
    colnames(input) <- stringi::stri_replace_all_fixed(
      str = colnames(input),
      pattern = "LOCUS",
      replacement = "MARKERS",
      vectorize_all = FALSE
    )
  }

  # Removing special characters in markers id ----------------------------------
  input$MARKERS <- radiator::clean_markers_names(input$MARKERS)

  # Markers in common between all populations (optional) -----------------------
  if (common.markers) { # keep only markers present in all pop
    input <- radiator::keep_common_markers(input, verbose = TRUE)$input
  } # End common markers

  # Removing monomorphic markers------------------------------------------------
  if (monomorphic.out) {
    if (verbose) message("Removing monomorphic markers: yes")
    if (tibble::has_name(input, "POLYMORPHIC")) {
      if (verbose) message("Scanning for monomorphic markers...")
      if (verbose) message("    Number of markers before = ", dplyr::n_distinct(input$MARKERS))
      if (tibble::has_name(input, "POS")) {
        mono.markers <- dplyr::filter(input, !POLYMORPHIC) %>%
          dplyr::distinct(MARKERS, CHROM, LOCUS, POS)
      } else {
        mono.markers <- dplyr::filter(input, !POLYMORPHIC) %>%
          dplyr::distinct(MARKERS)
      }

      if (nrow(mono.markers) > 0) {
        if (verbose) message("    Number of monomorphic markers removed = ", nrow(mono.markers))
        input <- dplyr::filter(input, !MARKERS %in% mono.markers$MARKERS)
        readr::write_tsv(mono.markers, "blacklist.monomorphic.markers.tsv")
        if (verbose) message("    Number of markers after = ", dplyr::n_distinct(input$MARKERS))
      }
      input <- dplyr::select(input, -POLYMORPHIC)
    } else {
      mono.out <- radiator::discard_monomorphic_markers(input, verbose = TRUE)
      mono.markers <- mono.out$blacklist.monomorphic.markers
      if (nrow(mono.markers) > 0) {
        input <- mono.out$input
        readr::write_tsv(mono.markers, "blacklist.monomorphic.markers.tsv")
      }
      mono.out <- NULL
    }
    mono.markers <- NULL
  } # End monomorphic out

  # Minor Allele Frequency filter ----------------------------------------------
  # maf.thresholds <- c(0.05, 0.1) # test
  if (!is.null(maf.thresholds)) { # with MAF
    maf.info <- radiator_maf_module(
      data = input,
      maf.thresholds = maf.thresholds,
      maf.pop.num.threshold = maf.pop.num.threshold,
      maf.approach = maf.approach,
      maf.operator = maf.operator
    )

    input <- maf.info$input
    # maf.data <- maf.info$maf.data
    maf.info <- NULL
  } # End of MAF filters


  # Write to working directory -------------------------------------------------
  # if (!is.null(filename)) {
  #   if (verbose) message("Writing the tidy data to the working directory: \n", filename)
  #   readr::write_tsv(x = input, path = filename, col_names = TRUE)
  # }

  if (!is.null(filename)) {
    tidy.name <- stringi::stri_join(filename, ".rad")
    message("Writing tidy data set: ", tidy.name)
    # if (!is.null(save.feather)) {
    # feather::write_feather(filter, stri_replace_all_fixed(filename, pattern = ".tsv", replacement = "_feather.tsv", vectorize_all = TRUE))
    # } else {
    fst::write.fst(x = input, path = tidy.name, compress = 85)
    # }
  }

  # Results --------------------------------------------------------------------
  # messages
  n.markers <- dplyr::n_distinct(input$MARKERS)
  if (tibble::has_name(input, "CHROM")) {
    n.chromosome <- dplyr::n_distinct(input$CHROM)
  } else {
    n.chromosome <- "no chromosome info"
  }
  n.individuals <- dplyr::n_distinct(input$INDIVIDUALS)
  n.pop <- dplyr::n_distinct(input$POP_ID)

  if (verbose) {
    cat("############################### RESULTS ###############################\n")

    if (!is.null(filename)) {
      message("Tidy data written in global environment and working directory")
    } else {
      message("Tidy data written in global environment")
    }
    message("Data format: ", data.type)
    if (biallelic) {
      message("Biallelic data")
    } else{
      message("Multiallelic data")
    }
    if (common.markers) {
      message("Number of common markers: ", n.markers)
    } else {
      message("Number of markers: ", n.markers)
    }
    message("Number of chromosome/contig/scaffold: ", n.chromosome)
    message("Number of individuals: ", n.individuals)
    message("Number of populations: ", n.pop)
    timing <- proc.time() - timing
    message("Computation time: ", round(timing[[3]]), " sec")
    cat("################ radiator::tidy_genomic_data completed ################\n")
  }
  res <- input
  options(width = opt.change)
  return(res)
} # tidy genomic data


