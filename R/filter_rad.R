# Import, filter and transform a dart output file to different formats

#' @name filter_rad

#' @title ONE FUNCTION TO RULE THEM ALL

#' @description Designed for RADseq data, it's radiator integrated pipeline that links
#' several \code{filter_} functions of \pkg{radiator}.
#' Rapidly get an idea of what you can and cannot do with your dataset.
#' Novices, start with this one!

#' @inheritParams genomic_converter
#' @inheritParams tidy_genomic_data
#' @inheritParams radiator_common_arguments
#' @inheritParams detect_mixed_genomes
#' @inheritParams filter_hwe
#' @inheritParams read_strata

# @param filter.markers.coverage (optional, string, numerical) Filter the lower and
# upper bound of locus/read coverage. The locus/read coverage combines the markers
# average count for REF and ALT allele (respectively the \code{AvgCountRef} and
# \code{AvgCountSnp} info). These markers statistics are generated by DArT.
# If you have count data, use \code{erase.genotypes} argument below instead.
# Default: \code{filter.markers.coverage = NULL}.
# e.g to keep markers with coverage inbetween 7 and 200,
# use : \code{filter.markers.coverage = c(7, 200)}.

# param erase.genotypes (optional, string, numerical) DArT file with count
# data is required for this argument to work. With count data, genotype,
# REF and ALT coverage information is available and is better suited than
# \code{filter.markers.coverage} to remove/erase data based on coverage info.
# This function argument requires 3 values in the string:
#   \enumerate{
#     \item threshold.low.coverage: threshold for the minimum read coverage. Under this threshold,
#     genotypes are erased. e.g. 7
#     \item threshold.gl: threshold that applies only for heterozygous genotypes.
#     Using the \code{threshold.low.coverage} doesn't guarantees that REF and ALT
#     allele have adequate coverage. This threshold does.
#     A genotype likelihood value is generated based
#     on the departure of equal coverage between REF and ALT allele, number of samples
#     sharing the heterozygous genotype for the locus, missing data for the locus
#     and individual. Below the genotype likelihood threshold value,
#     the heterozygous genotypes are erased. e.g. if an heterozygous genotype for a
#     marker as REF/ALT coverage of 100/3 with only 1 sample sharing this info and
#     this sample has 50% missing data and the marker missingness is averaged, the
#     GL value will be extremely low compared to another heterozygous genotype with
#     50/50 of coverage and 10 samples sharing the same genotype...
#     \item threshold.high.coverage: threshold that allows to erase genotypes with
#     very high coverage
#   }
#     e.g. of values: \code{erase.genotypes = c(7, -0.25, 200)}.
#     However, using the \code{interactive.filter = TRUE} is highly recommended to
#     visualize data before choosing values.
#     Default: \code{erase.genotypes = NULL}.

# @param filter.individuals.missing (optional, double) New argument to blacklist
# individuals with too many missing genotypes. Below the threshold, individuals
# are blacklisted. e.g. 0.80 will blacklist individuals with more than 20% missing
# genotypes.
# Default: \code{filter.individuals.missing = NULL}.


# @param filter.markers.missing (optional, string) Similar to call rate, but
# more adapted to the data. 3 values are required in the string, corresponding
# to the \code{\link[radiator]{filter_individual}} module of radiator.
# First value is the approach to count genotyped individuals per markers, \code{"overall"}
# or by \code{"pop"}. Second value is the percent threshold for the marker, with
# \code{70}, 70 percent of genotyped individuals are required to keep the marker.
# The last threshold is the number of problematic population that are allowed to skip
# the threshold. In doubt, use the interactive mode that take step by step these
# arguments. e.g to keep individuals genotyped at >= 70 percent for the markers,
# without considering the population info and allowing 1 population to be problematic for the
# threshold, use: \code{c("overall", 70, 1)}.
# Default: \code{filter.markers.missing = NULL}.


# @param number.snp.reads (optional, integer) This filter removes outlier markers
# with too many SNP number per locus/read.
# Having a higher than "normal" SNP number is usually the results of
# assembly artifacts or bad assembly parameters.
# This filter is population-agnostic. This is best decide after viewing the figures,
# with the interactive mode.
# If the argument is set to \code{number.snp.reads = 2},
# locus with 3 and more SNPs will be blacklisted.
# Default: \code{number.snp.reads = NULL}.

# @param detect.mixed.genomes (optional, logical) Highlight outliers individual's
# observed heterozygosity for a quick
# diagnostic of mixed samples or poor polymorphism discovery due to DNA quality,
# sequencing effort, etc.
# See this function for more info: \code{\link[radiator]{detect_mixed_genomes}}.
# Default: \code{detect.mixed.genomes = TRUE}.


# @param duplicate.genomes.analysis (optional, string) Detect duplicate individuals.
# The function can compute two methods (distance or genome pairwise similarity)
# to highligh potential duplicate individuals.
# See this function for more info: \code{\link[radiator]{detect_duplicate_genomes}}.
# The string required to run the analysis as 2 values:
# \enumerate{
# \item TRUE/FALSE to run the analysis;
# \item Computes pairwise genome similarity (TRUE/FALSE),
# with FALSE just the distance measure is used.
# The pairwise genome similarity is longer to run, but is better because it
# integrates markers in common/missing data.
# Using \code{interactive.filter = TRUE}, can overide this value,
# you can opt in for the pairwise genome similarity after viewing the figures
# used with distance measure... handy!
# }
# Default: \code{detect_duplicate_genomes = c(TRUE, FALSE)}.


#' @param filename (optional) The filename prefix for the objet in the global environment
#' or the working directory. Default: \code{filename = NULL}. A default name will be used,
#' customized with the output file(s) selected.

#' @param ... (optional) To pass further argument for fine-tuning the function.

#' @note
#' The function requires 2 packages (not installed automatically with radiator):
#' \itemize{
#' \item HardyWeinberg: to filter markers in HWD
#' \item ggtern: to generate ternary graph
#' }

#' @return The function returns an object (list). The content of the object
#' can be listed with \code{names(object)} and use \code{$} to isolate specific
#' object (see examples). Some output format will write the output file in the
#' working directory. The tidy genomic data frame is generated automatically.

#' @export
#' @rdname filter_rad
#' @importFrom dplyr group_by select rename filter mutate summarise distinct n_distinct arrange left_join semi_join anti_join inner_join full_join tally bind_rows
#' @importFrom parallel detectCores
#' @importFrom stringi stri_replace_all_fixed stri_join stri_sub stri_replace_na stri_pad_left
#' @importFrom purrr discard
#' @importFrom readr read_tsv write_tsv
#' @importFrom tibble as_data_frame data_frame
#' @importFrom tidyr spread gather unite separate
#' @importFrom stats IQR

#' @examples
#' \dontrun{
#' require(HardyWeinberg)
#' require(ggtern)
#' shark <- radiator::filter_rad(
#'     data = "data.shark.vcf",
#'     strata = "strata.shark.tsv",
#'     output = "genind",
#'     filename = "shark.filters")
#' }

#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com} and
#' Peter Grewe \email{peter.grewe@csiro.au}

filter_rad <- function(
  data,
  strata = NULL,
  interactive.filter = TRUE,
  output = NULL,
  filename = NULL,
  verbose = TRUE,
  parallel.core = parallel::detectCores() - 1,
  ...
) {

  if (verbose) {
    cat("################################################################################\n")
    cat("############################# radiator::filter_rad #############################\n")
    cat("################################################################################\n")
  }
  # Cleanup---------------------------------------------------------------------
  message("The function arguments names have changed: please read documentation\n")
  file.date <- format(Sys.time(), "%Y%m%d@%H%M")
  if (verbose) message("Execution date@time: ", file.date)
  old.dir <- getwd()
  opt.change <- getOption("width")
  options(width = 70)
  timing <- proc.time()# for timing
  res <- list()
  #back to the original directory and options
  on.exit(setwd(old.dir), add = TRUE)
  on.exit(options(width = opt.change), add = TRUE)
  on.exit(timing <- proc.time() - timing, add = TRUE)
  on.exit(if (verbose) message("\nComputation time, overall: ", round(timing[[3]]), " sec"), add = TRUE)
  on.exit(if (verbose) cat("############################# completed filter_rad #############################\n"), add = TRUE)

  # Required package -----------------------------------------------------------
  if (!"SeqVarTools" %in% utils::installed.packages()[,"Package"] ||
      !"HardyWeinberg" %in% utils::installed.packages()[,"Package"] ||
      !"ggtern" %in% utils::installed.packages()[,"Package"] ||
      !"UpSetR" %in% utils::installed.packages()[,"Package"]
  ) {
    rlang::abort('For this function to work properly,
make sure you have these packages: SeqVarTools, HardyWeinberg, ggtern and UpSetR
install.packages("BiocManager")
install.packages("HardyWeinberg")
install.packages("ggtern")
BiocManager::install("SeqVarTools")
install.packages("UpSetR")
')
  }

  # Function call and dotslist -------------------------------------------------
  rad.dots <- radiator_dots(
    func.name = as.list(sys.call())[[1]],
    fd = rlang::fn_fmls_names(),
    args.list = as.list(environment()),
    dotslist = rlang::dots_list(..., .homonyms = "error", .check_assign = TRUE),
    keepers = c(
      "subsample.markers.stats",
      "filter.reproducibility", "filter.individuals.missing",
      "filter.individuals.heterozygosity", "filter.individuals.coverage.total",
      "filter.common.markers", "filter.monomorphic", "filter.mac",
      "filter.coverage", "filter.genotyping", "filter.snp.position.read",
      "filter.snp.number", "filter.short.ld", "filter.long.ld", "long.ld.missing",
      "ld.method", "detect.mixed.genomes", "ind.heterozygosity.threshold",
      "detect.duplicate.genomes",
      "filter.hwe", "hw.pop.threshold", "midp.threshold",
      "filter.strands", "random.seed", "path.folder", "filename",
      "blacklist.genotype", "erase.genotypes",
      "gt", "gt.bin", "gt.vcf", "gt.vcf.nuc",
      "pop.levels", "pop.labels", "pop.select", "blacklist.id",
      "markers.info", "keep.allele.names", "ref.calibration",
      "vcf.metadata", "vcf.stats",
      "whitelist.markers",
      "write.tidy",
      "dart.sequence",
      "hierarchical.levels", "imputation.method", "pred.mean.matching", "num.tree",
      "missing.memory", "internal"),
    verbose = TRUE
  )

  filter.common.markers.bk <- filter.common.markers
  filter.monomorphic.bk <- filter.monomorphic

  # Checking for missing and/or default arguments ------------------------------
  if (missing(data)) rlang::abort("data is missing")

  # Folders---------------------------------------------------------------------
  # wf for working folder
  # radiator.folder : the 01_radiator folder to put most things...
  wf <- path.folder <- generate_folder(
    f = path.folder,
    rad.folder = "filter_rad",
    prefix_int = FALSE,
    internal = internal,
    file.date = file.date,
    verbose = verbose)

  radiator.folder <- generate_folder(
    f = path.folder,
    rad.folder = "radiator",
    prefix_int = TRUE,
    internal = FALSE,
    file.date = file.date,
    verbose = verbose)

  # write the dots file
  write_rad(
    data = rad.dots,
    path = radiator.folder,
    filename = stringi::stri_join(
      "radiator_filter_rad_args_", file.date, ".tsv"),
    tsv = TRUE,
    internal = internal,
    verbose = verbose
  )

  # Random seed ----------------------------------------------------------------
  if (is.null(random.seed)) {
    random.seed <- sample(x = 1:1000000, size = 1)
    set.seed(random.seed)
  } else {
    set.seed(random.seed)
  }
  readr::write_lines(x = random.seed, path = file.path(radiator.folder, "random.seed"))
  if (verbose) message("File written: random.seed (", random.seed,")")

  # Filter parameter file: generate --------------------------------------------
  filters.parameters <- radiator_parameters(
    generate = TRUE,
    initiate = FALSE,
    update = FALSE,
    parameter.obj = NULL,
    path.folder = radiator.folder,
    file.date = file.date,
    verbose = verbose)

  # File type detection----------------------------------------------------------
  data.type <- radiator::detect_genomic_format(data)

  # Import file ----------------------------------------------------------------
  if (data.type %in% c(
    "tbl_df", "fst.file", "SeqVarGDSClass", "gds.file", "vcf.file", "dart")) {

    if (data.type %in% c("tbl_df", "fst.file", "SeqVarGDSClass", "gds.file")) {
      gds <- read_rad(data)
      data.type <- radiator::detect_genomic_format(gds)
    } else if (data.type %in% c("vcf.file")) {
      gds <- read_vcf(
        data = data,
        strata = strata,
        filter.strands = filter.strands,
        # random.seed = random.seed,
        filter.monomorphic = FALSE,
        filter.common.markers = FALSE,
        internal = TRUE,
        # filters.parameters = filters.parameters,
        path.folder = radiator.folder,
        parallel.core = parallel.core,
        verbose = FALSE)
      data.type <- "SeqVarGDSClass"
    } else {
      gds <- read_dart(
        data = data,
        strata = strata,
        filename = filename,
        verbose = FALSE,
        parallel.core = parallel.core,
        path.folder = radiator.folder,
        pop.levels = pop.levels,
        internal = TRUE
      )
      data.type <- "SeqVarGDSClass"
    }
  } else {
    gds <- radiator::tidy_genomic_data(
      data = data,
      strata = strata,
      parallel.core = parallel.core,
      verbose = FALSE,
      internal = TRUE,
      vcf.metadata = TRUE,
      vcf.stats = TRUE,
      gt.vcf.nuc = FALSE,
      gt.vcf = FALSE,
      gt = FALSE,
      gt.bin = TRUE
    )
  }

  source <- extract_source(gds) # to know if dart data or not...

  # Filter reproducibility -----------------------------------------------------
  if ("dart" %in% source) {
    # Filter parameter file: initiate
    filters.parameters <- radiator_parameters(
      generate = FALSE,
      initiate = TRUE,
      update = FALSE,
      parameter.obj = filters.parameters,
      data = gds,
      path.folder = radiator.folder,
      file.date = file.date,
      verbose = verbose)

    gds <- filter_dart_reproducibility(
      data = gds,
      interactive.filter = interactive.filter,
      filter.reproducibility = filter.reproducibility,
      parallel.core = parallel.core,
      verbose = verbose,
      parameters = filters.parameters,
      path.folder = wf,
      internal = FALSE)
  }

  # Filter_monomorphic----------------------------------------------------------
  gds <- filter_monomorphic(
    data = gds,
    filter.monomorphic = filter.monomorphic.bk,
    parallel.core = parallel.core,
    verbose = verbose,
    parameters = filters.parameters,
    path.folder = wf,
    internal = FALSE)

  # Filter common markers ------------------------------------------------------
  gds <- filter_common_markers(
    data = gds,
    filter.common.markers = filter.common.markers.bk,
    fig = TRUE,
    parallel.core = parallel.core,
    verbose = verbose,
    parameters = filters.parameters,
    path.folder = wf,
    internal = FALSE)

  # Filter Whitelist------------------------------------------------------------
  gds <- filter_whitelist(
    data = gds,
    whitelist.markers = whitelist.markers,
    verbose = verbose,
    path.folder = wf,
    parameters = filters.parameters,
    biallelic = biallelic,
    internal = FALSE)

  # Genotypes metadata ---------------------------------------------------------
  # check for coverage information...
  genotypes.meta <- extract_genotypes_metadata(gds, index.only = TRUE)
  count.data <- "ALLELE_REF_DEPTH" %in% genotypes.meta
  # coverage.info <- "READ_DEPTH" %in% genotypes.meta
  genotypes.meta <- NULL

  # Filter_individuals----------------------------------------------------------
  gds <- filter_individuals(
    data = gds,
    interactive.filter = interactive.filter,
    filter.individuals.missing = filter.individuals.missing,
    filter.individuals.heterozygosity = filter.individuals.heterozygosity,
    filter.individuals.coverage.total = filter.individuals.coverage.total,
    parallel.core = parallel.core,
    verbose = verbose,
    path.folder = wf,
    parameters = filters.parameters,
    dp = count.data,
    internal = FALSE
  )

  # Filter MAC------------------------------------------------------------------
  gds <- filter_mac(
    data = gds,
    interactive.filter = interactive.filter,
    filter.mac = filter.mac,
    filename = NULL,
    parallel.core = parallel.core,
    verbose = verbose,
    parameters = filters.parameters,
    path.folder = wf,
    internal = FALSE)


  # Filter coverage-------------------------------------------------------------
  gds <- filter_coverage(
    data = gds,
    interactive.filter = interactive.filter,
    filter.coverage = filter.coverage,
    filename = NULL,
    parallel.core = parallel.core,
    verbose = verbose,
    parameters = filters.parameters,
    path.folder = wf,
    internal = FALSE)

  # Filter genotyping---------------------------------------------------------
  gds <- filter_genotyping(
    data = gds,
    interactive.filter = interactive.filter,
    filter.genotyping = filter.genotyping,
    filename = NULL,
    parallel.core = parallel.core,
    verbose = verbose,
    parameters = filters.parameters,
    path.folder = wf,
    internal = FALSE)

  # Filter SNP position on the read---------------------------------------------
  gds <- filter_snp_position_read(
    data = gds,
    interactive.filter = interactive.filter,
    filter.snp.position.read = filter.snp.position.read,
    filename = NULL,
    parallel.core = parallel.core,
    verbose = verbose,
    parameters = filters.parameters,
    path.folder = wf,
    internal = FALSE)


  # Filter snp number per locus ------------------------------------------------
  gds <- filter_snp_number(
    data = gds,
    interactive.filter = interactive.filter,
    filter.snp.number = filter.snp.number,
    filename = NULL,
    parallel.core = parallel.core,
    verbose = verbose,
    parameters = filters.parameters,
    path.folder = wf,
    internal = FALSE)

  # Filter Linkage disequilibrium --------------------------------------------
  gds <- filter_ld(
    data = gds,
    interactive.filter = interactive.filter,
    filter.short.ld = filter.short.ld,
    filter.long.ld = filter.long.ld,
    parallel.core = parallel.core,
    filename = NULL,
    verbose = verbose,
    long.ld.missing = long.ld.missing,
    ld.method = ld.method,
    parameters = filters.parameters,
    path.folder = wf,
    internal = FALSE)


  # Detect mixed genomes -------------------------------------------------------
  gds <- detect_mixed_genomes(
    data = gds,
    interactive.filter = interactive.filter,
    detect.mixed.genomes = detect.mixed.genomes,
    ind.heterozygosity.threshold = NULL,
    parameters = filters.parameters,
    verbose = verbose,
    path.folder = wf,
    internal = FALSE)

  #Detect duplicate genomes ---------------------------------------------------
  gds <- detect_duplicate_genomes(
    data = gds,
    interactive.filter = interactive.filter,
    detect.duplicate.genomes = detect.duplicate.genomes,
    parallel.core = parallel.core,
    verbose = verbose,
    parameters = filters.parameters,
    random.seed = random.seed,
    path.folder = wf,
    internal = FALSE)

  # Filter HWE -----------------------------------------------------------------
  gds <- filter_hwe(
    data = gds,
    interactive.filter = interactive.filter,
    filter.hwe = filter.hwe,
    strata = NULL,
    hw.pop.threshold = hw.pop.threshold,
    midp.threshold = midp.threshold,
    parallel.core = parallel.core,
    parameters = filters.parameters,
    path.folder = wf,
    verbose = verbose,
    internal = FALSE)


  # Final Sync GDS -----------------------------------------------------------
  if (verbose) message("\nPreparing output files...")
  markers.meta <- extract_markers_metadata(
    gds = gds,
    whitelist = TRUE)

  strata <- extract_individuals_metadata(
    gds = gds,
    ind.field.select = c("INDIVIDUALS", "STRATA"),
    whitelist = TRUE)

  sync_gds(
    gds = gds,
    samples = strata$INDIVIDUALS,
    markers = markers.meta$VARIANT_ID
  )

  # FINAL PREP
  # filtered data folder
  path.folder <- generate_folder(
    f = wf,
    rad.folder = "filtered",
    internal = FALSE,
    file.date = file.date,
    verbose = verbose)

  # Whitelist
  write_rad(data = markers.meta,
            path = path.folder,
            filename = "whitelist.markers.tsv",
            tsv = TRUE,
            write.message = "standard",
            verbose = verbose)
  # blacklist
  bl <- extract_markers_metadata(gds = gds, blacklist = TRUE)
  if (nrow(bl) > 0) {
    write_rad(data = bl,
              path = path.folder,
              filename = "blacklist.markers.tsv",
              tsv = TRUE,
              write.message = "standard",
              verbose = verbose)
  }


  # writing the blacklist of id
  blacklist.id <- extract_individuals_metadata(gds = gds, blacklist = TRUE)
  if (nrow(blacklist.id) > 0) {
    write_rad(data = blacklist.id,
              path = path.folder,
              filename = "blacklist.id.tsv",
              tsv = TRUE,
              write.message = "standard",
              verbose = verbose)
  }

  # Generate new strata
  write_rad(data = strata,
            path = path.folder,
            filename = "strata.filtered.tsv",
            tsv = TRUE,
            write.message = "Writing the filtered strata: strata.filtered.tsv",
            verbose = verbose)


  # Statistics after filtering -------------------------------------------------
  if (verbose) message("\nGenerating statistics after filtering")
  # SUBSAMPLE markers
  n.markers <- length(markers.meta$VARIANT_ID)
  if (n.markers < 200000) subsample.markers.stats <- 1
  if (subsample.markers.stats < 1) {
    markers.subsampled <- dplyr::sample_frac(
      tbl = markers.meta,
      size = subsample.markers.stats)
    variant.select <- markers.subsampled$VARIANT_ID
    subsample.filename <- stringi::stri_join("markers.subsampled_", file.date, ".tsv")
    dplyr::select(markers.subsampled, MARKERS) %>%
      dplyr::mutate(RANDOM_SEED = random.seed) %>%
      readr::write_tsv(
        x = .,
        path = file.path(path.folder, subsample.filename))
    markers.subsampled <- NULL
  } else {
    variant.select <- NULL
  }

  # Individuals stats
  if (verbose) message("calculating individual stats...")
  id.stats <- generate_id_stats(
    gds = gds,
    subsample = variant.select,
    path.folder = path.folder,
    file.date = file.date,
    parallel.core = parallel.core,
    verbose = verbose
    ) %$% info

  # Markers stats
  if (verbose) message("calculating markers stats...")
  markers.stats <- generate_markers_stats(
    gds = gds,
    path.folder = path.folder,
    filename = NULL,
    file.date = file.date,
    parallel.core = parallel.core,
    verbose = verbose,
    subsample = variant.select
  ) %$% info

  # missing memory
  # if (verbose) message("Memorizing missing genotypes")
  # memory.filename <- stringi::stri_join(filename, "_filtered_missing_memory.rad")
  # dplyr::select(
  #   input, MARKERS, INDIVIDUALS, GT_BIN) %>%
  #   dplyr::mutate(GT_BIN = is.na(GT_BIN)) %>%
  #   dplyr::rename(ERASE = GT_BIN) %>%
  #   dplyr::arrange(MARKERS, INDIVIDUALS) %>%
  #   radiator::write_rad(data = ., path = memory.filename)
  # if (verbose) message("File written: ", memory.filename)

  # genomic_converter-----------------------------------------------------------
  if (verbose) message("\nTransferring data to genomic converter...")
  res$output <- genomic_converter(
    data = gds,
    strata = strata,
    output = output,
    parallel.core = parallel.core,
    filename = filename,
    verbose = FALSE,
    path.folder = path.folder,
    parameters = filters.parameters,
    filter.common.markers = FALSE,
    filter.monomorphic = FALSE,
    internal = TRUE)
  if (is.null(res$output)) res$output <- "not selected"
  summary_gds(gds = gds, verbose = TRUE)
  res$gds <- gds
  return(res)
}#End filter_rad
