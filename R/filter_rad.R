# Import, filter and transform a dart output file to different formats

#' @name filter_rad

#' @title Pipeline to filter RADseq data.

#' @description Designed for RADseq data. The function import VCF file,
#' apply filters and generate imputed datasets.
#' The function uses \code{\link[radiator]{tidy_vcf}} and several \code{filter_}
#' functions of radiator.


#' @param interactive.filter (optional, logical) Do you want the filtering session to
#' be interactive. The user is asked to see figures of distribution before
#' making decisions for filtering. If you opt for this, fill the arguments:
#' \code{data, strata, output},
#' optionally fill these ones \code{pop.levels, blacklist.id, pop.select,
#' monomorphic.out, common.markers}, the rest are not necessary.
#' Default: \code{interactive.filter = TRUE}.

#' @inheritParams genomic_converter
#' @inheritParams tidy_genomic_data

#' @param filter.markers.coverage (optional, string, numerical) Filter the lower and
#' upper bound of locus/read coverage. The locus/read coverage combines the markers
#' average count for REF and ALT allele (respectively the \code{AvgCountRef} and
#' \code{AvgCountSnp} info). These markers statistics are generated by DArT.
#' If you have count data, use \code{erase.genotypes} argument below instead.
#' Default: \code{filter.markers.coverage = NULL}.
#' e.g to keep markers with coverage inbetween 7 and 200,
#' use : \code{filter.markers.coverage = c(7, 200)}.

#' @param erase.genotypes (optional, string, numerical) DArT file with count
#' data is required for this argument to work. With count data, genotype,
#' REF and ALT coverage information is available and is better suited than
#' \code{filter.markers.coverage} to remove/erase data based on coverage info.
#' This function argument requires 3 values in the string:
#' \enumerate{
#' \item threshold.low.coverage: threshold for the minimum read coverage. Under this threshold,
#' genotypes are erased. e.g. 7
#' \item threshold.gl: threshold that applies only for heterozygous genotypes.
#' Using the \code{threshold.low.coverage} doesn't guarantees that REF and ALT
#' allele have adequate coverage. This threshold does.
#' A genotype likelihood value is generated based
#' on the departure of equal coverage between REF and ALT allele, number of samples
#' sharing the heterozygous genotype for the locus, missing data for the locus
#' and individual. Below the genotype likelihood threshold value,
#' the heterozygous genotypes are erased. e.g. if an heterozygous genotype for a
#' marker as REF/ALT coverage of 100/3 with only 1 sample sharing this info and
#' this sample has 50% missing data and the marker missingness is averaged, the
#' GL value will be extremely low compared to another heterozygous genotype with
#' 50/50 of coverage and 10 samples sharing the same genotype...
#' \item threshold.high.coverage: threshold that allows to erase genotypes with
#' very high coverage
#' }
#' e.g. of values: \code{erase.genotypes = c(7, -0.25, 200)}.
#' However, using the \code{interactive.filter = TRUE} is highly recommended to
#' visualize data before choosing values.
#' Default: \code{erase.genotypes = NULL}.

#' @param filter.individuals.missing (optional, double) New argument to blacklist
#' individuals with too many missing genotypes. Below the threshold, individuals
#' are blacklisted. e.g. 0.80 will blacklist individuals with more than 20% missing
#' genotypes.
#' Default: \code{filter.individuals.missing = NULL}.


#' @param filter.markers.missing (optional, string) Similar to call rate, but
#' more adapted to the data. 3 values are required in the string, corresponding
#' to the \code{\link[radiator]{filter_individual}} module of radiator.
#' First value is the approach to count genotyped individuals per markers, \code{"overall"}
#' or by \code{"pop"}. Second value is the percent threshold for the marker, with
#' \code{70}, 70 percent of genotyped individuals are required to keep the marker.
#' The last threshold is the number of problematic population that are allowed to skip
#' the threshold. In doubt, use the interactive mode that take step by step these
#' arguments. e.g to keep individuals genotyped at >= 70 percent for the markers,
#' without considering the population info and allowing 1 population to be problematic for the
#' threshold, use: \code{c("overall", 70, 1)}.
#' Default: \code{filter.markers.missing = NULL}.


#' @param number.snp.reads (optional, integer) This filter removes outlier markers
#' with too many SNP number per locus/read.
#' Having a higher than "normal" SNP number is usually the results of
#' assembly artifacts or bad assembly parameters.
#' This filter is population-agnostic. This is best decide after viewing the figures,
#' with the interactive mode.
#' If the argument is set to \code{number.snp.reads = 2},
#' locus with 3 and more SNPs will be blacklisted.
#' Default: \code{number.snp.reads = NULL}.

#' @param mixed.genomes.analysis (optional, logical) Highlight outliers individual's
#' observed heterozygosity for a quick
#' diagnostic of mixed samples or poor polymorphism discovery due to DNA quality,
#' sequencing effort, etc.
#' See this function for more info: \code{\link[radiator]{detect_mixed_genomes}}.
#' Default: \code{detect_mixed_genomes = TRUE}.

#' @inheritParams detect_mixed_genomes

#' @param duplicate.genomes.analysis (optional, string) Detect duplicate individuals.
#' The function can compute two methods (distance or genome pairwise similarity)
#' to highligh potential duplicate individuals.
#' See this function for more info: \code{\link[radiator]{detect_duplicate_genomes}}.
#' The string required to run the analysis as 2 values:
#' \enumerate{
#' \item TRUE/FALSE to run the analysis;
#' \item Computes pairwise genome similarity (TRUE/FALSE),
#' with FALSE just the distance measure is used.
#' The pairwise genome similarity is longer to run, but is better because it
#' integrates markers in common/missing data.
#' Using \code{interactive.filter = TRUE}, can overide this value,
#' you can opt in for the pairwise genome similarity after viewing the figures
#' used with distance measure... handy!
#' }
#' Default: \code{detect_duplicate_genomes = c(TRUE, FALSE)}.

#' @inheritParams filter_hwe

#' @param filename (optional) The filename prefix for the objet in the global environment
#' or the working directory. Default: \code{filename = NULL}. A default name will be used,
#' customized with the output file(s) selected.

#' @param ... (optional) To pass further argument for fine-tuning the function.

#' @note
#' The function requires 2 packages (not installed automatically with radiator):
#' \itemize{
#' \item HardyWeinberg: to filter markers in HWD
#' \item ggtern: to generate ternary graph
#' }

#' @return The function returns an object (list). The content of the object
#' can be listed with \code{names(object)} and use \code{$} to isolate specific
#' object (see examples). Some output format will write the output file in the
#' working directory. The tidy genomic data frame is generated automatically.

#' @export
#' @rdname filter_rad
#' @importFrom dplyr group_by select rename filter mutate summarise distinct n_distinct arrange left_join semi_join anti_join inner_join full_join tally bind_rows
#' @importFrom parallel detectCores
#' @importFrom stringi stri_replace_all_fixed stri_join stri_sub stri_replace_na stri_pad_left
#' @importFrom purrr discard
#' @importFrom readr read_tsv write_tsv
#' @importFrom tibble as_data_frame data_frame
#' @importFrom tidyr spread gather unite separate
#' @importFrom stats IQR

#' @examples
#' \dontrun{
#' require(HardyWeinberg)
#' require(ggtern)
#' shark <- radiator::filter_rad(
#'     data = "data.shark.vcf",
#'     strata = "strata.shark.tsv",
#'     output = "genind",
#'     filename = "shark.filters")
#' }

#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com} and Peter Grewe \email{peter.grewe@csiro.au}

filter_rad <- function(
  interactive.filter = TRUE,
  data,
  strata = NULL,
  output = NULL,
  pop.levels = NULL,
  blacklist.id = NULL,
  pop.select = NULL,
  monomorphic.out = TRUE,
  common.markers = TRUE,
  filter.markers.coverage = NULL,
  erase.genotypes = NULL,
  filter.individuals.missing = NULL,
  filter.markers.missing = NULL,
  maf.thresholds = NULL,
  number.snp.reads = NULL,
  snp.ld = "maf",
  mixed.genomes.analysis = TRUE,
  ind.heterozygosity.threshold = NULL,
  duplicate.genomes.analysis = c(TRUE, FALSE),
  hw.pop.threshold = 0,
  midp.threshold = "****",
  imputation.method = NULL,
  hierarchical.levels = "strata",
  num.tree = 50,
  filename = NULL,
  verbose = TRUE,
  parallel.core = parallel::detectCores() - 1,
  ...
) {

  # # testing
  # interactive.filter = TRUE
  # # strata = NULL
  # # output = NULL
  # pop.levels = NULL
  # blacklist.id = NULL
  # pop.select = NULL
  # monomorphic.out = TRUE
  # common.markers = TRUE
  # filter.markers.coverage = NULL
  # erase.genotypes = NULL
  # filter.individuals.missing = NULL
  # filter.markers.missing = NULL
  # maf.thresholds = NULL
  # number.snp.reads = NULL
  # snp.ld = "maf"
  # mixed.genomes.analysis = TRUE
  # ind.heterozygosity.threshold = NULL
  # duplicate.genomes.analysis = c(TRUE, FALSE)
  # hw.pop.threshold = 0
  # midp.threshold = "****"
  # imputation.method = NULL
  # hierarchical.levels = "strata"
  # num.tree = 50
  # # filename = NULL
  # verbose = TRUE
  # parallel.core = parallel::detectCores() - 1


  if (!requireNamespace("HardyWeinberg", quietly = TRUE)) {
    stop("HardyWeinberg package needed for this function to work
         Install with install.packages('HardyWeinberg')", call. = FALSE)
  }

  if (!requireNamespace("ggtern", quietly = TRUE)) {
    stop("ggtern package needed for this function to draw ternary plots
         Install with install.packages('ggtern')", call. = FALSE)
  }

  if (verbose) {
    cat("#######################################################################\n")
    cat("######################## radiator::filter_rad #########################\n")
    cat("#######################################################################\n")
  }
  opt.change <- getOption("width")
  options(width = 70)
  timing <- proc.time()# for timing
  res <- list()

  # dotslist -------------------------------------------------------------------
  # not yet used
  dotslist <- list(...)

  # Checking for missing and/or default arguments ------------------------------
  if (missing(data)) stop("Input file missing")

  # Filename -------------------------------------------------------------------
  file.date <- format(Sys.time(), "%Y%m%d@%H%M")

  if (is.null(filename)) {
    folder.extension <- filename <- stringi::stri_join("filter_rad_", file.date)
  } else {
    folder.extension <- stringi::stri_join("filter_rad", filename, file.date, sep = "_")
    filename <- stringi::stri_join(filename, file.date, sep = "_")
  }

  working.dir <- getwd()
  path.folder <- stringi::stri_join(working.dir,"/", folder.extension, sep = "")
  dir.create(file.path(path.folder))

  message("\nFolder created: \n", folder.extension)
  filename <- file.path(path.folder, filename)

  # Import file ----------------------------------------------------------------
  input <- radiator::tidy_genomic_data(
    data = data,
    strata = strata,
    vcf.metadata = TRUE,
    monomorphic.out = TRUE,
    common.markers = TRUE,
    pop.levels = pop.levels,
    pop.select = pop.select,
    blacklist.id = blacklist.id,
    parallel.core = parallel.core,
    verbose = FALSE,
    vcf.stats = TRUE,
    gt.vcf.nuc = TRUE,
    gt.vcf = TRUE,
    gt = TRUE,
    gt.bin = TRUE,
    keep.gds = FALSE
  )

  # Keep GT_BIN
  want <- c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "INDIVIDUALS",
            "POP_ID", "GT_BIN", "READ_DEPTH", "ALLELE_REF_DEPTH", "ALLELE_ALT_DEPTH",
            "GQ", "GL_HOM_REF", "GL_HET", "GL_HOM_ALT")
  input <- suppressWarnings(dplyr::select(input, dplyr::one_of(want)))


  # Move some files generated during import ------------------------------------
  if (verbose) cat("\n### 00: Imports #######################################################\n")
  folder.extension <- stringi::stri_join("00_Imports_", file.date, sep = "")
  path.folder.import <- file.path(path.folder, folder.extension)
  dir.create(path.folder.import)
  message("Folder created: ", folder.extension)

  old.files <- list.files(
    pattern = "blacklist.monomorphic.markers|blacklist.not.in.common.markers|markers.missing.all.id")
  new.files <-  file.path(path.folder.import, old.files)

  if (length(old.files) > 0) {
    purrr::pwalk(
      .l = list(from = old.files, to = new.files),
      .f = file.rename)
  }

  # Filter parameter file ------------------------------------------------------
  filters.parameters.path <- stringi::stri_join(
    path.folder, "/filters_parameters.tsv")
  filters.parameters <- tibble::data_frame(
    FILTERS = as.character(),
    PARAMETERS = as.character(),
    VALUES = as.integer(),
    BEFORE = as.character(),
    AFTER = as.character(),
    BLACKLIST = as.integer(),
    UNITS = as.character(),
    COMMENTS = as.character()) %>%
    readr::write_tsv(
      x = .,
      path = filters.parameters.path,
      append = FALSE,
      col_names = TRUE)
  message("Generated a filters parameters file: filters_parameters.tsv")

  # create 2 data.info
  data.info <- first.data.info <- data_info(input, print.info = TRUE)

  # strata, pop.levels, pop.labels, pop.select and blacklist.id ----------------
  if (verbose) cat("\n#######################################################################\n")
  strata.df <- dplyr::distinct(input, INDIVIDUALS, POP_ID)


  # check for count data
  count.data <- tibble::has_name(input, "ALLELE_REF_DEPTH")

  coverage.info <- tibble::has_name(input, "READ_DEPTH")

  #01. Individuals coverage stats
  #01.Filtering coverage --------------------------------------------------------
  if (!is.null(erase.genotypes) || !is.null(filter.markers.coverage) || interactive.filter) {
    if (verbose) cat("\n### 01: Filtering coverage ############################################\n")
    folder.extension <- stringi::stri_join("01_filter_coverage_", file.date, sep = "")
    path.folder.coverage <- file.path(path.folder, folder.extension)
    dir.create(path.folder.coverage)
    message("Folder created: ", folder.extension)
  }
  if (coverage.info) {
    if (!count.data && (interactive.filter || !is.null(filter.markers.coverage))) {
      message("Filtering markers mean coverage")
      want <- c("MARKERS", "CHROM", "LOCUS", "POS", "AVG_COUNT_REF", "AVG_COUNT_SNP")
      coverage <- dplyr::select(metadata, dplyr::one_of(want)) %>%
        dplyr::rename(REF = AVG_COUNT_REF, ALT = AVG_COUNT_SNP) %>%
        dplyr::distinct(MARKERS, REF, ALT, .keep_all = TRUE) %>%
        dplyr::mutate(READS = REF + ALT)

      coverage.long <- tidyr::gather(data = coverage, key = GROUP, value = COVERAGE, -c(MARKERS, CHROM, LOCUS, POS)) %>%
        dplyr::mutate(GROUP = factor(GROUP, levels = c("READS", "REF", "ALT"), ordered = TRUE))
      plot.coverage <- ggplot2::ggplot(
        data = coverage.long,
        ggplot2::aes(x = COVERAGE)) +
        ggplot2::geom_histogram() +
        ggplot2::labs(x = "Markers") +
        ggplot2::labs(y = "Coverage (count)") +
        ggplot2::theme(
          legend.position = "none",
          axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
          axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
          axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica", angle = 90, hjust = 1, vjust = 0.5),
          strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
        ) +
        ggplot2::facet_grid(~ GROUP)
      # plot.coverage
      suppressMessages(ggplot2::ggsave(
        filename = file.path(path.folder.coverage, "plot.coverage.pdf"),
        plot = plot.coverage,
        width = 30, height = 15, dpi = 600, units = "cm", useDingbats = FALSE))

      plot.coverage.boxplot <- ggplot2::ggplot(
        coverage.long,
        ggplot2::aes(x = factor(GROUP), y = COVERAGE, na.rm = TRUE)) +
        ggplot2::geom_violin(trim = TRUE) +
        ggplot2::geom_boxplot(width = 0.1, fill = "black", outlier.colour = NA) +
        ggplot2::stat_summary(fun.y = "mean", geom = "point", shape = 21, size = 2.5, fill = "white") +
        ggplot2::labs(x = "Markers") +
        ggplot2::labs(y = "Coverage (count)") +
        ggplot2::theme(
          legend.position = "none",
          axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
          axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
          axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica"),
          legend.title = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
          legend.text = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
          strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
        )
      # plot.coverage.boxplot
      suppressMessages(ggplot2::ggsave(
        filename = file.path(path.folder.coverage, "plot.coverage.boxplot.pdf"),
        plot = plot.coverage.boxplot,
        width = 15, height = 15, dpi = 600, units = "cm", useDingbats = FALSE))

      if (interactive.filter) {
        filter.coverage <- c(1, 1000000)
        message("    Inspect plots in folder created to help choose coverage thresholds (min and max)...")
        message("    Enter the minimum coverage allowed to keep a marker (e.g. 7): ")
        # filter.coverage[1] <- as.numeric(readLines(n = 1))
        filter.coverage[1] <- interactive_question(
          x = "Enter value: ", minmax = c(0, 10000000))

      }

      if (interactive.filter) {
        message("    Enter the maximum coverage allowed to keep a marker (e.g. 150): ")
        # filter.coverage[2] <- as.numeric(readLines(n = 1))
        # filter.coverage <- as.numeric(filter.coverage)
        filter.coverage[2] <- interactive_question(
          x = "Enter value: ", minmax = c(0, 10000000))
        filter.coverage <- as.numeric(filter.coverage)

      }

      if (!is.null(filter.coverage)) {
        want <- c("MARKERS", "CHROM", "LOCUS", "POS")
        blacklist.coverage.markers <- coverage %>%
          dplyr::filter(READS < filter.coverage[1] | READS > filter.coverage[2]) %>%
          dplyr::select(dplyr::one_of(want)) %>%
          dplyr::distinct(MARKERS, .keep_all = TRUE)

        if (nrow(blacklist.coverage.markers) > 0) {
          n.snp.before <- data.info$n.snp
          if (verbose) message("    Number of markers before = ", n.snp.before)
          n.snp.blacklist <- nrow(blacklist.coverage.markers)
          if (verbose) message("    Number of markers removed = ", n.snp.blacklist)
          if (verbose) message("    Number of markers after = ", n.snp.before - n.snp.blacklist)
          # input <- dplyr::anti_join(input, blacklist.coverage.markers, by = "MARKERS")

          metadata <- metadata %>%
            dplyr::filter(!MARKERS %in% blacklist.coverage.markers$MARKERS)

          whitelist.markers <- dplyr::select(metadata, dplyr::one_of(want)) %>%
            dplyr::distinct(MARKERS, .keep_all = TRUE)

          new.data.info <- data_info(metadata) # updating parameters
          filters.parameters <- tibble::data_frame(
            FILTERS = "coverage",
            PARAMETERS = "min/max",
            VALUES = stringi::stri_join(filter.coverage, collapse = "/"),
            BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
            AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
            BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
            UNITS = "CHROM/LOCUS/SNP",
            COMMENTS = ""
          )
          readr::write_tsv(x = filters.parameters,
                           path = filters.parameters.path, append = TRUE,
                           col_names = FALSE)
          # update data.info
          data.info <- new.data.info

          if (!is.null(blacklist.markers)) {
            blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.coverage.markers)
          } else {
            blacklist.markers <- blacklist.coverage.markers
          }

          # write blacklist and whitelist
          readr::write_tsv(x = blacklist.coverage.markers, path = file.path(path.folder.coverage, "blacklist.coverage.markers.tsv"))
          readr::write_tsv(x = whitelist.markers, path = file.path(path.folder.coverage, "whitelist.coverage.markers.tsv"))
        }
      } else {
        stop("A filter.coverage thresholds values are required...")
      }
      blacklist.coverage.markers <- coverage <- coverage.long <- plot.coverage <- plot.coverage.boxplot <- NULL
      message("File written: tidy.data.coverage.rad")
      radiator::write_rad(data = input, path = file.path(path.folder.coverage, "tidy.data.coverage.rad"))
      message("File written: tidy.data.coverage.rad")
    } else {# Counts data
      # Removing individuals with very low coverage ------------------------------
      # Filter low genotypes coverage---------------------------------------------
      message("Filtering genotypes coverage")

      if (!is.null(erase.genotypes)) {
        threshold.low.coverage <- erase.genotypes[1]
        threshold.gl <- erase.genotypes[2]
        threshold.high.coverage <- erase.genotypes[3]
      }

      #1. Filter low and high coverage for all genotypes with read depth ---------
      message("1. Genotypes coverage: low and high read depth")
      message("    generating plot...")
      cov_stats <- function(x, cov.filter = NULL) {
        x <- x[x>0 & !is.na(x)]

        if (!is.null(cov.filter)) {
          x <- x[x > cov.filter[1] & x < cov.filter[2]]
        }

        res <- tibble::data_frame(
          MEAN = mean(x, na.rm = TRUE),
          MEDIAN = stats::median(x, na.rm = TRUE),
          SD = stats::sd(x, na.rm = TRUE),
          Q25 = stats::quantile(x, 0.25, na.rm = TRUE),
          Q75 = stats::quantile(x, 0.75, na.rm = TRUE),
          IQR = stats::IQR(x, na.rm = TRUE),
          MIN = min(x, na.rm = TRUE),
          MAX = max(x, na.rm = TRUE),
          OUTLIERS_LOW = Q25 - (1.5 * IQR),
          OUTLIERS_HIGH = Q75 + (1.5 * IQR),
          OUTLIERS_LOW_N = length(x[x < OUTLIERS_LOW]),
          OUTLIERS_HIGH_N = length(x[x > OUTLIERS_HIGH]),
          OUTLIERS_TOTAL = OUTLIERS_HIGH_N + OUTLIERS_LOW_N,
          OUTLIERS_PROP = round(OUTLIERS_TOTAL / length(x), 3)
        )
        return(res)
      }

      cov.stats <- dplyr::bind_rows(
        tibble::add_column(.data = cov_stats(input$READ_DEPTH), GROUP = "GENOTYPES", FILTER = "with outliers", .before = 1),
        tibble::add_column(.data = cov_stats(input$ALLELE_REF_DEPTH), GROUP = "REF", FILTER = "with outliers", .before = 1),
        tibble::add_column(.data = cov_stats(input$ALLELE_ALT_DEPTH), GROUP = "ALT", FILTER = "with outliers", .before = 1)
      )

      cov.filter <- c(cov.stats$OUTLIERS_LOW[cov.stats$GROUP == "GENOTYPES"],
                      cov.stats$OUTLIERS_HIGH[cov.stats$GROUP == "GENOTYPES"])
      cov.stats <- dplyr::bind_rows(
        cov.stats,
        dplyr::bind_rows(
          tibble::add_column(.data = cov_stats(input$READ_DEPTH, cov.filter = cov.filter), GROUP = "GENOTYPES", FILTER = "without outliers", .before = 1),
          tibble::add_column(.data = cov_stats(input$ALLELE_REF_DEPTH, cov.filter = cov.filter), GROUP = "REF", FILTER = "without outliers", .before = 1),
          tibble::add_column(.data = cov_stats(input$ALLELE_ALT_DEPTH, cov.filter = cov.filter), GROUP = "ALT", FILTER = "without outliers", .before = 1)
        )
      ) %>%
        dplyr::mutate(
          GROUP = factor(GROUP, levels = c("GENOTYPES", "REF", "ALT"),
                         ordered = TRUE),
          FILTER = factor(FILTER, levels = c("with outliers", "without outliers"),
                          ordered = TRUE)
        ) %>%
        readr::write_tsv(
          x = .,
          path = file.path(path.folder.coverage,"genotypes.coverage.stats.tsv"))

      element.text <- ggplot2::element_text(size = 10,
                                            family = "Helvetica", face = "bold")
      range.with.outliers <- stringi::stri_join("coverage range with outliers: ", "[", cov.stats$MIN[cov.stats$GROUP == "GENOTYPES" & cov.stats$FILTER == "with outliers"], " - ", cov.stats$MAX[cov.stats$GROUP == "GENOTYPES" & cov.stats$FILTER == "with outliers"], "]")
      range.without.outliers <- stringi::stri_join("coverage range without outliers: ", "[", cov.stats$MIN[cov.stats$GROUP == "GENOTYPES" & cov.stats$FILTER == "without outliers"], " - ", cov.stats$MAX[cov.stats$GROUP == "GENOTYPES" & cov.stats$FILTER == "without outliers"], "]")
      data_range <- ggplot2::as_labeller(c(`with outliers` = range.with.outliers, `without outliers` = range.without.outliers))

      plot.coverage.boxplot <- ggplot2::ggplot(
        cov.stats,
        ggplot2::aes(factor(GROUP), na.rm = TRUE)) +
        ggplot2::geom_boxplot(
          ggplot2::aes(ymin = MIN, lower = Q25, middle = MEDIAN, upper = Q75, ymax = MAX), stat = "identity") +
        ggplot2::labs(
          x = "Coverage groups",
          y = "Coverage (read depth)",
          title = "Genotypes coverage information") + #, subtitle = stringi::stri_join("coverage range with outliers: ", range.with.outliers, "\ncoverage range without outliers: ", range.without.outliers)) +
        ggplot2::theme(
          plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
          # plot.subtitle = ggplot2::element_text(size = 10, family = "Helvetica", hjust = 0.5),
          legend.position = "none",
          axis.title.x = element.text,
          axis.title.y = element.text,
          axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica"),
          legend.title = element.text,
          legend.text = element.text,
          strip.text.x = element.text
        ) +
        ggplot2::facet_wrap(~FILTER, nrow = 2, ncol = 1, scales = "free", labeller = ggplot2::labeller(FILTER = data_range))
      cov.stats <- range.with.outliers <- range.without.outliers <- data_range <- NULL

      print(plot.coverage.boxplot)
      suppressMessages(ggplot2::ggsave(
        filename = file.path(path.folder.coverage, "plot.coverage.boxplot.pdf"),
        plot = plot.coverage.boxplot,
        width = 15, height = 20, dpi = 300, units = "cm", useDingbats = FALSE))
      plot.coverage.boxplot <- NULL

      if (interactive.filter) {
        threshold.low.coverage <- 0
        threshold.high.coverage <- 1000000000
        message("    Inspect plots to help choose min and max coverage threshold")
        message("    Enter the minimum read depth threshold to call a genotype")
        message("    Below this threshold, genotypes are erased (e.g. 10) ")
        threshold.low.coverage <- interactive_question(
          x = "Enter value: ", minmax = c(0, 10000000000))
        # threshold.low.coverage <- as.numeric(readLines(n = 1))
        message("    Enter the maximum read depth threshold to call a genotype")
        message("    Above this threshold, genotypes are erased (e.g. 200) ")
        threshold.high.coverage <- interactive_question(
          x = "Enter value: ", minmax = c(0, 10000000000))
        # threshold.high.coverage <- as.numeric(readLines(n = 1))
      }

      n.genotypes <- length(input$GT_BIN[!is.na(input$GT_BIN)])
      input <- input %>%
        dplyr::mutate(
          BLACKLIST_GENOTYPES_COMMENT = READ_DEPTH < threshold.low.coverage | READ_DEPTH > threshold.high.coverage)
      blacklist.genotypes <- dplyr::filter(input, BLACKLIST_GENOTYPES_COMMENT) %>%
        dplyr::mutate(BLACKLIST_GENOTYPES_COMMENT = "low or high coverage")
      n.blacklist.genotypes <- nrow(blacklist.genotypes)

      if (n.blacklist.genotypes > 0) {
        message("    number of blacklisted (erased) genotypes (%): ",
                n.blacklist.genotypes, " (",
                round(n.blacklist.genotypes / n.genotypes * 100, 2),")")

        blacklist.genotypes <- blacklist.genotypes %>%
          readr::write_tsv(
            x = .,
            path = file.path(path.folder.coverage, "blacklist.genotypes.tsv")) %>%
          dplyr::select(-BLACKLIST_GENOTYPES_COMMENT) %>%
          dplyr::mutate(
            GT_BIN = NA_integer_,
            ALLELE_REF_DEPTH = NA_integer_,
            ALLELE_ALT_DEPTH = NA_integer_,
            READ_DEPTH = NA_integer_)

        input <- input %>%
          dplyr::filter(is.na(READ_DEPTH) | !BLACKLIST_GENOTYPES_COMMENT) %>%
          dplyr::select(-BLACKLIST_GENOTYPES_COMMENT) %>%
          dplyr::bind_rows(blacklist.genotypes)
        blacklist.genotypes <- NULL

        # new.data.info <- data_info(metadata) # updating parameters
        n.genotypes.after <- n.genotypes - n.blacklist.genotypes
        filters.parameters <- tibble::data_frame(
          FILTERS = "low or high coverage",
          PARAMETERS = "min/max",
          VALUES = stringi::stri_join(threshold.low.coverage, threshold.high.coverage, sep = "/"),
          BEFORE = n.genotypes,
          AFTER = n.genotypes.after,
          BLACKLIST = n.blacklist.genotypes,
          UNITS = "genotypes",
          COMMENTS = ""
        )
        readr::write_tsv(x = filters.parameters,
                         path = filters.parameters.path, append = TRUE,
                         col_names = FALSE)
      } else {
        n.genotypes.after <- n.genotypes
      }

      # 2. het genotypes coverage ------------------------------------------------
      # escape a bit the first threshold
      # second pass of filtering using alleles coverage info
      # using the same threshold we explore the data.
      if (interactive.filter) {
        message("2. Heterozygous genotypes coverage: REF/ALT alleles below ", threshold.low.coverage, " reads")
      }
      gl_relative <- function(x) x / max(x, na.rm = TRUE)

      input <- suppressWarnings(radiator::write_rad(data = input, path = file.path(path.folder.coverage, "temp.coverage.rad")) %>%
          dplyr::select(MARKERS, INDIVIDUALS, GT_BIN, READ_DEPTH, ALLELE_REF_DEPTH, ALLELE_ALT_DEPTH) %>%
          dplyr::group_by(MARKERS) %>%
          dplyr::mutate(
            GENOTYPED_PROP_MARKERS = length(GT_BIN[!is.na(GT_BIN)]) / length(GT_BIN)
          ) %>%
          dplyr::group_by(INDIVIDUALS) %>%
          dplyr::mutate(
            GENOTYPED_PROP_INDIVIDUALS = length(GT_BIN[!is.na(GT_BIN)]) / length(GT_BIN)
          ) %>%
          dplyr::ungroup(.) %>%
          dplyr::filter(
            GT_BIN == 1,
            ALLELE_REF_DEPTH <= threshold.low.coverage | ALLELE_ALT_DEPTH <= threshold.low.coverage))

      ref.coverage.problem <- dplyr::filter(input, is.na(ALLELE_REF_DEPTH))
      alt.coverage.problem <- dplyr::filter(input, is.na(ALLELE_ALT_DEPTH))

      if (nrow(ref.coverage.problem) > 0) {
        message("\nProblem detected")
        message("    missing REF allele depth info")
        message("    number of genotypes with problem: ", nrow(ref.coverage.problem))
        message("    correcting problem by using read depth - ALT read depth info to recover the REF depth...\n\n")
        input %<>% dplyr::mutate(
          ALLELE_REF_DEPTH = dplyr::if_else(is.na(ALLELE_REF_DEPTH),
                                             READ_DEPTH - ALLELE_ALT_DEPTH, ALLELE_REF_DEPTH))
      }

      if (nrow(alt.coverage.problem) > 0) {
        message("\nProblem detected")
        message("    missing ALT allele depth info")
        message("    number of genotypes with problem: ", nrow(alt.coverage.problem))
        message("    correcting problem by using read depth - REF read depth info to recover the ALT depth...\n\n")
        input %<>% dplyr::mutate(
          ALLELE_ALT_DEPTH = dplyr::if_else(is.na(ALLELE_ALT_DEPTH),
                                            READ_DEPTH - ALLELE_REF_DEPTH, ALLELE_ALT_DEPTH))
      }

      suppressWarnings(input %<>%
          dplyr::group_by(MARKERS) %>%
          dplyr::mutate(NUMBER_INDIVIDUALS = length(INDIVIDUALS)) %>%
          dplyr::ungroup(.) %>%
          dplyr::mutate(
            ALLELE_RATIO_LIK = ALLELE_ALT_DEPTH / ALLELE_REF_DEPTH,
            ALLELE_RATIO_LIK = dplyr::if_else(ALLELE_RATIO_LIK > 1, 1 / ALLELE_RATIO_LIK, ALLELE_RATIO_LIK)
          ) %>%
          dplyr::mutate_at(
            .tbl = .,
            .vars = c("NUMBER_INDIVIDUALS", "GENOTYPED_PROP_MARKERS", "GENOTYPED_PROP_INDIVIDUALS"),
            .funs = gl_relative) %>%
          dplyr::mutate(
            # GT_BIN = factor(GT_BIN),
            # Different weight
            # Very primitive GL but really works well
            # Note to myself: z-score could also be used and explored here
            # similar to AMOVA with missing
            GL = ((ALLELE_RATIO_LIK * 4) +# The ratio between REF and ALT x4
                    (NUMBER_INDIVIDUALS * 3) +# The number of individuals with same genotypes x3
                    (GENOTYPED_PROP_INDIVIDUALS * 2) +# The number of individuals with same genotypes x3
                    GENOTYPED_PROP_MARKERS) / 10 # the proportion of genotypes within markers x1
          ) %>%
          dplyr::mutate_at(
            .tbl = .,
            .vars = "GL",
            .funs = gl_relative) %>%
          dplyr::select(MARKERS, INDIVIDUALS, GT_BIN, READ_DEPTH, ALLELE_REF_DEPTH,
                        ALLELE_ALT_DEPTH, GL, NUMBER_INDIVIDUALS,
                        GENOTYPED_PROP_MARKERS, GENOTYPED_PROP_INDIVIDUALS) %>%
          dplyr::mutate(GL = log10(GL)) %>%
          dplyr::arrange(GL)
        )

      plot.gl.violinplot <- input %>%
        dplyr::select(GT_BIN, ALLELE_REF_DEPTH, ALLELE_ALT_DEPTH, GL) %>%
        data.table::as.data.table(.) %>%
        data.table::melt.data.table(
          data = .,
          id.vars = c("GT_BIN", "GL"),
          variable.name = "ALLELES",
          value.name = "READ_DEPTH"
        ) %>%
        tibble::as_data_frame(.) %>%
        dplyr::filter(READ_DEPTH <= threshold.low.coverage)

      min.rd <- min(plot.gl.violinplot$READ_DEPTH)
      max.rd <- max(plot.gl.violinplot$READ_DEPTH)
      overall.range <- stringi::stri_join(min.rd, max.rd, sep = "-")
      overall.levels <- seq(from = min.rd, to = max.rd, by = 1)
      overall.levels <- c(overall.levels, overall.range)
      plot.gl.violinplot$READ_DEPTH <- as.character(plot.gl.violinplot$READ_DEPTH)

      plot.gl.violinplot <- suppressWarnings(
        dplyr::bind_rows(
          plot.gl.violinplot,
          plot.gl.violinplot %>%
            dplyr::mutate(
              ALLELES = rep("OVERALL", n()),
              READ_DEPTH = rep(overall.range, n()))
        ) %>%
          dplyr::mutate(
            ALLELES = factor(
              x = ALLELES,
              levels = c("ALLELE_REF_DEPTH", "ALLELE_ALT_DEPTH", "OVERALL"),
              labels = c("REF", "ALT", "OVERALL")),
            READ_DEPTH = factor(x = READ_DEPTH, levels = overall.levels)))

      plot.gl.violinplot <- ggplot2::ggplot(
        plot.gl.violinplot, ggplot2::aes(x = READ_DEPTH, y = GL, na.rm = TRUE)) +
        ggplot2::geom_violin(trim = TRUE) +
        ggplot2::geom_boxplot(width = 0.1, fill = "black", outlier.colour = NA) +
        ggplot2::stat_summary(fun.y = "mean", geom = "point", shape = 21,
                              size = 2.5, fill = "white") +
        ggplot2::labs(x = "Alleles read depth of heterozygous genotypes",
                      y = "Genotype Likelihood (GL)") +
        ggplot2::theme(
          legend.position = "none",
          axis.title.y = element.text,
          axis.title.x = element.text,
          axis.text.x = element.text
        ) +
        ggplot2::facet_wrap(~ ALLELES, scales = "free_x")
      print(plot.gl.violinplot)
      suppressWarnings(ggplot2::ggsave(
        filename = file.path(path.folder.coverage, "plot.gl.violinplot.pdf"),
        plot = plot.gl.violinplot,
        width = length(overall.levels) * 1.8, height = 10, dpi = 300, units = "cm",
        useDingbats = FALSE))
      plot.gl.violinplot <- NULL

      # GL and coverage correlation statistics------------------------------------
      cor_ref <- function(x) {
        stats::cor.test(~ ALLELE_REF_DEPTH + VALUE, data = x)
      }

      cor_alt <- function(x) {
        stats::cor.test(~ ALLELE_ALT_DEPTH + VALUE, data = x)
      }

      cor.data <- suppressWarnings(
        input %>%
          dplyr::mutate(GENOTYPE = seq(from = 1, to = n(), by = 1)) %>%
          dplyr::select(GENOTYPE, ALLELE_REF_DEPTH, ALLELE_ALT_DEPTH,
                        NUMBER_INDIVIDUALS, READ_DEPTH, GENOTYPED_PROP_MARKERS,
                        GENOTYPED_PROP_INDIVIDUALS) %>%
          data.table::as.data.table(.) %>%
          data.table::melt.data.table(
            data = .,
            id.vars = c("GENOTYPE", "ALLELE_REF_DEPTH", "ALLELE_ALT_DEPTH"),
            variable.name = "GROUP",
            value.name = "VALUE"
          ) %>%
          tibble::as_data_frame(.) %>%
          dplyr::select(-GENOTYPE))

      depth.cor <- suppressWarnings(
        cor.data %>%
          dplyr::group_by(GROUP) %>%
          tidyr::nest(.key = DATA) %>%
          dplyr::mutate(
            MODEL = purrr::map(purrr::map(.x = DATA, .f = cor_ref), broom::tidy)
          ) %>%
          tidyr::unnest(MODEL) %>%
          dplyr::select(-DATA)) %>%
        tibble::add_column(.data = ., ALLELE = rep("REF", nrow(.)), .before = 1)
      colnames(depth.cor) <- stringi::stri_trans_toupper(colnames(depth.cor))

      alt.cor <- suppressWarnings(
        cor.data %>%
          dplyr::group_by(GROUP) %>%
          tidyr::nest(.key = DATA) %>%
          dplyr::mutate(
            MODEL = purrr::map(purrr::map(.x = DATA, .f = cor_alt), broom::tidy)
          ) %>%
          tidyr::unnest(MODEL) %>%
          dplyr::select(-DATA)) %>%
        tibble::add_column(.data = ., ALLELE = rep("ALT", nrow(.)), .before = 1)
      colnames(alt.cor) <- stringi::stri_trans_toupper(colnames(alt.cor))
      cor.data <- NULL
      depth.cor <- dplyr::bind_rows(depth.cor, alt.cor)
      alt.cor <- NULL
      # View(depth.cor)
      readr::write_tsv(
        x = depth.cor,
        path = file.path(path.folder.coverage, "het.geno.correlation.tsv"))
      depth.cor <- NULL

      if (interactive.filter) {
        threshold.gl <- -1000000
        message("    Enter the gl threshold (close to 0 the better)")
        message("    Below this threshold, heterozygous genotypes are erased: ")
        # threshold.gl <- as.double(readLines(n = 1))
        threshold.gl <- interactive_question(
          x = "    Enter value: ", minmax = c(-1, 0))
      }


      blacklist.genotypes.gl <- dplyr::select(input, MARKERS, INDIVIDUALS, GL) %>%
        dplyr::filter(GL < threshold.gl) %>%
        dplyr::distinct(MARKERS, INDIVIDUALS) %>%
        dplyr::mutate(BLACKLIST_GENOTYPES_COMMENT = "bad.gl")
      input <- radiator::read_rad(data = file.path(path.folder.coverage, "temp.coverage.rad"))
      file.remove(file.path(path.folder.coverage, "temp.coverage.rad"))
      n.blacklist.genotypes <- nrow(blacklist.genotypes.gl)

      if (n.blacklist.genotypes > 0) {
        n.genotypes <- n.genotypes.after
        message("    number of blacklisted (erased) genotypes (%): ",
                n.blacklist.genotypes, " (",
                round(n.blacklist.genotypes / n.genotypes * 100, 2),")")

        input <- dplyr::left_join(
          input,
          blacklist.genotypes.gl, by = c("MARKERS", "INDIVIDUALS"))
        blacklist.genotypes.gl <- NULL

        blacklist.genotypes.gl <- dplyr::filter(
          input, BLACKLIST_GENOTYPES_COMMENT == "bad.gl") %>%
          readr::write_tsv(
            x = .,
            path = file.path(path.folder.coverage, "blacklist.genotypes.tsv"),
            append = TRUE) %>%
          dplyr::select(-BLACKLIST_GENOTYPES_COMMENT) %>%
          dplyr::mutate(
            GT_BIN = NA_integer_,
            ALLELE_REF_DEPTH = NA_integer_,
            ALLELE_ALT_DEPTH = NA_integer_,
            READ_DEPTH = NA_integer_
          )

        input <- input %>%
          dplyr::filter(
            is.na(BLACKLIST_GENOTYPES_COMMENT) | BLACKLIST_GENOTYPES_COMMENT != "bad.gl") %>%
          dplyr::select(-BLACKLIST_GENOTYPES_COMMENT) %>%
          dplyr::bind_rows(blacklist.genotypes.gl)
        blacklist.genotypes.gl <- NULL


        # new.data.info <- data_info(metadata) # updating parameters
        n.genotypes.after <- n.genotypes - n.blacklist.genotypes
        filters.parameters <- tibble::data_frame(
          FILTERS = "heterozygous genotypes low gl",
          PARAMETERS = "low gl",
          VALUES = threshold.gl,
          BEFORE = n.genotypes,
          AFTER = n.genotypes.after,
          BLACKLIST = n.blacklist.genotypes,
          UNITS = "genotypes",
          COMMENTS = ""
        ) %>%
          readr::write_tsv(
            x = .,
            path = filters.parameters.path, append = TRUE,
            col_names = FALSE)
      }
      element.text <- NULL

      # Write the file
      radiator::write_rad(data = input, path = file.path(path.folder.coverage, "tidy.data.coverage.rad"))
      message("File written: tidy.data.coverage.rad")

      # Individual coverage again...


    }#End filter coverage counts data
  } else {
    readme <- "coverage info not available"
    message(readme)
    readr::write_tsv(x = data.frame(readme), path = file.path(path.folder.coverage, "readme.tsv"))
  }

  # remove unnecessary metadata ------------------------------------------------
  if (count.data) {
    radiator::write_rad(
      data = dplyr::select(input, MARKERS, INDIVIDUALS, READ_DEPTH, ALLELE_REF_DEPTH, ALLELE_ALT_DEPTH),
      path = file.path(path.folder, "temp_markers_coverage_info.rad"))
    input <- dplyr::select(input, -c(READ_DEPTH, ALLELE_REF_DEPTH, ALLELE_ALT_DEPTH))
  }


  # blacklist.markers prep -----------------------------------------------------
  blacklist.markers <- NULL

  #02.Filter monomorphic markers  ------------------------------------------------
  if (monomorphic.out) {
    if (verbose) cat("\n### 02: Filtering monomorphic markers #################################\n")
    folder.extension <- stringi::stri_join("02_filter_monomorphic_markers_", file.date, sep = "")
    path.folder.mono <- file.path(path.folder, folder.extension)
    dir.create(path.folder.mono)
    message("Folder created: \n", folder.extension)

    input <- discard_monomorphic_markers(data = input, verbose = verbose)
    blacklist.monomorphic.markers <- input$blacklist.monomorphic.markers
    whitelist.markers <- input$whitelist.polymorphic.markers %>%
      readr::write_tsv(
        x = .,
        path = file.path(path.folder.mono, "whitelist.monomorphic.markers.tsv"))
    input <- input$input

    # update blacklist.markers
    if (nrow(blacklist.monomorphic.markers) > 0) {
      readr::write_tsv(x = blacklist.monomorphic.markers,
                       path = file.path(path.folder.mono, "blacklist.monomorphic.markers.tsv"))
      if (verbose) message("File written: blacklist.monomorphic.markers.tsv")

      if (is.null(blacklist.markers)) {
        blacklist.markers<- blacklist.monomorphic.markers
      } else {
        blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.monomorphic.markers)
      }

      new.data.info <- data_info(input)
      if (count.data) {
        new.data.info$n.chrom <- data.info$n.chrom
        new.data.info$n.locus <- NA_integer_
        n.locus.after <- "NA"
        bl.locus <- "NA"
      } else {
        n.locus.after <- new.data.info$n.locus
        bl.locus <- data.info$n.locus - n.locus.after
      }

      # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "removing monomorphic markers",
        PARAMETERS = "",
        VALUES = "",
        BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
        AFTER = paste(new.data.info$n.chrom, n.locus.after, new.data.info$n.snp, sep = "/"),
        BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, bl.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
        UNITS = "CHROM/LOCUS/SNP",
        COMMENTS = ""
      ) %>%
        readr::write_tsv(x = .,
                         path = filters.parameters.path, append = TRUE,
                         col_names = FALSE)
      # update data.info
      data.info <- new.data.info
      # Write the file
      radiator::write_rad(data = input, path = file.path(path.folder.mono, "tidy.data.monomorphic.rad"))
      message("File written: tidy.data.monomorphic.rad")
    }
    blacklist.monomorphic.markers <- NULL
  }# End monomorphic.out

  #03.Filter common markers between all populations  -----------------------------
  if (common.markers) {
    if (verbose) cat("\n### 03: Filtering common markers ######################################\n")
    folder.extension <- stringi::stri_join("03_filter_common_markers_", file.date, sep = "")
    path.folder.common <- file.path(path.folder, folder.extension)
    dir.create(path.folder.common)
    message("Folder created: \n", folder.extension)

    input <- keep_common_markers(data = input, plot = FALSE,
                                 verbose = verbose)
    blacklist.not.in.common.markers <- input$blacklist.not.in.common.markers
    whitelist.markers <- tibble::as_data_frame(input$whitelist.common.markers) %>%
      readr::write_tsv(
        x = .,
        path = file.path(path.folder.common, "whitelist.common.markers.tsv"))

    if (file.exists(file.path(getwd(), "whitelist.common.markers.tsv"))) {
      file.remove(file.path(getwd(), "whitelist.common.markers.tsv"))
    }
    input <- input$input

    if (nrow(blacklist.not.in.common.markers) > 0) {
      readr::write_tsv(x = blacklist.not.in.common.markers,
                       path = file.path(path.folder.common, "blacklist.not.in.common.markers.tsv"))
      if (verbose) message("File written: blacklist.not.in.common.markers.tsv")

      new.data.info <- data_info(input) # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "keeping common markers",
        PARAMETERS = "",
        VALUES = "",
        BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
        AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
        BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
        UNITS = "CHROM/LOCUS/SNP",
        COMMENTS = ""
      )
      readr::write_tsv(x = filters.parameters,
                       path = filters.parameters.path, append = TRUE,
                       col_names = FALSE)
      # update data.info
      data.info <- new.data.info
      if (!is.null(blacklist.markers)) {
        blacklist.markers <- dplyr::bind_rows(
          blacklist.markers,
          blacklist.not.in.common.markers)
      } else {
        blacklist.markers <- blacklist.not.in.common.markers
      }
      # Write the file
      radiator::write_rad(data = input, path = file.path(path.folder.common, "tidy.data.common.markers.rad"))
      message("File written: tidy.data.common.markers.rad")
    }
    blacklist.not.in.common.markers <- NULL
  } #End common.markers

  #04.Filter individuals with too many missing -----------------------------------
  if (!is.null(filter.individuals.missing) || interactive.filter) {
    if (verbose) cat("\n### 04: Filtering individuals poorly genotyped ########################\n")
    message("Finding individuals with too many missing genotypes...")
    folder.extension <- stringi::stri_join("04_filter_individuals_missing_", file.date, sep = "")
    path.folder.id.missing <- file.path(path.folder, folder.extension)
    dir.create(path.folder.id.missing)
    message("Folder created: \n", folder.extension)

    ind.missing <-  input %>%
      dplyr::select(INDIVIDUALS, POP_ID, GT_BIN) %>%
      dplyr::group_by(INDIVIDUALS, POP_ID) %>%
      dplyr::summarise(
        GENOTYPED_PROP_INDIVIDUALS = length(GT_BIN[!is.na(GT_BIN)]) / length(GT_BIN)
      ) %>%
      dplyr::ungroup(.) %>%
      dplyr::arrange(GENOTYPED_PROP_INDIVIDUALS) %>%
      readr::write_tsv(x = ., path = file.path(path.folder.id.missing, "individuals.genotyping.info.tsv"))
    pop.levels.missing <- c(levels(ind.missing$POP_ID), "OVERALL")

    overall <- ind.missing %>%
      dplyr::mutate(POP_ID = rep("OVERALL", n()))

    ind.missing <- suppressWarnings(dplyr::bind_rows(ind.missing, overall) %>%
                                      dplyr::mutate(POP_ID = factor(POP_ID, levels = pop.levels.missing)))
    overall <- pop.levels.missing <- NULL
    message("generating plot...")
    element.text <- ggplot2::element_text(size = 10,
                                          family = "Helvetica", face = "bold")
    outlier.id <- stats::quantile(ind.missing$GENOTYPED_PROP_INDIVIDUALS[ind.missing$POP_ID == "OVERALL"], 0.25, na.rm = TRUE) -
      (1.5 * stats::IQR(ind.missing$GENOTYPED_PROP_INDIVIDUALS[ind.missing$POP_ID == "OVERALL"], na.rm = TRUE))

    missing.ind.plot <- suppressWarnings(
      ggplot2::ggplot(
        ind.missing, ggplot2::aes(x = POP_ID, y = GENOTYPED_PROP_INDIVIDUALS, na.rm = TRUE)) +
        ggplot2::geom_boxplot() +
        ggplot2::labs(x = "Populations",
                      y = "Individuals genotyped (proportion)",
                      title = "Genotyped/missing information",
                      subtitle = stringi::stri_join("Overall outlier lower range: ", outlier.id)) +
        ggplot2::theme(
          legend.position = "none",
          plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
          plot.subtitle = ggplot2::element_text(size = 10, family = "Helvetica", hjust = 0.5),
          axis.title.y = element.text,
          axis.title.x = element.text,
          axis.text.x = element.text))
    outlier.id <- NULL
    # missing.ind.plot
    suppressWarnings(
      ggplot2::ggsave(
        plot = missing.ind.plot,
        filename = file.path(path.folder.id.missing, "plot.missing.ind.pdf"),
        width = data.info$n.pop * 2, height = 10, dpi = 300, units = "cm",
        useDingbats = FALSE)
    )

    if (interactive.filter) {
      print(missing.ind.plot)
      filter.individuals.missing <- 0
      message("    Inspect plot and tables to help choose threshold to blacklist individuals")
      message("    Enter the ind minimum genotyped proportion threshold")
      message("    Below this threshold, individuals are blacklisted (e.g. 0.5)")
      # filter.individuals.missing <- as.double(readLines(n = 1))
      filter.individuals.missing <- interactive_question(
        x = "Enter value: ", minmax = c(0, 1))
    }
    missing.ind.plot <- NULL
    blacklist.id <- ind.missing %>%
      dplyr::filter(POP_ID != "OVERALL") %>%
      dplyr::filter(GENOTYPED_PROP_INDIVIDUALS < filter.individuals.missing) %>%
      dplyr::select(INDIVIDUALS)
    ind.missing <- NULL
    if (nrow(blacklist.id) > 0) {
      res$blacklist.id <- dplyr::bind_rows(res$blacklist.id, blacklist.id)
      n.ind.blacklisted <- length(blacklist.id$INDIVIDUALS)
      if (verbose) message("\nBlacklisted individuals: ", n.ind.blacklisted, " ind.")
      if (verbose) message("    Filtering with blacklist of individuals")
      readr::write_tsv(x = blacklist.id, path = file.path(path.folder.id.missing, "blacklist.id.missing.tsv"))

      n.id.before <- dplyr::n_distinct(input$INDIVIDUALS)
      input <- dplyr::filter(input, !INDIVIDUALS %in% blacklist.id$INDIVIDUALS)
      n.id.after <- dplyr::n_distinct(input$INDIVIDUALS)
      # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "Filter individuals missing (blacklisted ids)",
        PARAMETERS = "filter.individuals.missing",
        VALUES = filter.individuals.missing,
        BEFORE = n.id.before,
        AFTER = n.id.after,
        BLACKLIST = n.ind.blacklisted,
        UNITS = "individuals",
        COMMENTS = ""
      ) %>%
        readr::write_tsv(x = ., path = filters.parameters.path,
                         append = TRUE, col_names = FALSE)
      # update data.info
      data.info$n.ind <- n.id.after
      # Write the file
      radiator::write_rad(data = input, path = file.path(path.folder.id.missing, "tidy.data.ind.missing.rad"))
      message("File written: tidy.data.ind.missing.rad")

      # Remove potential monomorphic markers------
      folder.extension <- stringi::stri_join("filter_monomorphic_markers_", file.date, sep = "")
      path.folder.mono <- file.path(path.folder.id.missing, folder.extension)
      dir.create(path.folder.mono)
      message("Folder created: \n", folder.extension)

      input <- discard_monomorphic_markers(data = input, verbose = verbose)
      blacklist.monomorphic.markers <- input$blacklist.monomorphic.markers
      whitelist.markers <- input$whitelist.polymorphic.markers
      input <- input$input

      # update blacklist.markers
      if (nrow(blacklist.monomorphic.markers) > 0) {
        readr::write_tsv(x = blacklist.monomorphic.markers,
                         path = file.path(path.folder.mono, "blacklist.monomorphic.markers.tsv"))
        if (verbose) message("File written: blacklist.monomorphic.markers.tsv")

        if (is.null(blacklist.markers)) {
          blacklist.markers<- blacklist.monomorphic.markers
        } else {
          blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.monomorphic.markers)
        }

        new.data.info <- data_info(input)
        if (count.data) {
          new.data.info$n.chrom <- data.info$n.chrom
          new.data.info$n.locus <- NA_integer_
          n.locus.after <- "NA"
          bl.locus <- "NA"
        } else {
          n.locus.after <- new.data.info$n.locus
          bl.locus <- data.info$n.locus - n.locus.after
        }

        # updating parameters
        filters.parameters <- tibble::data_frame(
          FILTERS = "removing monomorphic markers",
          PARAMETERS = "",
          VALUES = "",
          BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
          AFTER = paste(new.data.info$n.chrom, n.locus.after, new.data.info$n.snp, sep = "/"),
          BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, bl.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
          UNITS = "CHROM/LOCUS/SNP",
          COMMENTS = ""
        ) %>%
          readr::write_tsv(x = .,
                           path = filters.parameters.path, append = TRUE,
                           col_names = FALSE)
        # update data.info
        data.info <- new.data.info
        # Write the file
        radiator::write_rad(data = input, path = file.path(path.folder.mono, "tidy.data.monomorphic.rad"))
        message("File written: tidy.data.monomorphic.rad")
      }
      blacklist.monomorphic.markers <- NULL
    } else {
      if (verbose) message("\nBlacklisted individuals: no")
    }
  }#End filter missing per id

  #05.Filtering markers with too many missing ------------------------------------
  if (!is.null(filter.markers.missing) || interactive.filter) {

    if (verbose) cat("\n### 05: Filtering markers poorly genotyped ############################\n")
    if (!is.null(filter.markers.missing)) {
      ind.approach <- as.character(filter.markers.missing[1])
      ind.threshold <- as.numeric(filter.markers.missing[2])
      prob.pop.threshold <- as.integer(filter.markers.missing[3])
    }

    if (interactive.filter) {
      message("2 steps to visualize and filter markers based on the number of genotyped individuals:")
      message("Step 1. Impact of individual threshold on marker discovery")
      message("Step 2. Choose the filtering approach and thresholds")
    }

    # Folder
    folder.extension <- stringi::stri_join("05_filter_markers_missing_", file.date, sep = "")
    path.folder.ind.filter <- file.path(path.folder, folder.extension)
    dir.create(path.folder.ind.filter)
    message("\nFolder created: \n", folder.extension)

    # prepare filter, table and figure
    ind.total <- dplyr::n_distinct(input$INDIVIDUALS) # total number of individuals
    pop.number <- dplyr::n_distinct(input$POP_ID) # number of pop

    # individuals per pop
    ind.pop <- input %>%
      dplyr::distinct(POP_ID, INDIVIDUALS) %>%
      dplyr::group_by(POP_ID) %>%
      dplyr::tally(.) %>%
      dplyr::rename(N_IND = n)

    # input genotyped
    if (tibble::has_name(input, "GT_BIN")) {
      input.genotyped <- dplyr::filter(input, !is.na(GT_BIN))
    } else {
      input.genotyped <- dplyr::filter(input, GT != "000000")
    }

    # overall genotyped individuals
    overall <- input.genotyped %>%
      dplyr::select(MARKERS, INDIVIDUALS) %>%
      dplyr::group_by(MARKERS) %>%
      dplyr::tally(.) %>%
      dplyr::rename(GENOTYPED = n) %>%
      dplyr::mutate(PERCENT = ceiling(GENOTYPED/ind.total*100))

    # number of pop. genotyped per marker
    pop.genotyped.marker <- input.genotyped %>%
      dplyr::distinct(MARKERS, POP_ID) %>%
      dplyr::group_by(MARKERS) %>%
      dplyr::tally(.) %>%
      dplyr::rename(POP_GENOTYPED = n)

    # genotyped individuals per pop
    pop <- input.genotyped %>%
      dplyr::select(MARKERS, INDIVIDUALS, POP_ID) %>%
      dplyr::group_by(MARKERS, POP_ID) %>%
      dplyr::tally(.) %>%
      dplyr::rename(GENOTYPED = n) %>%
      dplyr::inner_join(ind.pop, by = "POP_ID") %>%
      dplyr::mutate(PERCENT = ceiling(GENOTYPED/N_IND*100))

    input.genotyped <- NULL # unused object

    # Step 1. Impact of individual threshold on marker discovery
    threshold.helper.overall <- overall %>%
      dplyr::ungroup(.) %>%
      dplyr::summarise(
        `10` = length(PERCENT[PERCENT >= 10]),
        `20` = length(PERCENT[PERCENT >= 20]),
        `30` = length(PERCENT[PERCENT >= 30]),
        `40` = length(PERCENT[PERCENT >= 40]),
        `50` = length(PERCENT[PERCENT >= 50]),
        `60` = length(PERCENT[PERCENT >= 60]),
        `70` = length(PERCENT[PERCENT >= 70]),
        `80` = length(PERCENT[PERCENT >= 80]),
        `90` = length(PERCENT[PERCENT >= 90]),
        `100` = length(PERCENT[PERCENT == 100])
      ) %>%
      tidyr::gather(data = ., key = IND_THRESHOLD, value = MARKER_NUMBER) %>%
      dplyr::mutate(POP_ID = rep("OVERALL", n()))

    threshold.helper.pop <- pop %>%
      dplyr::group_by(POP_ID) %>%
      dplyr::summarise(
        `10` = length(PERCENT[PERCENT >= 10]),
        `20` = length(PERCENT[PERCENT >= 20]),
        `30` = length(PERCENT[PERCENT >= 30]),
        `40` = length(PERCENT[PERCENT >= 40]),
        `50` = length(PERCENT[PERCENT >= 50]),
        `60` = length(PERCENT[PERCENT >= 60]),
        `70` = length(PERCENT[PERCENT >= 70]),
        `80` = length(PERCENT[PERCENT >= 80]),
        `90` = length(PERCENT[PERCENT >= 90]),
        `100` = length(PERCENT[PERCENT == 100])
      ) %>%
      tidyr::gather(data = ., key = IND_THRESHOLD, value = MARKER_NUMBER, -POP_ID)

    mean.pop <- threshold.helper.pop %>%
      dplyr::group_by(IND_THRESHOLD) %>%
      dplyr::summarise(
        MARKER_NUMBER = round(mean(MARKER_NUMBER), 0)
      ) %>%
      dplyr::mutate(POP_ID = rep("MEAN_POP", n()))

    # Make sure POP_ID is factor
    if (!is.factor(input$POP_ID)) {
      input$POP_ID <- factor(input$POP_ID)
    }

    threshold.helper <- suppressWarnings(
      dplyr::bind_rows(threshold.helper.pop, mean.pop, threshold.helper.overall) %>%
        dplyr::mutate(
          IND_THRESHOLD = as.numeric(IND_THRESHOLD),
          POP_ID = factor(POP_ID, levels = c(levels(input$POP_ID), "MEAN_POP", "OVERALL"), ordered = TRUE)
        ))

    # Set the breaks for the figure
    max.markers <- dplyr::n_distinct(input$MARKERS)

    #Function to replace plyr::round_any
    rounder <- function(x, accuracy, f = round) {
      f(x / accuracy) * accuracy
    }

    # max.markers <- 658
    if (max.markers >= 1000) {
      y.breaks.by <- rounder(max.markers/10, 100, ceiling)
      y.breaks.max <- rounder(max.markers, 1000, ceiling)
      y.breaks <- seq(0, y.breaks.max, by = y.breaks.by)
    } else {
      y.breaks.by <- rounder(max.markers/10, 10, ceiling)
      y.breaks.max <- rounder(max.markers, 100, ceiling)
      y.breaks <- seq(0, y.breaks.max, by = y.breaks.by)
    }

    plot.ind.threshold <- ggplot2::ggplot(threshold.helper, ggplot2::aes(x = IND_THRESHOLD, y = MARKER_NUMBER)) +
      ggplot2::geom_line() +
      ggplot2::geom_point(size = 2, shape = 21, fill = "white") +
      ggplot2::scale_x_continuous(name = "Individual threshold (percent)", breaks = seq(10, 100, by = 10)) +
      ggplot2::scale_y_continuous(name = "Number of markers", breaks = y.breaks, limits = c(0, y.breaks.max)) +
      ggplot2::theme(
        axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica", angle = 90, hjust = 1, vjust = 0.5),
        strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
      ) +
      ggplot2::facet_grid(~POP_ID)
    ggplot2::ggsave(
      plot = plot.ind.threshold,
      filename = file.path(path.folder.ind.filter, "plot.ind.threshold.pdf"),
      width = pop.number*5, height = 10,
      dpi = 600, units = "cm", useDingbats = FALSE)

    if (interactive.filter) {
      message("\nStep 1. Impact of individual threshold on marker discovery")
      print(plot.ind.threshold)
      message("Look at the plot and inspect the change in the number of markers
              in relation to the individual percentage thresholds\n")
    }

    # Helper table for individual thresholds
    ind.threshold.helper.table <- threshold.helper %>%
      dplyr::group_by(POP_ID) %>%
      tidyr::spread(data = ., key = IND_THRESHOLD, MARKER_NUMBER) %>%
      readr::write_tsv(
        x = .,
        path = file.path(path.folder.ind.filter, "ind.threshold.helper.table.tsv"))
    ind.threshold.helper.table <- NULL
    #     if (interactive.filter) {
    #       message("\nInspect the table (ind.threshold.helper.table) to help you view
    # the relation between individual thresholds and marker discovery:")
    #       message("First column: POP_ID")
    #       message("Remaining columns: the individual thresholds in percent
    # with the value = the number of markers discovered")
    #       message("The last 2 rows: MEAN_POP is the mean across your populations
    # and OVERALL is if you had 1 large population")
    #     }

    # Step 2. Choose the filtering approach and thresholds
    # 2 approach: filtering with the overall n. ind. ("overall") or by pop ("pop")
    if (interactive.filter) {
      message("Step 2. Choose the filtering approach and thresholds")
      message("The approach to filter a marker: do you want it based on the overall
              number of genotyped individuals or
              on the number of genotyped individuals per pop ? (overall or pop)")
      # ind.approach <- as.character(readLines(n = 1))
      ind.approach <- interactive_question(
        x = "Enter approach: ", answer.opt = c("overall", "pop"))
    }

    if (interactive.filter) {
      # message("Enter the individual threshold percentage")
      # ind.threshold <- as.numeric(readLines(n = 1))
      ind.threshold <- interactive_question(
        x = "Enter the individual threshold percentage: ", minmax = c(0, 100))
    }
    if (interactive.filter && ind.approach == "pop") {
      # message("Tolerance for deviation: look at the plot produced ealier and if you see some populations dragging down
      #         the number of markers for certain percentage thresholds, you have 3 options:\n
      #         1. remove the population (use pop.select argument to keep the desired populations)
      #         2. remove individuals with too many missing genotypes (use blacklist.id argument)
      #         3. use the next threshold (below) to allow variance and then
      #         manage the missing values with blacklist of individuals and/or
      #         missing data imputations.\n
      #         Enter the number of problematic population that you allow to deviate from the threshold:")
      message("Next, the threshold in the number of problematic population that you allow to deviate")
      # prob.pop.threshold <- as.numeric(readLines(n = 1))
      prob.pop.threshold <- interactive_question(
        x = "Enter the threshold: ", minmax = c(0, 100000000))
    }
    if (verbose) message("Filtering data")
    # some discrepencies need to be highlighted here. If you have entire pop not genotyped for a markers
    # this will compute them when doing the filtering:
    # summarise(GENOTYPED = length(INDIVIDUALS[GT != "000000"]))
    # if we first remove the individuals not genotyped with :
    # filter(GT != "000000")
    # the pop not genotyped are not accounted for. And this is what we want here.
    # filter_populations take care the ungenotyped pop and common.markers make sure that for certain analysis
    # you can have common markers or not.
    # so here we focus on when pop got a marker is it at 50% 60% 70%  ... genotyped?
    if (ind.approach == "overall") {
      threshold.id <- "(percent)"
      prob.pop.threshold <- "NA"
      ind.approach <- "overall individuals (no pop)"
      filter <- overall %>%
        dplyr::filter(PERCENT >= ind.threshold) %>%
        dplyr::distinct(MARKERS)
    } else {# approach by pop
      threshold.id <- "(percent)"
      ind.approach <- "individuals by pop"
      # ind.threshold <- 0.6
      # prob.pop.threshold <- 3
      filter <- pop %>%
        dplyr::ungroup(.) %>%
        dplyr::filter(PERCENT >= ind.threshold) %>%
        dplyr::group_by(MARKERS) %>%
        dplyr::tally(.) %>%
        dplyr::inner_join(pop.genotyped.marker, by = "MARKERS") %>%
        dplyr::mutate(PROB_POP = POP_GENOTYPED - n) %>%
        dplyr::filter(PROB_POP <= prob.pop.threshold) %>%
        dplyr::distinct(MARKERS)
    }

    # Apply the filter to the tidy data
    input <- dplyr::left_join(x = filter, input, by = "MARKERS")
    new.data.info <- data_info(input) # updating parameters

    n.snp.before <- data.info$n.snp
    if (verbose) message("    Number of markers before = ", n.snp.before)
    n.snp.blacklist <- n.snp.before - new.data.info$n.snp
    if (verbose) message("    Number of markers removed = ", n.snp.blacklist)
    if (verbose) message("    Number of markers after = ", n.snp.before - n.snp.blacklist)

    filters.parameters <- tibble::data_frame(
      FILTERS = "Filter markers missing",
      PARAMETERS = "ind.approach/ind.threshold/prob.pop.threshold",
      VALUES = stringi::stri_join(ind.approach, ind.threshold, prob.pop.threshold, sep = "/"),
      BEFORE = paste(data.info$n.chrom, data.info$n.locus, n.snp.before, sep = "/"),
      AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
      BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, n.snp.blacklist, sep = "/"),
      UNITS = "CHROM/LOCUS/SNP",
      COMMENTS = ""
    )
    # update data.info
    data.info <- new.data.info
    readr::write_tsv(x = filters.parameters,
                     path = filters.parameters.path, append = TRUE,
                     col_names = FALSE)
    new.whitelist.markers <- suppressWarnings(
      dplyr::select(input, dplyr::one_of(c("MARKERS", "CHROM", "LOCUS", "POS"))) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE)) %>%
      readr::write_tsv(x = ., path = "whitelist.markers.geno.tsv")

    blacklist.markers.geno <- dplyr::setdiff(whitelist.markers, new.whitelist.markers)
    if (nrow(blacklist.markers.geno) > 0) {
      readr::write_tsv(x = blacklist.markers.geno, path = file.path(path.folder.ind.filter, "blacklist.markers.geno.tsv"))
      if (!is.null(blacklist.markers)) {
        blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.markers.geno)
      } else {
        blacklist.markers <- blacklist.markers.geno
      }
    }

    # Write the file
    radiator::write_rad(data = input, path = file.path(path.folder.ind.filter, "tidy.data.markers.geno.rad"))
    message("File written: tidy.data.markers.geno.rad")

    whitelist.markers <- new.whitelist.markers
    new.whitelist.markers <- blacklist.markers.geno <- ind.total <- NULL
    pop.number <- ind.pop <- input.genotyped <- overall <- pop.genotyped.marker <- NULL
    pop <- threshold.helper.overall <- threshold.helper.pop <- NULL
    mean.pop <- threshold.helper <- max.markers <- filter <- NULL
    plot.ind.threshold <- NULL
  }#End filter.markers.missing

  # change to the new directory for MAF filtering
  old.dir <- getwd()
  setwd(path.folder)


  #06.Filter Minor Allele Frequency  ---------------------------------------------
  if (!is.null(maf.thresholds) || interactive.filter) {
    if (verbose) cat("\n### 06: Filtering markers with mac/maf  ###############################\n")

    if (interactive.filter) {
      maf.info <- radiator::filter_maf(
        data = input,
        maf.thresholds = c("SNP", 1, "OR", 1, 1),
        monomorphic.out = FALSE,
        parallel.core = parallel.core,
        interactive.filter = TRUE)
    } else {
      maf.info <- radiator::filter_maf(
        data = input,
        maf.thresholds = maf.thresholds,
        monomorphic.out = FALSE,
        parallel.core = parallel.core,
        interactive.filter = FALSE)
    }

    old.folder.maf <- list.files(path = path.folder, pattern = "filter_maf")
    new.folder.maf <- stringi::stri_join("06_", old.folder.maf)
    file.rename(from = old.folder.maf, to = new.folder.maf)
    old.folder.maf <- new.folder.maf <- NULL
    # param.delete <- list.files(path = path.folder, pattern = "filters_parameters.tsv", full.names = TRUE)
    # suppressWarnings(param.delete <- file.remove(param.delete))
    # param.delete <- NULL

    # param <- maf.info$filters.parameters

    blacklist.markers.maf <- maf.info$blacklist.markers
    whitelist.markers <- maf.info$whitelist.markers
    input <- maf.info$tidy.filtered.maf
    maf.info <- NULL
    if (nrow(blacklist.markers.maf) > 0) {
      # readr::write_tsv(x = param,
      #                  path = filters.parameters.path, append = TRUE,
      #                  col_names = FALSE)
      n.snp.before <- data.info$n.snp
      n.snp.blacklist <- nrow(blacklist.markers.maf)
      data.info <- data_info(input)
      if (!is.null(blacklist.markers)) {
        blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.markers.maf)
      } else {
        blacklist.markers <- blacklist.markers.maf
      }
      # Write the file
      radiator::write_rad(data = input, path = file.path(path.folder.ind.filter, "tidy.data.markers.geno.rad"))
      message("File written: tidy.data.markers.geno.rad")

      # Write the file
      new.folder.maf <- list.files(path = path.folder, pattern = "06_filter_maf", full.names = TRUE)
      radiator::write_rad(data = input, path = file.path(new.folder.maf, "tidy.data.maf.rad"))
      message("File written: tidy.data.maf.rad")
      new.folder.maf <- NULL
    }
    blacklist.markers.maf <- param <- NULL
  }# End maf.thresholds

  #07.Filter snp number  ---------------------------------------------------------
  if (!is.null(number.snp.reads) || interactive.filter) {
    setwd(path.folder)
    if (verbose) cat("\n### 07: Filtering SNP number per read/locus ###########################\n")
    folder.extension <- stringi::stri_join("07_filter_snp_number_", file.date, sep = "")
    path.folder.snp.number <- file.path(path.folder, folder.extension)
    dir.create(path.folder.snp.number)
    message("Folder created: \n", folder.extension)

    # get the number of SNP per reads/haplotypes/locus
    number.snp <- dplyr::distinct(input, MARKERS, CHROM, LOCUS, POS) %>%
      dplyr::group_by(LOCUS) %>%
      dplyr::mutate(SNP_N = dplyr::n_distinct(POS))

    number.snp.plot.data <- number.snp %>% dplyr::distinct(LOCUS, SNP_N)

    number.snp.reads.plot <- ggplot2::ggplot(number.snp.plot.data, ggplot2::aes(factor(SNP_N))) +
      ggplot2::geom_bar() +
      ggplot2::labs(x = "Number of SNP per haplotypes (reads)") +
      ggplot2::labs(y = "Distribution (number)") +
      ggplot2::theme(
        axis.title.x = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold"),
        legend.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold"),
        legend.text = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold"),
        strip.text.x = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold"))
    number.snp.plot.data <- NULL
    # save
    ggplot2::ggsave(
      filename = file.path(path.folder.snp.number, "number.snp.locus.plot.pdf"),
      plot = number.snp.reads.plot,
      width = 20, height = 10, dpi = 300, units = "cm", useDingbats = FALSE)

    if (interactive.filter) {
      message("2 non-exclusive methods to manage short LD and the number of SNPs/reads/locus:")
      message("    1. Remove outlier markers with too many SNPs/locus")
      message("    2. Keep only 1 SNP/locus")
    }

    if (verbose) message("\nPlot written: number.snp.locus.plot.pdf")
    if (interactive.filter) {
      print(number.snp.reads.plot)
      message("1. Remove outlier markers with too many SNPs/locus")
      message("   Based on the plot, choose the threshold")
      message("   in maximum number of SNP/locus allowed")
      message("   (turn off by using a large integer): ")
      # number.snp.reads <- as.integer(readLines(n = 1))
      number.snp.reads <- interactive_question(
        x = "Enter the number of SNP: ", minmax = c(0, 100))
    }

    blacklist.snp.number.markers <- number.snp %>%
      dplyr::filter(SNP_N > number.snp.reads) %>%
      dplyr::distinct(LOCUS)

    if (nrow(blacklist.snp.number.markers) > 0) {
      n.snp.before <- data.info$n.snp
      blacklist.snp.number.markers <- dplyr::left_join(
        blacklist.snp.number.markers, input, by = "LOCUS") %>%
        dplyr::select(MARKERS, CHROM, LOCUS, POS) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE) %>%
        readr::write_tsv(
          x = .,
          path = file.path(path.folder.snp.number, "blacklist.snp.number.markers.tsv"))

      input <- dplyr::filter(input,
                             !MARKERS %in% blacklist.snp.number.markers$MARKERS)

      whitelist.markers <- dplyr::select(input, dplyr::one_of(c("MARKERS", "CHROM", "LOCUS", "POS"))) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE) %>%
        readr::write_tsv(
          x = .,
          path = file.path(path.folder.snp.number, "whitelist.snp.number.markers.tsv"))
      new.data.info <- data_info(input) # updating parameters

      if (verbose) message("    Number of markers before = ", n.snp.before)
      if (verbose) message("    Number of markers removed = ", data.info$n.snp - new.data.info$n.snp)
      if (verbose) message("    Number of markers after = ", new.data.info$n.snp)

      filters.parameters <- tibble::data_frame(
        FILTERS = "SNP number per reads/locus",
        PARAMETERS = "",
        VALUES = number.snp.reads,
        BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
        AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
        BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
        UNITS = "CHROM/LOCUS/SNP",
        COMMENTS = ""
      ) %>%
        readr::write_tsv(x = .,
                         path = filters.parameters.path, append = TRUE,
                         col_names = FALSE)
      # update data.info
      data.info <- new.data.info
      if (!is.null(blacklist.markers)) {
        blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.snp.number.markers)
      } else {
        blacklist.markers <- blacklist.snp.number.markers
      }
      # Write the file
      radiator::write_rad(data = input, path = file.path(path.folder.snp.number, "tidy.data.snp.number.rad"))
      message("File written: tidy.data.snp.number.rad")
    }
    blacklist.snp.number.markers <- number.snp <- number.snp.reads.plot <- NULL

    if (interactive.filter) {
      message("2. Keep only 1 SNP/locus to manage short LD")
      # message("   Do you want to run this filter (y/n):")
      # run.snp.ld <- as.character(readLines(n = 1))
      run.snp.ld <- interactive_question(
        x = "   Do you want to run this filter (y/n):", answer.opt = c("y", "n"))
    }

    if (interactive.filter && run.snp.ld == "y") {
      message("4 options:")
      message("   random: for a random selection of 1 SNP on the read")
      message("   first: for the first one on the read")
      message("   last: for the last SNP on the read and")
      message("   middle: for locus > 2 SNPs, keep the middle SNP")
      message("   maf: keeps the SNP with the highest MAF")
      # snp.ld <- as.character(readLines(n = 1))
      snp.ld <- interactive_question(
        x = "\n   ENTER your choice: ", answer.opt = c("random", "first", "last", "middle", "maf"))
    } else {
      snp.ld <- NULL
    }

    if (!is.null(snp.ld)) {
      snp.ld <- match.arg(snp.ld, c("first", "random", "last", "middle", "maf"))

      if (snp.ld == "maf") {
        maf.data <- list.files(
          path = path.folder, pattern = "maf.data.tsv",
          full.names = TRUE, recursive = TRUE, include.dirs = TRUE)
      } else {
        maf.data <- NULL
      }

      want <- c("MARKERS", "CHROM", "LOCUS", "POS")
      blacklist.snp.ld.markers <- input %>%
        dplyr::select(dplyr::one_of(want)) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE)

      input <- snp_ld(
        data = input,
        snp.ld = snp.ld,
        maf.data = maf.data,
        parallel.core = parallel.core)

      whitelist.snp.ld.markers <- input %>%
        dplyr::select(dplyr::one_of(want)) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE)

      blacklist.snp.ld.markers <- blacklist.snp.ld.markers %>%
        dplyr::filter(!MARKERS %in% whitelist.snp.ld.markers$MARKERS)

      if (nrow(blacklist.snp.ld.markers) > 0) {
        n.snp.before <- data.info$n.snp
        readr::write_tsv(
          x = blacklist.snp.ld.markers,
          path = file.path(path.folder.snp.number, "blacklist.snp.ld.markers.tsv"))
        whitelist.markers <- whitelist.snp.ld.markers %>%
          readr::write_tsv(
            x = .,
            path = file.path(path.folder.snp.number, "whitelist.snp.ld.markers.tsv"))
        new.data.info <- data_info(input) # updating parameters

        #if (verbose) message("    Number of markers before = ", n.snp.before)
        #if (verbose) message("    Number of markers removed = ", data.info$n.snp - new.data.info$n.snp)
        #if (verbose) message("    Number of markers after = ", new.data.info$n.snp)

        filters.parameters <- tibble::data_frame(
          FILTERS = "Short linkage disequilibrium",
          PARAMETERS = "snp.ld",
          VALUES = snp.ld,
          BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
          AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
          BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
          UNITS = "CHROM/LOCUS/SNP",
          COMMENTS = ""
        ) %>%
          readr::write_tsv(x = .,
                           path = filters.parameters.path, append = TRUE,
                           col_names = FALSE)
        # update data.info
        data.info <- new.data.info
        if (!is.null(blacklist.markers)) {
          blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.snp.ld.markers)
        } else {
          blacklist.markers <- blacklist.snp.ld.markers
        }
        # Write the file
        radiator::write_rad(data = input, path = file.path(path.folder.snp.number, "tidy.data.snp.ld.rad"))
        message("File written: tidy.data.snp.ld.rad")
      }# snp.ld
    }
    whitelist.snp.ld.markers <- blacklist.snp.ld.markers <- NULL
  }#End number.snp.reads

  # Data quality AFTER filters --------------------------------------------------
  #08.Detect mixed genomes -------------------------------------------------------
  if (interactive.filter || mixed.genomes.analysis) {
    if (verbose) cat("\n### 08: Detect mixed genomes ##########################################\n")
    # if (verbose) message("Mixed genomes analysis ...")
    mixed.genomes.analysis <- radiator::detect_mixed_genomes(
      data = input,
      ind.heterozygosity.threshold = ind.heterozygosity.threshold,
      verbose = FALSE)

    blacklist.ind.het <- mixed.genomes.analysis$blacklist.ind.het

    if (interactive.filter) {
      message("\n\nInspect plots and tables in folder created...")
      # message("    Do you want to exclude individuals based on heterozygosity ? (y/n): ")
      # mixed.gen.analysis <- as.character(readLines(n = 1))
      mixed.gen.analysis <- interactive_question(
        x = "    Do you want to exclude individuals based on heterozygosity ? (y/n): ", answer.opt = c("y", "n"))


      if (mixed.gen.analysis == "y") {
        mix.text <- "    Enter the min value for ind.heterozygosity.threshold argument (0 turns off): "
        # threshold.min <- as.numeric(readLines(n = 1))
        threshold.min <- interactive_question(x = mix.text, minmax = c(0, 1))

        mix.text <- "Enter the max value for ind.heterozygosity.threshold argument (1 turns off): "
        # threshold.max <- as.numeric(readLines(n = 1))
        threshold.max <- interactive_question(x = mix.text, minmax = c(0, 1))

        blacklist.ind.het  <- dplyr::ungroup(mixed.genomes.analysis$individual.heterozygosity) %>%
          dplyr::filter(HET_PROP > threshold.max | HET_PROP < threshold.min) %>%
          dplyr::distinct(INDIVIDUALS)
        ind.heterozygosity.threshold <- as.numeric(c(threshold.min, threshold.max))
      }
    }


    if (!is.null(nrow(blacklist.ind.het)) && nrow(blacklist.ind.het) > 0) {
      n.ind.blacklisted <- length(blacklist.ind.het$INDIVIDUALS)
      message("Filter individual's heterozygosity: ", n.ind.blacklisted, " individual(s) blacklisted")
      mixed.genome.folder <- list.files(path = path.folder, pattern = "detect_mixed_genomes", full.names = TRUE)

      if (length(mixed.genome.folder) > 1) {
        mixed.genome.folder <- file.info(mixed.genome.folder) %>%
          tibble::rownames_to_column(df = ., var = "FILE") %>%
          dplyr::filter(mtime == max(mtime))
        mixed.genome.folder <- mixed.genome.folder$FILE
      }

      readr::write_tsv(
        x = blacklist.ind.het,
        path = stringi::stri_join(mixed.genome.folder, "/blacklist.ind.het.tsv"),
        col_names = TRUE)

      res$blacklist.id <- res$blacklist.id %>% dplyr::bind_rows(blacklist.ind.het)

      input <- dplyr::anti_join(
        input,
        blacklist.ind.het, by = "INDIVIDUALS")

      # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "detect mixed genomes",
        PARAMETERS = "ind.heterozygosity.threshold (min/max)",
        VALUES = stringi::stri_join(ind.heterozygosity.threshold, collapse = "/"),
        BEFORE = data.info$n.ind,
        AFTER = data.info$n.ind - n.ind.blacklisted,
        BLACKLIST = n.ind.blacklisted,
        UNITS = "individuals",
        COMMENTS = ""
      ) %>%
        readr::write_tsv(x = ., path = filters.parameters.path,
                         append = TRUE, col_names = FALSE)
      # update data.info
      data.info$n.ind <- data.info$n.ind - n.ind.blacklisted

      # Filter monomorphic markers again
      input <- discard_monomorphic_markers(data = input, verbose = verbose)
      blacklist.monomorphic.markers <- input$blacklist.monomorphic.markers
      whitelist.markers <- input$whitelist.polymorphic.markers
      input <- input$input

      # update blacklist.markers
      if (nrow(blacklist.monomorphic.markers) > 0) {
        readr::write_tsv(x = blacklist.monomorphic.markers,
                         path = file.path(path.folder, "blacklist.monomorphic.markers.tsv"))
        if (verbose) message("File written: blacklist.monomorphic.markers.tsv")

        if (is.null(blacklist.markers)) {
          blacklist.markers<- blacklist.monomorphic.markers
        } else {
          blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.monomorphic.markers)
        }

        new.data.info <- data_info(input)

        # updating parameters
        filters.parameters <- tibble::data_frame(
          FILTERS = "removing monomorphic markers",
          PARAMETERS = "",
          VALUES = "",
          BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
          AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
          BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
          UNITS = "CHROM/LOCUS/SNP",
          COMMENTS = ""
        ) %>%
          readr::write_tsv(
            x = .,
            path = filters.parameters.path, append = TRUE,
            col_names = FALSE)
        # update data.info
        data.info <- new.data.info
      }
      blacklist.monomorphic.markers <- NULL
    }
    mixed.genomes.analysis <- NULL

    old.folder <- list.files(path = path.folder, pattern = "detect_mixed_genomes")
    new.folder <- stringi::stri_join("08_", old.folder)
    file.rename(from = old.folder, to = new.folder)

    mono.file <- list.files(path = path.folder, pattern = "blacklist.monomorphic.markers")
    mono.file.full <- list.files(path = path.folder,
                                 pattern = "blacklist.monomorphic.markers",
                                 full.names = TRUE)
    if (length(mono.file) > 0 && file.exists(mono.file)) {
      new.mono.file <- file.path(new.folder, mono.file)
      file.rename(from = mono.file.full, to = new.mono.file)
    }

    # Write the file
    path.genome.mix <- list.files(path = path.folder, pattern = "08_detect_mixed_genomes", full.names = TRUE)
    radiator::write_rad(data = input, path = file.path(path.genome.mix, "tidy.data.mix.gen.rad"))
    message("File written: tidy.data.mix.gen.rad")
    path.genome.mix <- NULL
    old.folder <- new.folder <- mono.file <- mono.file.full <-  NULL
  }# End mixed genomes

  #09.Detect duplicate genomes ---------------------------------------------------
  genome <- duplicate.genomes.analysis[2]
  duplicate.genomes.analysis <- duplicate.genomes.analysis[1]

  if (interactive.filter || duplicate.genomes.analysis) {
    if (verbose) cat("\n### 09: Detect duplicate genomes ######################################\n")

    # if (verbose) message("Duplicate genomes analysis...")
    duplicate.genomes <- radiator::detect_duplicate_genomes(
      data = input,
      distance.method = "manhattan",
      genome = genome,
      blacklist.duplicates = TRUE,
      parallel.core = parallel.core,
      verbose = FALSE)

    # subsample.markers = NULL # test
    # random.seed = NULL # test

    if (interactive.filter) {
      message("\n\n    Inspect plots and tables")
      # filtering by distance or pairwise genome similarity ?

      message("    Suspicious about the duplicates analysis?")
      message("    Run the full pairwise genome comparisons")
      message("    This approach integrates markers in common & missing data\n")

      dup.text <- "    Do you want to run the pairwise genome comparison (y/n): "
      # genome <- as.character(readLines(n = 1))
      genome <- interactive_question(x = dup.text, answer.opt = c("y", "n"))

      if (genome == "y") {
        duplicate.genomes <- radiator::detect_duplicate_genomes(
          data = input,
          distance.method = "manhattan",
          genome = TRUE,
          blacklist.duplicates = TRUE,
          parallel.core = parallel.core,
          verbose = FALSE)
      }

      old.folder <- list.files(path = path.folder, pattern = "detect_duplicate_genomes")
      new.folder <- stringi::stri_join("09_", old.folder)
      file.rename(from = old.folder, to = new.folder)
      old.folder <- new.folder <- NULL

      dup.genome.folder <- list.files(
        path = path.folder,
        pattern = "detect_duplicate_genomes", full.names = TRUE)

      if (length(dup.genome.folder) > 1) {
        dup.genome.folder <- file.info(dup.genome.folder) %>%
          tibble::rownames_to_column(df = ., var = "FILE") %>%
          dplyr::filter(mtime == max(mtime))
        dup.genome.folder <- dup.genome.folder$FILE
      }

      # Check for a blacklist
      blacklist.id.similar.path <- list.files(
        path = dup.genome.folder,
        pattern = "blacklist.id.similar",
        full.names = TRUE)
      if (length(blacklist.id.similar.path) > 0) {
        blacklist.id.similar <- suppressMessages(
          readr::read_tsv(
            file = blacklist.id.similar.path,
            col_names = TRUE,
            col_types = readr::cols(.default = readr::col_character())))
        n.ind.blacklisted <- length(blacklist.id.similar$INDIVIDUALS)
        if (n.ind.blacklisted > 0) {
          if (verbose) message("Blacklisted individuals: ", n.ind.blacklisted, " ind.")
          if (verbose) message("    Filtering with blacklist of individuals")
          input <- dplyr::filter(input, !INDIVIDUALS %in% blacklist.id.similar$INDIVIDUALS)
          res$blacklist.id <- res$blacklist.id %>% dplyr::bind_rows(blacklist.id.similar)
          blacklist.id.similar <- NULL

          # updating parameters
          filters.parameters <- tibble::data_frame(
            FILTERS = "detect duplicate genomes",
            PARAMETERS = "",
            VALUES = "",
            BEFORE = data.info$n.ind,
            AFTER = data.info$n.ind - n.ind.blacklisted,
            BLACKLIST = n.ind.blacklisted,
            UNITS = "individuals",
            COMMENTS = ""
          ) %>%
            readr::write_tsv(
              x = ., path = filters.parameters.path,
              append = TRUE, col_names = FALSE)
          # update data.info
          data.info$n.ind <- data.info$n.ind - n.ind.blacklisted

          # After removing individuals => check for monomorphic markers
          message("\nScan and remove monomorphic markers, again...")
          input <- discard_monomorphic_markers(data = input, verbose = verbose)
          blacklist.monomorphic.markers <- input$blacklist.monomorphic.markers
          whitelist.markers <- input$whitelist.polymorphic.markers
          input <- input$input
          if (nrow(blacklist.monomorphic.markers) > 0) {
            readr::write_tsv(
              x = blacklist.monomorphic.markers,
              path = file.path(dup.genome.folder, "blacklist.monomorphic.markers.tsv"))
            if (verbose) message("File written: blacklist.monomorphic.markers.tsv")

            new.data.info <- data_info(input)

            # updating parameters
            filters.parameters <- tibble::data_frame(
              FILTERS = "removing monomorphic markers",
              PARAMETERS = "",
              VALUES = "",
              BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
              AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
              BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
              UNITS = "CHROM/LOCUS/SNP",
              COMMENTS = ""
            ) %>%
              readr::write_tsv(
                x = .,
                path = filters.parameters.path, append = TRUE,
                col_names = FALSE)
            # update data.info
            data.info <- new.data.info
            if (!is.null(blacklist.markers)) {
              blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.monomorphic.markers)
            } else {
              blacklist.markers <- blacklist.monomorphic.markers
            }
          }
        }
      }
    }
    # Write the file
    path.dup.genomes <- list.files(path = path.folder, pattern = "09_detect_duplicate_genomes", full.names = TRUE)
    radiator::write_rad(data = input, path = file.path(path.dup.genomes, "tidy.data.dup.gen.rad"))
    message("File written: tidy.data.dup.gen.rad")
    path.dup.genomes <- NULL

    duplicate.genomes <- blacklist.monomorphic.markers <- NULL
  }#End duplicate.genomes.analysis

  #10.Filter HWE -----------------------------------------------------------------
  if (interactive.filter || hw.pop.threshold) {
    if (verbose) cat("\n### 10: Filter markers HWE ############################################\n")
    # message to do HW filtering or not
    hw.q <- "Do you want to filter you markers based on HW principles ?\nYou can still opt out after looking at the figures. (y/n): \n"
    do.hw <- interactive_question(x = hw.q, answer.opt = c("y", "n"))

    if (do.hw == "y") {
      input <- filter_hwe(
        interactive.filter = interactive.filter,
        data = input, strata = NULL,
        hw.pop.threshold = hw.pop.threshold,
        midp.threshold = midp.threshold,
        parallel.core = parallel.core,
        verbose = FALSE)
      hw.pop.threshold <- input$hw.pop.threshold
      midp.threshold <- input$midp.threshold
      input <- input$tidy.hw.filtered

      old.folder <- list.files(path = path.folder, pattern = "filter_hwe")
      new.folder <- stringi::stri_join("10_", old.folder)
      file.rename(from = old.folder, to = new.folder)

      #update filter parameter file
      n.snp.before <- data.info$n.snp
      new.data.info <- data_info(input)

      # updating parameters
      filters.parameters <- list.files(path = path.folder, pattern = "filters_parameters", full.names = TRUE) %>%
        readr::read_tsv(file = ., col_types = readr::cols(.default = readr::col_character()))

      filters.parameters <- filters.parameters %>%
        dplyr::filter(FILTERS != "HWE") %>%
        dplyr::bind_rows(
          filters.parameters %>%
            dplyr::filter(FILTERS == "HWE", VALUES == stringi::stri_join(hw.pop.threshold,"/",midp.threshold)) %>%
            dplyr::distinct(FILTERS, .keep_all = TRUE)) %>%
        readr::write_tsv(
          x = .,
          path = filters.parameters.path, append = FALSE,
          col_names = TRUE)
      # update data.info
      data.info <- new.data.info

      bl.name <- stringi::stri_join("blacklist.markers.hwd.", midp.threshold,".mid.p.value.", hw.pop.threshold,".hw.pop.threshold")

      if (length(bl.name) > 0) {
        blacklist.hw <- list.files(
          path = path.folder,
          pattern = bl.name,
          full.names = TRUE, recursive = TRUE, include.dirs = TRUE) %>%
          readr::read_tsv(file = ., col_types = "cccc")

        wt.name <- stringi::stri_join("whitelist.markers.hwe.", midp.threshold,".mid.p.value.", hw.pop.threshold,".hw.pop.threshold")
        whitelist.markers <- list.files(
          path = path.folder,
          pattern = wt.name,
          full.names = TRUE, recursive = TRUE, include.dirs = TRUE) %>%
          readr::read_tsv(file = ., col_types = "cccc")

        if (!is.null(blacklist.markers) && nrow(blacklist.hw) > 0) {
          blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.hw)
        } else {
          blacklist.markers <- blacklist.snp.number.markers
        }
        blacklist.hw <- NULL
      }
      if (verbose) message("    Number of markers before = ", n.snp.before)
      if (verbose) message("    Number of markers removed = ", n.snp.before - new.data.info$n.snp)
      if (verbose) message("    Number of markers after = ", new.data.info$n.snp)
    } else {
      hw.pop.threshold <- input$hw.pop.threshold
      midp.threshold <- input$midp.threshold
      input <- input$tidy.hw.filtered
    }
  }#End HW


  # Missing visualization analysis before filters------------------------------
  # if (missing.analysis) {
  #   if (verbose) message("Missing data analysis: after filters")
  #   missing.visualization <- grur::missing_visualization(data = input, write.plot = TRUE)
  # }


  # Writing to working directory the filtered data frame -----------------------
  if (verbose) cat("\n#######################################################################\n")
  # reintroduce REF/ALT
  if (verbose) message("Working to prepare files...")
  markers.meta <- list.files(path = path.folder, pattern = "metadata", full.names = TRUE)

  if (length(markers.meta) > 1) {
    markers.meta <- file.info(markers.meta) %>%
      tibble::rownames_to_column(df = ., var = "FILE") %>%
      dplyr::filter(mtime == max(mtime))
    markers.meta <- markers.meta$FILE

    input <- dplyr::left_join(
      input,
      radiator:: read_rad(markers.meta, columns = c("MARKERS", "REF", "ALT")),
      by = "MARKERS")
    markers.meta <- NULL
  }

  # check REF/ALT alleles + new GT coding
  input <- radiator::change_alleles(
    data = input,
    biallelic = TRUE,
    parallel.core = parallel.core, verbose = TRUE)$input

  # re-introduce all the metadata

  if (count.data) {
    markers.meta <- list.files(path = path.folder, pattern = "temp_markers_coverage_info", full.names = TRUE)

    if (length(markers.meta) > 1) {
      markers.meta <- file.info(markers.meta) %>%
        tibble::rownames_to_column(df = ., var = "FILE") %>%
        dplyr::filter(mtime == max(mtime))
      markers.meta <- markers.meta$FILE
    }

    input <- dplyr::left_join(
      input,
      radiator:: read_rad(data = markers.meta),
      by = c("MARKERS", "INDIVIDUALS")
    )
    file.remove(markers.meta)
    markers.meta <- NULL
  }

  # Whitelist
  res$whitelist.markers <- dplyr::distinct(input, MARKERS, .keep_all = TRUE) %>%
    readr::write_tsv(x = ., path = "whitelist.markers.tsv", col_names = TRUE)
  if (verbose) message("Writing the whitelist of markers: whitelist.markers.tsv")

  if (nrow(blacklist.markers) > 0) {
    res$blacklist.markers <- dplyr::distinct(blacklist.markers, MARKERS) %>%
      readr::write_tsv(x = ., path = "blacklist.markers.tsv", col_names = TRUE)
    if (verbose) message("Writing the blacklist of markers: blacklist.markers.tsv")
  }

  # writing the blacklist of id
  blacklist.id <- NULL
  if (nrow(res$blacklist.id) > 0) {
    readr::write_tsv(x = res$blacklist.id, path = "blacklist.id.tsv", col_names = TRUE)
    if (verbose) message("Writing the blacklist of ids: blacklist.id.tsv")
  }

  # missing memory
  if (verbose) message("Memorizing missing genotypes")
  memory.filename <- stringi::stri_join(filename, "_filtered_missing_memory.rad")
  dplyr::select(
    input, MARKERS, INDIVIDUALS, GT_BIN) %>%
    dplyr::mutate(GT_BIN = is.na(GT_BIN)) %>%
    dplyr::rename(ERASE = GT_BIN) %>%
    dplyr::arrange(MARKERS, INDIVIDUALS) %>%
    radiator::write_rad(data = ., path = memory.filename)
  if (verbose) message("File written: ", memory.filename)

  # Import back the filter parameter file
  res$filters.parameters <- readr::read_tsv(file = filters.parameters.path, col_types = "cccccccc")

  # tidy data
  want <- c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "INDIVIDUALS",
            "POP_ID", "CALL_RATE", "REP_AVG",
            "AVG_COUNT_REF", "AVG_COUNT_SNP",
            "READ_DEPTH", "ALLELE_REF_DEPTH", "ALLELE_ALT_DEPTH",
            "GT", "GT_VCF", "GT_VCF_NUC", "GT_BIN")
  tidy.name <- stringi::stri_join(filename, "_filtered.rad")
  input <- suppressWarnings(
    dplyr::select(input, dplyr::one_of(want)) %>%
      dplyr::arrange(MARKERS, POP_ID, INDIVIDUALS) %>%
      write_rad(data = ., path = tidy.name)
  )
  message("Filtered tidy data written: ", tidy.name)

  # Generate new strata --------------------------------------------------------
  res$strata <-input %>%
    dplyr::distinct(INDIVIDUALS, POP_ID) %>%
    dplyr::rename(STRATA = POP_ID) %>%
    readr::write_tsv(x = ., path = "new_filtered_strata.tsv")

  # genomic_converter & Imputations --------------------------------------------
  if (!is.null(output)) {
    if (verbose) message("\nData transferred to genomic converter")
    res$output <- radiator::genomic_converter(
      data = input,
      output = output,
      snp.ld = NULL,
      imputation.method = imputation.method,
      hierarchical.levels = hierarchical.levels,
      num.tree = num.tree,
      parallel.core = parallel.core,
      filename = tidy.name,
      verbose = verbose,
      write.tidy = FALSE)
    last.data.info <- data_info(res$output$tidy.data)
    input <- NULL
  } else {
    last.data.info <- data_info(input)
    res$tidy.data <- input
    input <- NULL
  }

  if (verbose) {

    cat("\n\n\n############################### RESULTS ###############################\n")
    message("data info (before -> after) filters: ")
    message("Number of populations: ", first.data.info$n.pop, " -> ", last.data.info$n.pop)
    message("Number of individuals: ", first.data.info$n.ind, " -> ", last.data.info$n.ind)
    message("Number of chrom: ", first.data.info$n.chrom, " -> ", last.data.info$n.chrom)
    message("Number of locus: ", first.data.info$n.locus, " -> ", last.data.info$n.locus)
    message("Number of SNPs: ", first.data.info$n.snp, " -> ", last.data.info$n.snp)
    timing <- proc.time() - timing
    message("\nComputation time, overall: ", round(timing[[3]]), " sec")
    cat("############################ completed ################################\n")
  }
  setwd(working.dir) #back to the original working directory
  options(width = opt.change)
  return(res)
}#End filter_rad
