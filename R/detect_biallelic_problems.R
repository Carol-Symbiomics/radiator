# Detect the number of alleles/nucleotides per bi-allelic markers

#' @name detect_biallelic_problems

#' @title Detect biallelic problems

#' @description Detect the number of alleles/nucleotides per markers.
#' Sometimes, a dataset might have 3 alleles at a SNP, is this biological or artifactual ?
#' This function helps to resolve this, by highlighting markers with this potential
#' problem, so that user can further look at the origin of the phenomenon.
#' The function can also split datasets in biallelic/multiallelic datasets.

#' @param data A tidy data frame object in the global environment or
#' a tidy data frame in wide or long format in the working directory.
#' The tidy dataset needs a column with nucleotide information \code{GT_VCF_NUC},
#' usually this is automatically generated by \pkg{radiator}.
#' \emph{How to get a tidy data frame ?}
#' Look into \pkg{radiator} \code{\link{tidy_genomic_data}}.

#' @param verbose (optional, logical) \code{verbose = TRUE} to be chatty
#' during execution.
#' Default: \code{verbose = TRUE}.

#' @param parallel.core (optional) The number of core used for parallel
#' execution.
#' Default: \code{parallel.core = parallel::detectCores() - 1}.


#' @return Several info

#' @export
#' @rdname detect_biallelic_problems
#' @importFrom dplyr select mutate group_by ungroup rename tally filter
#' @importFrom stringi stri_replace_all_fixed stri_sub
#' @importFrom tibble has_name
#' @importFrom tidyr gather
#' @importFrom purrr flatten_chr

#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com}

detect_biallelic_problems <- function(data, verbose = TRUE, parallel.core = parallel::detectCores() - 1) {
  if (verbose) cat("#######################################################################\n")
  if (verbose) cat("################# radiator::detect_biallelic_problems #################\n")
  if (verbose) cat("#######################################################################\n")
  timing <- proc.time()
  opt.change <- getOption("width")
  options(width = 70)
  # Checking for missing and/or default arguments ------------------------------
  if (missing(data)) stop("Input file missing")
  res <- list()
  # Get data and time and generate a filename
  # in case problematic markers are found and printed
  date.time <- format(Sys.time(), "%Y%m%d@%H%M")
  # filename <- stringi::stri_join("radiator_biallelic_problem_", format(Sys.time(), "%Y%m%d@%H%M"), ".tsv")

  # Import data ---------------------------------------------------------------
  if (is.vector(data)) {
    data <- radiator::tidy_wide(data = data, import.metadata = TRUE)
  }
  if (!tibble::has_name(data, "GT_VCF_NUC")) stop("Tidy dataset requires nuclotides in genotypes: GT_VCF_NUC")

  # Check data ----------------------------------------------------------
  message("Generating statistics...")
  # want <- c("MARKERS", "CHROM", "LOCUS", "POS", "POP_ID", "GT_VCF_NUC",
            # "AVG_COUNT_REF", "AVG_COUNT_SNP", "ALLELE_REF_DEPTH",
            # "ALLELE_ALT_DEPTH")
  # data <- suppressWarnings(dplyr::select(data, dplyr::one_of(want)))
  markers.metadata <- purrr::keep(
    .x = colnames(data),
    .p = colnames(data) %in% c("MARKERS", "CHROM", "LOCUS", "POS"))
  want <- c("MARKERS", "CHROM", "LOCUS", "POS", "GT_VCF_NUC")
  blacklist.markers <- dplyr::select(data, dplyr::one_of(want)) %>%
    dplyr::filter(GT_VCF_NUC != "./.") %>%
    dplyr::distinct(MARKERS, GT_VCF_NUC, .keep_all = TRUE) %>%
    separate_gt(x = ., exclude = markers.metadata, parallel.core = parallel.core) %>%
    dplyr::distinct(MARKERS, HAPLOTYPES, .keep_all = TRUE) %>%
    dplyr::group_by_at(dplyr::vars(markers.metadata)) %>%
    dplyr::tally(.) %>%
    dplyr::filter(n > 2) %>%
    dplyr::rename(N_ALLELES = n)

  if (nrow(blacklist.markers) == 0) {
    message("No markers to blacklist")
    res$blacklist.markers <- "No markers blacklisted"
    res$blacklist.info <- "No markers blacklisted"
    res$biallelic.data <- data
    res$multiallelic.data <- NULL
  } else {
    # write the blacklist
    blacklist.filename <- stringi::stri_join("blacklist.markers.not.biallelic_", date.time, ".tsv")
    readr::write_tsv(x = blacklist.markers, path = blacklist.filename)

    res$blacklist.markers <- blacklist.markers


    exclude.vars <- purrr::keep(
      .x = colnames(data),
      .p = !colnames(data) %in% "GT_VCF_NUC")

    group.vars <- purrr::keep(
      .x = colnames(data),
      .p = colnames(data) %in% c("MARKERS", "CHROM", "LOCUS", "POS", "POP_ID"))

    # Generating biallelic/multiallelic datasets -------------------------------
    res$multiallelic.data <- dplyr::filter(data, MARKERS %in% blacklist.markers$MARKERS)
    res$biallelic.data <- dplyr::filter(data, !MARKERS %in% blacklist.markers$MARKERS)

    data <- NULL # no longer required

    # Blacklist additionnal info -----------------------------------------------
    blacklist.info <- dplyr::filter(res$multiallelic.data, GT_VCF_NUC != "./.") %>%
      separate_gt(x = ., exclude = exclude.vars, parallel.core = parallel.core) %>%
      dplyr::rename(ALLELES = HAPLOTYPES) %>%
      dplyr::select(-ALLELE_GROUP) %>%
      dplyr::group_by_at(dplyr::vars(c(group.vars, "ALLELES"))) %>%
      dplyr::summarise(N = n()) %>%
      dplyr::ungroup(.) %>%
      dplyr::group_by_at(dplyr::vars(c(markers.metadata, "ALLELES"))) %>%
      dplyr::mutate(REF = sum(N)) %>%
      dplyr::ungroup(.) %>%
      dplyr::arrange(MARKERS, ALLELES)

    markers.low.mac <- blacklist.info %>%
      dplyr::group_by_at(dplyr::vars(markers.metadata)) %>%
      dplyr::filter(REF == min(REF)) %>%
      dplyr::distinct(MARKERS, REF, .keep_all = TRUE) %>%
      dplyr::filter(REF <=1) %>%
      dplyr::ungroup(.) %>%
      nrow

    blacklist.info.filename <- stringi::stri_join("blacklist.markers.not.biallelic.info_", date.time, ".tsv")
    blacklist.info <- blacklist.info %>%
      dplyr::group_by_at(dplyr::vars(markers.metadata)) %>%
      dplyr::mutate(REF = dplyr::if_else(REF == max(REF), "REF", "ALT")) %>%
      dplyr::ungroup(.) %>%
      dplyr::group_by_at(dplyr::vars(c(markers.metadata, "ALLELES", "REF"))) %>%
      tidyr::spread(data = ., key = POP_ID, value = N) %>%
      readr::write_tsv(x = ., path = blacklist.info.filename, na = "-")
    res$blacklist.info <- blacklist.info
    dodgy.markers <- dplyr::n_distinct(blacklist.info$MARKERS)
    message("\nNumber of suspicious markers (> 2 alleles): ", dodgy.markers)
    message("Number of suspicious markers with 1 count for the ALT allele: ", markers.low.mac)
    message("Number of suspicious markers after low count removed: ", dodgy.markers - markers.low.mac)

    message("\nblacklist of markers with > 2 alleles:")
    message("    ", blacklist.filename)
    message("\nblacklist with more info:")
    message("    ", blacklist.info.filename)

    message("\nBiallelic and multiallelic tidy datasets objects generated")

    # if (tibble::has_name(data, "AVG_COUNT_REF")) {
    #   data3 <- data %>%
    #     dplyr::filter(MARKERS %in% blacklist.markers$MARKERS) %>%
    #     dplyr::group_by(MARKERS, GT_VCF_NUC) %>%
    #     dplyr::summarise(
    #       NUMBER_SAMPLES = n(),
    #       AVG_COUNT_REF = mean(AVG_COUNT_REF),
    #       AVG_COUNT_SNP = mean(AVG_COUNT_SNP)) %>%
    #     dplyr::arrange(MARKERS, dplyr::desc(NUMBER_SAMPLES))
    # } else if (tibble::has_name(data, "ALLELE_REF_DEPTH")) {
    #   data3 <- data %>%
    #     dplyr::filter(MARKERS %in% blacklist.markers$MARKERS) %>%
    #     dplyr::group_by(MARKERS, GT_VCF_NUC) %>%
    #     dplyr::summarise(NUMBER_SAMPLES = n()) %>%
    #     dplyr::arrange(MARKERS, dplyr::desc(NUMBER_SAMPLES))
    # } else {
    #   data3 <- data %>%
    #     dplyr::filter(MARKERS %in% blacklist.markers$MARKERS) %>%
    #     dplyr::group_by(MARKERS, GT_VCF_NUC) %>%
    #     dplyr::summarise(NUMBER_SAMPLES = n()) %>%
    #     dplyr::arrange(MARKERS, dplyr::desc(NUMBER_SAMPLES))
    # }
  }
  timing <- proc.time() - timing
  if (verbose) message("\nComputation time: ", round(timing[[3]]), " sec")
  if (verbose) cat("############################## completed ##############################\n")
  options(width = opt.change)
  return(res)
}#End detect_biallelic_problems
