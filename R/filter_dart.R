# Import, filter and transform a dart output file to different formats

#' @name filter_dart

#' @title Swiss Army knife tool to prepare \href{http://www.diversityarrays.com}{DArT}
#' output file for population genetics analysis.

#' @description Import, filter and generate imputed datasets of DArT output file.
#' The function uses \code{\link[radiator]{tidy_dart}} to import and tidy DArT input file.
#' Currently 3 formats are recognized: 1- and 2- row format (also called binary),
#' and count data.


#' @param interactive.filter (optional, logical) Do you want the filtering session to
#' be interactive. The user is asked to see figures of distribution before
#' making decisions for filtering.
#' Default: \code{interactive.filter = TRUE}.

#' @inheritParams tidy_dart
#' @inheritParams genomic_converter
#' @inheritParams tidy_genomic_data


#' @param strata A tab delimited file or object with 3 columns.
#' Columns header is:
#' \code{TARGET_ID}, \code{INDIVIDUALS} and \code{STRATA}.
#' Note: the column \code{STRATA} refers to any grouping of individuals.
#' You need to make sure that
#' the column \code{TARGET_ID} match the id used by DArT.
#' The column \code{INDIVIDUALS} and \code{STRATA} will be kept in the tidy data.
#' Only individuals in the strata file are kept in the tidy, i.e. that the strata
#' is also used as a whitelist of individuals/strata.


#' @param filter.reproducibility (optional, numerical) Filter the \code{RepAvg}
#' column in the data set. For DArT this is the proportion of technical
#' replicate assay pairs for which the marker score is consistent.
#' Default: \code{filter.reproducibility = NULL}.
#' e.g to keep markers with reproducibility >= 99%,
#' use: \code{filter.reproducibility = 0.99}.

#' @param filter.call.rate (optional, numerical) Filter the \code{CallRate}
#' column in the data set. For DArT this is the proportion of samples for
#' which the genotype was called. Default: \code{filter.call.rate = NULL}. e.g to keep
#' markers genotyped in more than 95% of the individuals use :
#' \code{filter.call.rate = 0.95}

#' @param filter.markers.coverage (optional, string, numerical) Filter the lower and
#' upper bound of locus/read coverage. The locus/read coverage combines the markers
#' average count for REF and ALT allele (respectively the \code{AvgCountRef} and
#' \code{AvgCountSnp} info). These markers statistics are generated by DArT.
#' If you have count data, use \code{erase.genotypes} argument below instead.
#' Default: \code{filter.markers.coverage = NULL}.
#' e.g to keep markers with coverage inbetween 7 and 200,
#' use : \code{filter.markers.coverage = c(7, 200)}.

#' @param erase.genotypes (optional, string, numerical) DArT file with count
#' data is required for this argument to work. With count data, genotype,
#' REF and ALT coverage information is available and is better suited than
#' \code{filter.markers.coverage} to remove/erase data based on coverage info.
#' This function argument requires 3 values in the string:
#' \enumerate{
#' \item threshold.low.coverage: threshold for the minimum read coverage. Under this threshold,
#' genotypes are erased. e.g. 7
#' \item threshold.gl: threshold that applies only for heterozygous genotypes.
#' Using the \code{threshold.low.coverage} doesn't guarantees that REF and ALT
#' allele have adequate coverage. This threshold does.
#' A genotype likelihood value is generated based
#' on the departure of equal coverage between REF and ALT allele, number of samples
#' sharing the heterozygous genotype for the locus, missing data for the locus
#' and individual. Below the genotype likelihood threshold value,
#' the heterozygous genotypes are erased. e.g. if an heterozygous genotype for a
#' marker as REF/ALT coverage of 100/3 with only 1 sample sharing this info and
#' this sample has 50% missing data and the marker missingness is averaged, the
#' GL value will be extremely low compared to another heterozygous genotype with
#' 50/50 of coverage and 10 samples sharing the same genotype...
#' \item threshold.high.coverage: threshold that allows to erase genotypes with
#' very high coverage
#' }
#' e.g. of values: \code{erase.genotypes = c(7, -0.25, 200)}.
#' However, using the \code{interactive.filter = TRUE} is highly recommended to
#' visualize data before choosing values.
#' Default: \code{erase.genotypes = NULL}.

#' @param filter.individuals.missing (optional, double) New argument to blacklist
#' individuals with too many missing genotypes. Below the threshold, individuals
#' are blacklisted. e.g. 0.80 will blacklist individuals with more than 20% missing
#' genotypes.
#' Default: \code{filter.individuals.missing = NULL}.


#' @param filter.markers.missing (optional, string) Similar to call rate, but
#' more adapted to the data. 3 values are required in the string, corresponding
#' to the \code{\link[radiator]{filter_individual}} module of radiator.
#' First value is the approach to count genotyped individuals per markers, \code{"overall"}
#' or by \code{"pop"}. Second value is the percent threshold for the marker, with
#' \code{70}, 70 percent of genotyped individuals are required to keep the marker.
#' The last threshold is the number of problematic population that are allowed to skip
#' the threshold. In doubt, use the interactive mode that take step by step these
#' arguments. e.g to keep individuals genotyped at >= 70 percent for the markers,
#' without considering the population info and allowing 1 population to be problematic for the
#' threshold, use: \code{c("overall", 70, 1)}.
#' Default: \code{filter.markers.missing = NULL}.


#' @param number.snp.reads (optional, integer) This filter removes outlier markers
#' with too many SNP number per locus/read.
#' Having a higher than "normal" SNP number is usually the results of
#' assembly artifacts or bad assembly parameters.
#' This filter is population-agnostic. This is best decide after viewing the figures,
#' with the interactive mode.
#' If the argument is set to \code{number.snp.reads = 2},
#' locus with 3 and more SNPs will be blacklisted.
#' Default: \code{number.snp.reads = NULL}.

#' @param mixed.genomes.analysis (optional, logical) Highlight outliers individual's
#' observed heterozygosity for a quick
#' diagnostic of mixed samples or poor polymorphism discovery due to DNA quality,
#' sequencing effort, etc.
#' See this function for more info: \code{\link[radiator]{detect_mixed_genomes}}.
#' Default: \code{detect_mixed_genomes = TRUE}.

#' @inheritParams detect_mixed_genomes

#' @param duplicate.genomes.analysis (optional, string) Detect duplicate individuals.
#' The function can compute two methods (distance or genome pairwise similarity)
#' to highligh potential duplicate individuals.
#' See this function for more info: \code{\link[radiator]{detect_duplicate_genomes}}.
#' The string required to run the analysis as 2 values:
#' \enumerate{
#' \item TRUE/FALSE to run the analysis;
#' \item Computes pairwise genome similarity (TRUE/FALSE),
#' with FALSE just the distance measure is used.
#' The pairwise genome similarity is longer to run, but is better because it
#' integrates markers in common/missing data.
#' Using \code{interactive.filter = TRUE}, can overide this value,
#' you can opt in for the pairwise genome similarity after viewing the figures
#' used with distance measure... handy!
#' }
#' Default: \code{detect_duplicate_genomes = c(TRUE, FALSE)}.


#' @param filename (optional) The filename prefix for the objet in the global environment
#' or the working directory. Default: \code{filename = NULL}. A default name will be used,
#' customized with the output file(s) selected.

#' @param ... (optional) To pass further argument for fine-tuning the function.


#' @return The function returns an object (list). The content of the object
#' can be listed with \code{names(object)} and use \code{$} to isolate specific
#' object (see examples). Some output format will write the output file in the
#' working directory. The tidy genomic data frame is generated automatically.

#' @export
#' @rdname filter_dart
#' @importFrom dplyr group_by select rename filter mutate summarise distinct n_distinct arrange left_join semi_join anti_join inner_join full_join tally bind_rows
#' @importFrom parallel detectCores
#' @importFrom stringi stri_replace_all_fixed stri_join stri_sub stri_replace_na stri_pad_left
#' @importFrom purrr discard
#' @importFrom readr read_tsv write_tsv
#' @importFrom tibble as_data_frame data_frame
#' @importFrom tidyr spread gather unite separate
#' @importFrom stats IQR

#' @examples
#' \dontrun{
#' testing
#' }

#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com} and Peter Grewe \email{peter.grewe@csiro.au}

filter_dart <- function(
  interactive.filter = TRUE,
  data,
  strata,
  output = NULL,
  pop.levels = NULL,
  blacklist.id = NULL,
  pop.select = NULL,
  monomorphic.out = TRUE,
  common.markers = TRUE,
  filter.reproducibility = NULL,
  filter.call.rate = NULL,
  filter.markers.coverage = NULL,
  erase.genotypes = NULL,
  filter.individuals.missing = NULL,
  filter.markers.missing = NULL,
  maf.thresholds = NULL,
  number.snp.reads = NULL,
  mixed.genomes.analysis = TRUE,
  ind.heterozygosity.threshold = NULL,
  duplicate.genomes.analysis = c(TRUE, FALSE),
  snp.ld = NULL,
  imputation.method = NULL,
  hierarchical.levels = "populations",
  num.tree = 50,
  filename = NULL,
  verbose = TRUE,
  parallel.core = parallel::detectCores() - 1,
  ...
) {
  if (verbose) {
    cat("#######################################################################\n")
    cat("######################## radiator::filter_dart ########################\n")
    cat("#######################################################################\n")
  }
  opt.change <- getOption("width")
  options(width = 70)
  timing <- proc.time()# for timing
  res <- list()

  # dotslist -------------------------------------------------------------------
  dotslist <- list(...)
  want <- c("filter.coverage", "filter.ind.missing.geno")
  unknowned_param <- setdiff(names(dotslist), want)

  if (length(unknowned_param) > 0) {
    stop("Unknowned \"...\" parameters ",
         stringi::stri_join(unknowned_param, collapse = " "))
  }

  radiator.dots <- dotslist[names(dotslist) %in% want]
  filter.coverage <- radiator.dots[["filter.coverage"]]
  filter.ind.missing.geno <- radiator.dots[["filter.ind.missing.geno"]]

  if (!is.null(filter.coverage) && !is.null(filter.ind.missing.geno)) {
    stop("
filter.coverage is deprecated in favour of: filter.markers.coverage
filter.ind.missing.geno is deprecated in favour of: filter.markers.missing")
  }

  if (!is.null(filter.coverage)) {
    stop("
filter.coverage is deprecated in favour of: filter.markers.coverage")
  }

  if (!is.null(filter.ind.missing.geno)) {
    stop("
filter.ind.missing.geno is deprecated in favour of: filter.markers.missing")
  }


  # Checking for missing and/or default arguments ------------------------------
  if (missing(data)) stop("Input file missing")
  if (missing(output)) stop("At least 1 output format is required")

  # Filename -------------------------------------------------------------------
  file.date <- format(Sys.time(), "%Y%m%d@%H%M")

  if (is.null(filename)) {
    folder.extension <- filename <- stringi::stri_join("filter_dart_", file.date)

    # if (!is.null(imputation.method)) {
    #   filename.imp <- stringi::stri_join("filter_dart_imputed_", file.date)
    # }
  } else {
    # if (!is.null(imputation.method)) {
    #   filename.imp <- stringi::stri_join(filename, "imputed", file.date, sep = "_")
    # }
    folder.extension <- stringi::stri_join("filter_dart", filename, file.date, sep = "_")
    filename <- stringi::stri_join(filename, file.date, sep = "_")
  }

  working.dir <- getwd()
  path.folder <- stringi::stri_join(working.dir,"/", folder.extension, sep = "")
  dir.create(file.path(path.folder))

  message("\nFolder created: \n", folder.extension)
  filename <- file.path(path.folder, filename)

  # File type ------------------------------------------------------------------
  data.type <- radiator::detect_genomic_format(data)

  if (data.type == "dart") {
    # Check that DArT file as good target id written
    target.id <- extract_dart_target_id(data, write = FALSE)
    if (nrow(target.id) != length(unique(target.id$TARGET_ID))) {
      stop("non unique target id are used in the DArT file...
           What you want are different target ids at the end of the row that contains AlleleID, AlleleSequence, etc
           Edit manually before trying again
           If you're still encountering problem, email author for help")
    }
    target.id <- NULL
  }

  if (data.type == "fst.file") {
    message("Importing tidy DArT data...")
    input <- radiator::read_rad(data)
  }

  # Filter parameter file ------------------------------------------------------
  filters.parameters <- tibble::data_frame(
    FILTERS = as.character(),
    PARAMETERS = as.character(),
    VALUES = as.integer(),
    BEFORE = as.character(),
    AFTER = as.character(),
    BLACKLIST = as.integer(),
    UNITS = as.character(),
    COMMENTS = as.character())
  filters.parameters.path <- stringi::stri_join(
    path.folder, "/filters_parameters_dart.tsv")
  readr::write_tsv(x = filters.parameters,
                   path = filters.parameters.path,
                   append = FALSE,
                   col_names = TRUE)
  message("Generated a filters parameters file: filters_parameters_dart.tsv")

  # Markers meta----------------------------------------------------------------
  message("Importing markers metadata")
  metadata <- radiator::tidy_dart_metadata(
    data = data,
    filename = filename,
    parallel.core = parallel.core,
    verbose = TRUE)

  metadata.file <- list.files(path = path.folder, pattern = "metadata")

  # create 2 data.info
  data.info <- first.data.info <- data_info(metadata, print.info = FALSE)

  # Filtering reproducibility  -------------------------------------------------
  if (interactive.filter || !is.null(filter.reproducibility)) {
    message("Filtering reproducibility")

    folder.extension <- stringi::stri_join("filter_reproducibility_dart_", file.date, sep = "")
    path.folder.reproducibility <- file.path(path.folder, folder.extension)
    dir.create(path.folder.reproducibility)
    message("Folder created: \n", folder.extension)

    want <- c("MARKERS", "CHROM", "LOCUS", "POS", "REP_AVG")
    reproducibility <- dplyr::select(metadata, dplyr::one_of(want)) %>%
      dplyr::mutate(Markers = rep("markers", n()))

    plot.reproducibility.violinplot <- ggplot2::ggplot(
      reproducibility, ggplot2::aes(x = Markers, y = REP_AVG, na.rm = TRUE)) +
      ggplot2::geom_violin(trim = TRUE) +
      ggplot2::geom_boxplot(width = 0.1, fill = "black", outlier.colour = NA) +
      ggplot2::stat_summary(fun.y = "mean", geom = "point", shape = 21,
                            size = 2.5, fill = "white") +
      ggplot2::labs(x = "Markers", y = "Markers reproducibility averaged") +
      ggplot2::theme(
        legend.position = "none",
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_blank()
      )
    # plot.reproducibility.violinplot
    ggplot2::ggsave(
      filename = file.path(path.folder.reproducibility, "plot.reproducibility.violinplot.pdf"),
      plot = plot.reproducibility.violinplot,
      width = 20, height = 15, dpi = 600, units = "cm", useDingbats = FALSE)

    plot.reproducibility.histo <- ggplot2::ggplot(
      data = reproducibility,
      ggplot2::aes(x = REP_AVG)) +
      ggplot2::geom_histogram() +
      ggplot2::labs(x = "Markers", y = "Markers reproducibility averaged") +
      ggplot2::theme(
        legend.position = "none",
        axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica", angle = 90, hjust = 1, vjust = 0.5),
        strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
      )
    # plot.reproducibility.histo
    suppressMessages(ggplot2::ggsave(
      filename = file.path(path.folder.reproducibility, "plot.reproducibility.histo.pdf"),
      plot = plot.reproducibility.histo,
      width = 20, height = 15, dpi = 600, units = "cm", useDingbats = FALSE))

    if (interactive.filter) {
      message("    Inspect plots in folder created to help choose reproducibility threshold...")
      message("    Enter the value (between 0 and 1) for filter.reproducibility threshold \n    (below threshold < markers are discarded): ")
      filter.reproducibility <- as.numeric(readLines(n = 1))
    }

    if (!is.null(filter.reproducibility)) {
      want <- c("MARKERS", "CHROM", "LOCUS", "POS")

      blacklist.reproducibility.markers <- reproducibility %>%
        dplyr::filter(REP_AVG < filter.reproducibility) %>%
        dplyr::select(dplyr::one_of(want)) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE)

      if (nrow(blacklist.reproducibility.markers) > 0) {
        n.snp.before <- data.info$n.snp
        if (verbose) message("    Number of markers before = ", n.snp.before)
        n.snp.blacklist <- nrow(blacklist.reproducibility.markers)
        if (verbose) message("    Number of markers removed = ", n.snp.blacklist)
        if (verbose) message("    Number of markers after = ", n.snp.before - n.snp.blacklist)
        # input <- dplyr::anti_join(input, blacklist.reproducibility.markers, by = "MARKERS")
        # whitelist.markers <- dplyr::select(input, dplyr::one_of(want)) %>%
        #   dplyr::distinct(MARKERS, .keep_all = TRUE)

        metadata <- metadata %>%
          dplyr::filter(!MARKERS %in% blacklist.reproducibility.markers$MARKERS)

        new.data.info <- data_info(metadata) # updating parameters

        filters.parameters <- tibble::data_frame(
          FILTERS = "reproducibility",
          PARAMETERS = "",
          VALUES = filter.reproducibility,
          BEFORE = stringi::stri_join(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
          AFTER = stringi::stri_join(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
          BLACKLIST = stringi::stri_join(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
          UNITS = "CHROM/LOCUS/SNP",
          COMMENTS = ""
        )
        readr::write_tsv(x = filters.parameters,
                         path = filters.parameters.path, append = TRUE,
                         col_names = FALSE)
        # update data.info
        data.info <- new.data.info

        blacklist.markers <- blacklist.reproducibility.markers
        whitelist.markers <- dplyr::select(metadata, MARKERS, CHROM, LOCUS, POS)

        # write blacklist and whitelist
        readr::write_tsv(x = blacklist.reproducibility.markers, path = file.path(path.folder.reproducibility, "blacklist.reproducibility.markers.tsv"))
        readr::write_tsv(x = whitelist.markers, path = file.path(path.folder.reproducibility, "whitelist.reproducibility.markers.tsv"))

      }
      blacklist.markers <- blacklist.reproducibility.markers <- NULL
      whitelist.markers <- dplyr::select(metadata, MARKERS, CHROM, LOCUS, POS)
    } else {
      stop("A filter.reproducibility threshold value is required...")
    }

    reproducibility <- plot.reproducibility.histo <- plot.reproducibility.violinplot <- NULL
  }#End filter.reproducibility

  # Filtering call rate ---------------------------------------------------------
  if (interactive.filter || !is.null(filter.call.rate)) {
    message("Filtering markers call rate")

    folder.extension <- stringi::stri_join("filter_call_rate_dart_", file.date, sep = "")
    path.folder.call.rate <- file.path(path.folder, folder.extension)
    dir.create(path.folder.call.rate)
    message("Folder created: \n", folder.extension)

    want <- c("MARKERS", "CHROM", "LOCUS", "POS", "CALL_RATE")
    call.rate <- dplyr::select(metadata, dplyr::one_of(want)) %>%
      dplyr::mutate(Markers = rep("markers", n()))

    plot.call.rate.violinplot <- ggplot2::ggplot(
      call.rate, ggplot2::aes(x = Markers, y = CALL_RATE, na.rm = TRUE)) +
      ggplot2::geom_violin(trim = TRUE) +
      ggplot2::geom_boxplot(width = 0.1, fill = "black", outlier.colour = NA) +
      ggplot2::stat_summary(fun.y = "mean", geom = "point", shape = 21, size = 2.5, fill = "white") +
      ggplot2::labs(x = "Markers") +
      ggplot2::labs(y = "Markers Call Rate (proportion)") +
      ggplot2::theme(
        legend.position = "none",
        # axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_blank()
        # axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica", angle = 90, hjust = 1, vjust = 0.5),
        # legend.title = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        # legend.text = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
        # strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
      ) #+ ggplot2::facet_grid(~POP_ID)
    # plot.call.rate.violinplot
    ggplot2::ggsave(
      filename = file.path(path.folder.call.rate, "plot.call.rate.violinplot.pdf"),
      plot = plot.call.rate.violinplot,
      width = 20, height = 15, dpi = 600, units = "cm", useDingbats = FALSE)

    plot.call.rate.histo <- ggplot2::ggplot(
      data = call.rate,
      ggplot2::aes(x = CALL_RATE)) +
      ggplot2::geom_histogram() +
      ggplot2::labs(x = "Markers") +
      ggplot2::labs(y = "Markers Call Rate (proportion)") +
      ggplot2::theme(
        legend.position = "none",
        axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica", angle = 90, hjust = 1, vjust = 0.5),
        strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
      )
    # plot.call.rate.histo
    suppressMessages(ggplot2::ggsave(
      filename = file.path(path.folder.call.rate, "plot.call.rate.histo.pdf"),
      plot = plot.call.rate.histo,
      width = 20, height = 15, dpi = 600, units = "cm", useDingbats = FALSE))

    if (interactive.filter) {
      message("    Inspect plots in folder created to help choose call rate threshold...")
      message("    Enter the value (between 0 and 1) for filter.call.rate threshold \n    (below threshold < markers are discarded): ")
      filter.call.rate <- as.numeric(readLines(n = 1))
    }

    if (!is.null(filter.call.rate)) {
      want <- c("MARKERS", "CHROM", "LOCUS", "POS")
      blacklist.call.rate.markers <- call.rate %>%
        dplyr::filter(CALL_RATE < filter.call.rate) %>%
        dplyr::select(dplyr::one_of(want)) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE)

      if (nrow(blacklist.call.rate.markers) > 0) {
        n.snp.before <- data.info$n.snp
        if (verbose) message("    Number of markers before = ", n.snp.before)
        n.snp.blacklist <- nrow(blacklist.call.rate.markers)
        if (verbose) message("    Number of markers removed = ", n.snp.blacklist)
        if (verbose) message("    Number of markers after = ", n.snp.before - n.snp.blacklist)

        # input <- dplyr::anti_join(input, blacklist.call.rate.markers, by = "MARKERS")

        metadata <- metadata %>%
          dplyr::filter(!MARKERS %in% blacklist.call.rate.markers$MARKERS)

        new.data.info <- data_info(metadata) # updating parameters
        filters.parameters <- tibble::data_frame(
          FILTERS = "call rate",
          PARAMETERS = "",
          VALUES = filter.call.rate,
          BEFORE = stringi::stri_join(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
          AFTER = stringi::stri_join(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
          BLACKLIST = stringi::stri_join(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
          UNITS = "CHROM/LOCUS/SNP",
          COMMENTS = ""
        )
        readr::write_tsv(x = filters.parameters,
                         path = filters.parameters.path, append = TRUE,
                         col_names = FALSE)
        # update data.info
        data.info <- new.data.info

        if (!is.null(blacklist.markers)) {
          blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.call.rate.markers)
        } else {
          blacklist.markers <- blacklist.call.rate.markers
        }

        whitelist.markers <- dplyr::select(metadata, dplyr::one_of(want)) %>%
          dplyr::distinct(MARKERS, .keep_all = TRUE)

        # write blacklist and whitelist
        readr::write_tsv(x = blacklist.call.rate.markers, path = file.path(path.folder.call.rate, "blacklist.call.rate.markers.tsv"))
        readr::write_tsv(x = whitelist.markers, path = file.path(path.folder.call.rate, "whitelist.call.rate.markers.tsv"))
      }
      blacklist.call.rate.markers <- NULL
    } else {
      stop("A filter.call.rate threshold value is required...")
    }
    call.rate <- plot.call.rate.histo <- plot.call.rate.violinplot <- NULL
  }#End filter.call.rate

  # strata ---------------------------------------------------------------------
  if (is.vector(strata)) {
    strata.df <- readr::read_tsv(
      file = strata, col_names = TRUE,
      col_types = readr::cols(.default = readr::col_character())) %>%
      dplyr::mutate(
        TARGET_ID = stringi::stri_trans_toupper(TARGET_ID),
        TARGET_ID = stringi::stri_replace_all_fixed(
          TARGET_ID, pattern = " ", replacement = "", vectorize_all = FALSE))
  } else {
    strata.df <- dplyr::mutate_all(.tbl = strata, .funs = as.character) %>%
      dplyr::mutate(
        TARGET_ID = stringi::stri_trans_toupper(TARGET_ID),
        TARGET_ID = stringi::stri_replace_all_fixed(
          TARGET_ID, pattern = " ", replacement = "", vectorize_all = FALSE))
  }

  data.info$n.pop <- first.data.info$n.pop <- dplyr::n_distinct(strata.df$STRATA)
  data.info$n.ind <- first.data.info$n.ind <- dplyr::n_distinct(strata.df$INDIVIDUALS)

  # pop.select -----------------------------------------------------------------
  if (!is.null(pop.select)) {
    if (verbose) {
      n.pop.new <- length(pop.select)
      message(
        n.pop.new, " population(s) selected: ",
        stringi::stri_join(pop.select, collapse = ", "), sep = " ")
    }
    strata.df <- suppressWarnings(strata.df %>% dplyr::filter(STRATA %in% pop.select))
    n.ind.new <- dplyr::n_distinct(strata.df$INDIVIDUALS)
    # updating parameters
    filters.parameters <- tibble::data_frame(
      FILTERS = c("pop selected","pop selected"),
      PARAMETERS = c("", ""),
      VALUES = c(stringi::stri_join(pop.select, collapse = ", "), stringi::stri_join(pop.select, collapse = ", ")),
      BEFORE = c(data.info$n.pop, data.info$n.ind),
      AFTER = c(n.pop.new, n.ind.new),
      BLACKLIST = c(data.info$n.pop - n.pop.new, data.info$n.ind - n.ind.new),
      UNITS = c("populations", "individuals"),
      COMMENTS = c("", "")
    )
    readr::write_tsv(x = filters.parameters, path = filters.parameters.path,
                     append = TRUE, col_names = FALSE)
    # update data.info
    data.info$n.pop <- n.pop.new
    data.info$n.ind <- n.ind.new
  }

  # Blacklist id ---------------------------------------------------------------
  if (is.null(blacklist.id)) { # No blacklist of ID
    if (verbose) message("\nBlacklisted individuals: no")
    res$blacklist.id <- tibble::data_frame(INDIVIDUALS = character(0))
  } else {# With blacklist of ID
    res$blacklist.id <- suppressMessages(readr::read_tsv(blacklist.id, col_names = TRUE))
    n.ind.blacklisted <- length(res$blacklist.id$INDIVIDUALS)
    if (verbose) message("\nBlacklisted individuals: ", n.ind.blacklisted, " ind.")
    if (verbose) message("    Filtering with blacklist of individuals")

    n.id.before <- dplyr::n_distinct(strata.df$INDIVIDUALS)
    n.pop.before <- dplyr::n_distinct(strata.df$STRATA)
    strata.df <- dplyr::filter(strata.df, !INDIVIDUALS %in% res$blacklist.id$INDIVIDUALS)
    n.id.after <- dplyr::n_distinct(strata.df$INDIVIDUALS)
    n.pop.after <- dplyr::n_distinct(strata.df$STRATA)

    n.ind.blacklisted <- n.id.after - n.id.before
    if (n.ind.blacklisted > 0) {
      # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "blacklisted ids",
        PARAMETERS = "",
        VALUES = "",
        BEFORE = n.id.before,
        AFTER = n.id.after,
        BLACKLIST = n.id.before - n.id.after,
        UNITS = "individuals",
        COMMENTS = ""
      )
      readr::write_tsv(x = filters.parameters, path = filters.parameters.path,
                       append = TRUE, col_names = FALSE)
    } else {
      message("    None of the individuals in the blacklist were used to filter the data")
    }
    # update data.info
    data.info$n.ind <- n.id.after
    data.info$n.pop <- n.pop.after
  }
  metadata <- NULL
  # Tidy DArT ------------------------------------------------------------------
  message("\nNext step requires the genotypes")
  if (data.type == "dart") {
    input <- radiator::tidy_dart(data = data, strata = strata.df,
                                 whitelist.markers = whitelist.markers,
                                 filename = filename, verbose = TRUE,
                                 parallel.core = parallel.core)
  } else {
    input <- input %>%
      dplyr::filter(MARKERS %in% whitelist.markers$MARKERS) %>%
      dplyr::filter(INDIVIDUALS %in% strata.df$INDIVIDUALS)
  }

  # Change populations names or order/levels -----------------------------------
  if (is.factor(input$POP_ID)) input$POP_ID <- droplevels(input$POP_ID)
  pop.levels <- levels(input$POP_ID)
  input <- change_pop_names(data = input, pop.levels = pop.levels)

  # check for count data
  count.data <- tibble::has_name(input, "ALLELE_REF_DEPTH")

  # Update data info
  data.info$n.pop <- dplyr::n_distinct(input$POP_ID)
  data.info$n.ind <- dplyr::n_distinct(input$INDIVIDUALS)
  #
  #   # update metadata file -------------------------------------------------------
  #   write_rad(
  #     data = metadata,
  #     path = file.path(
  #       path.folder,
  #       stringi::stri_replace_all_fixed(metadata.file,
  #                                       ".rad", "_filtered.rad",
  #                                       vectorize_all = FALSE)))
  # Filtering coverage --------------------------------------------------------
  if (!is.null(erase.genotypes) || !is.null(filter.markers.coverage) || interactive.filter) {
    message("Filtering coverage")
    folder.extension <- stringi::stri_join("filter_coverage_dart_", file.date, sep = "")
    path.folder.coverage <- file.path(path.folder, folder.extension)
    dir.create(path.folder.coverage)
    message("Folder created: \n", folder.extension)
  }
  if (!count.data && (interactive.filter || !is.null(filter.markers.coverage))) {
    message("Filtering markers mean coverage")
    want <- c("MARKERS", "CHROM", "LOCUS", "POS", "AVG_COUNT_REF", "AVG_COUNT_SNP")
    coverage <- dplyr::select(metadata, dplyr::one_of(want)) %>%
      dplyr::rename(REF = AVG_COUNT_REF, ALT = AVG_COUNT_SNP) %>%
      dplyr::distinct(MARKERS, REF, ALT, .keep_all = TRUE) %>%
      dplyr::mutate(READS = REF + ALT)

    coverage.long <- tidyr::gather(data = coverage, key = GROUP, value = COVERAGE, -c(MARKERS, CHROM, LOCUS, POS)) %>%
      dplyr::mutate(GROUP = factor(GROUP, levels = c("READS", "REF", "ALT"), ordered = TRUE))
    plot.coverage <- ggplot2::ggplot(
      data = coverage.long,
      ggplot2::aes(x = COVERAGE)) +
      ggplot2::geom_histogram() +
      ggplot2::labs(x = "Markers") +
      ggplot2::labs(y = "Coverage (count)") +
      ggplot2::theme(
        legend.position = "none",
        axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica", angle = 90, hjust = 1, vjust = 0.5),
        strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
      ) +
      ggplot2::facet_grid(~ GROUP)
    # plot.coverage
    suppressMessages(ggplot2::ggsave(
      filename = file.path(path.folder.coverage, "plot.coverage.pdf"),
      plot = plot.coverage,
      width = 30, height = 15, dpi = 600, units = "cm", useDingbats = FALSE))

    plot.coverage.boxplot <- ggplot2::ggplot(
      coverage.long,
      ggplot2::aes(x = factor(GROUP), y = COVERAGE, na.rm = TRUE)) +
      ggplot2::geom_violin(trim = TRUE) +
      ggplot2::geom_boxplot(width = 0.1, fill = "black", outlier.colour = NA) +
      ggplot2::stat_summary(fun.y = "mean", geom = "point", shape = 21, size = 2.5, fill = "white") +
      ggplot2::labs(x = "Markers") +
      ggplot2::labs(y = "Coverage (count)") +
      ggplot2::theme(
        legend.position = "none",
        axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica"),
        legend.title = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        legend.text = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
      )
    # plot.coverage.boxplot
    suppressMessages(ggplot2::ggsave(
      filename = file.path(path.folder.coverage, "plot.coverage.boxplot.pdf"),
      plot = plot.coverage.boxplot,
      width = 15, height = 15, dpi = 600, units = "cm", useDingbats = FALSE))

    if (interactive.filter) {
      filter.coverage <- c(1, 1000000)
      message("    Inspect plots in folder created to help choose coverage thresholds (min and max)...")
      message("    Enter the minimum coverage allowed to keep a marker (e.g. 7): ")
      filter.coverage[1] <- as.numeric(readLines(n = 1))
    }

    if (interactive.filter) {
      message("    Enter the maximum coverage allowed to keep a marker (e.g. 150): ")
      filter.coverage[2] <- as.numeric(readLines(n = 1))
      filter.coverage <- as.numeric(filter.coverage)
    }

    if (!is.null(filter.coverage)) {
      want <- c("MARKERS", "CHROM", "LOCUS", "POS")
      blacklist.coverage.markers <- coverage %>%
        dplyr::filter(READS < filter.coverage[1] | READS > filter.coverage[2]) %>%
        dplyr::select(dplyr::one_of(want)) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE)

      if (nrow(blacklist.coverage.markers) > 0) {
        n.snp.before <- data.info$n.snp
        if (verbose) message("    Number of markers before = ", n.snp.before)
        n.snp.blacklist <- nrow(blacklist.coverage.markers)
        if (verbose) message("    Number of markers removed = ", n.snp.blacklist)
        if (verbose) message("    Number of markers after = ", n.snp.before - n.snp.blacklist)
        # input <- dplyr::anti_join(input, blacklist.coverage.markers, by = "MARKERS")

        metadata <- metadata %>%
          dplyr::filter(!MARKERS %in% blacklist.coverage.markers$MARKERS)

        whitelist.markers <- dplyr::select(metadata, dplyr::one_of(want)) %>%
          dplyr::distinct(MARKERS, .keep_all = TRUE)

        new.data.info <- data_info(metadata) # updating parameters
        filters.parameters <- tibble::data_frame(
          FILTERS = "coverage",
          PARAMETERS = "min/max",
          VALUES = stringi::stri_join(filter.coverage, collapse = "/"),
          BEFORE = stringi::stri_join(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
          AFTER = stringi::stri_join(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
          BLACKLIST = stringi::stri_join(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
          UNITS = "CHROM/LOCUS/SNP",
          COMMENTS = ""
        )
        readr::write_tsv(x = filters.parameters,
                         path = filters.parameters.path, append = TRUE,
                         col_names = FALSE)
        # update data.info
        data.info <- new.data.info

        if (!is.null(blacklist.markers)) {
          blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.coverage.markers)
        } else {
          blacklist.markers <- blacklist.coverage.markers
        }

        # write blacklist and whitelist
        readr::write_tsv(x = blacklist.coverage.markers, path = file.path(path.folder.coverage, "blacklist.coverage.markers.tsv"))
        readr::write_tsv(x = whitelist.markers, path = file.path(path.folder.coverage, "whitelist.coverage.markers.tsv"))
      }
    } else {
      stop("A filter.coverage thresholds values are required...")
    }
    blacklist.coverage.markers <- coverage <- coverage.long <- plot.coverage <- plot.coverage.boxplot <- NULL
  } else {# Counts data
    if (!is.null(erase.genotypes)) {
      threshold.low.coverage <- erase.genotypes[1]
      threshold.gl <- erase.genotypes[2]
      threshold.high.coverage <- erase.genotypes[3]
    }

    # Filter low genotypes coverage
    message("Filtering genotypes coverage")

    element.text <- ggplot2::element_text(size = 10,
                                          family = "Helvetica", face = "bold")

    #1. Filter low coverage for all genotypes with read depth -----------------
    message("generating plot...")
    coverage.plot <- suppressWarnings(
      ggplot2::ggplot(
        input, ggplot2::aes(x = POP_ID, y = READ_DEPTH, na.rm = TRUE)) +
        ggplot2::geom_violin(trim = TRUE) +
        ggplot2::geom_boxplot(width = 0.1, fill = "black", outlier.colour = NA) +
        ggplot2::stat_summary(fun.y = "mean", geom = "point", shape = 21,
                              size = 2.5, fill = "white") +
        ggplot2::labs(x = "Populations",
                      y = "Genotypes coverage (read depth)",
                      title = "Genotypes coverage information",
                      subtitle = "zoomed between 0 and 200 read depth") +
        ggplot2::theme(
          legend.position = "none",
          plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
          plot.subtitle = ggplot2::element_text(size = 10, family = "Helvetica", hjust = 0.5),
          axis.title.y = element.text,
          axis.title.x = element.text,
          axis.text.x = element.text
        ) +
        ggplot2::coord_cartesian(ylim = c(0, 200))
    )
    suppressWarnings(
      ggplot2::ggsave(
        plot = coverage.plot,
        filename = file.path(path.folder.coverage, "plot.coverage.violinplot.pdf"),
        width = data.info$n.pop * 2, height = 10, dpi = 300, units = "cm",
        useDingbats = FALSE)
    )
    coverage.plot <- NULL

    if (interactive.filter) {
      threshold.low.coverage <- 0
      message("    Inspect violin plot to help choose min coverage threshold")
      message("    The plot is zoomed between 0 and 200 of read depth")
      message("    Enter the minimum read depth threshold to call a genotype")
      message("    Below this threshold, genotypes are erased (e.g. 7 or 10): ")
      threshold.low.coverage <- as.numeric(readLines(n = 1))
    }

    n.genotypes <- nrow(dplyr::filter(input, !is.na(GT_BIN)))
    blacklist.genotypes <- input %>%
      dplyr::filter(READ_DEPTH < threshold.low.coverage) %>%
      dplyr::mutate(BLACKLIST_GENOTYPES_COMMENT = "low.coverage")

    if (nrow(blacklist.genotypes) > 0) {
      n.blacklist.genotypes <- nrow(blacklist.genotypes)
      message("    number of blacklisted (erased) genotypes (%): ",
              n.blacklist.genotypes, " (",
              round(n.blacklist.genotypes / n.genotypes * 100, 2),")")
      readr::write_tsv(
        x = blacklist.genotypes,
        path = file.path(path.folder.coverage, "blacklist.genotypes.tsv"))

      blacklist.genotypes <- blacklist.genotypes %>%
        dplyr::select(-BLACKLIST_GENOTYPES_COMMENT) %>%
        dplyr::mutate(
          GT = rep("000000", n()),
          GT_VCF = rep("./.", n()),
          GT_VCF_NUC = rep("./.", n()),
          GT_BIN = rep(as.numeric(NA_integer_, n())),
          ALLELE_REF_DEPTH = NA_integer_,
          ALLELE_ALT_DEPTH = NA_integer_,
          READ_DEPTH = NA_integer_
        )
      # we need to keep READ_DEPTH with NA...
      input <- input %>%
        dplyr::filter(is.na(READ_DEPTH) | READ_DEPTH >= threshold.low.coverage) %>%
        dplyr::bind_rows(blacklist.genotypes)

      blacklist.genotypes <- NULL

      # new.data.info <- data_info(metadata) # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "low coverage",
        PARAMETERS = "min",
        VALUES = threshold.low.coverage,
        BEFORE = n.genotypes,
        AFTER = n.genotypes - n.blacklist.genotypes,
        BLACKLIST = n.blacklist.genotypes,
        UNITS = "genotypes",
        COMMENTS = ""
      )
      readr::write_tsv(x = filters.parameters,
                       path = filters.parameters.path, append = TRUE,
                       col_names = FALSE)
    }

    # 2. het genotypes coverage ------------------------------------------------
    # escape a bit the first threshold
    # second pass of filtering using alleles coverage info
    # using the same threshold we explore the data.
    if (interactive.filter) {
      message("Exploration of coverage for heterozygous genotypes
              with REF/ALT alleles below ", threshold.low.coverage, " reads")
    }
    gl_relative <- function(x) x / max(x)
    geno.coverage <- suppressWarnings(
      input %>%
        dplyr::group_by(MARKERS) %>%
        dplyr::mutate(
          # MISSING_PROP_MARKERS = length(GT_BIN[is.na(GT_BIN)]) / length(GT_BIN),
          # GENOTYPED_PROP_MARKERS = 1 - MISSING_PROP_MARKERS
          GENOTYPED_PROP_MARKERS = length(GT_BIN[!is.na(GT_BIN)]) / length(GT_BIN)
        ) %>%
        dplyr::group_by(INDIVIDUALS) %>%
        dplyr::mutate(
          # MISSING_PROP_INDIVIDUALS = length(GT_BIN[is.na(GT_BIN)]) / length(GT_BIN),
          # GENOTYPED_PROP_INDIVIDUALS = 1 - MISSING_PROP_INDIVIDUALS
          GENOTYPED_PROP_INDIVIDUALS = length(GT_BIN[!is.na(GT_BIN)]) / length(GT_BIN)
        ) %>%
        dplyr::ungroup(.) %>%
        dplyr::filter(
          GT_BIN == 1,
          ALLELE_REF_DEPTH <= threshold.low.coverage | ALLELE_ALT_DEPTH <= threshold.low.coverage) %>%
        dplyr::select(MARKERS, INDIVIDUALS, GT_BIN, READ_DEPTH, ALLELE_REF_DEPTH, ALLELE_ALT_DEPTH, GENOTYPED_PROP_MARKERS, GENOTYPED_PROP_INDIVIDUALS) %>%
        dplyr::group_by(MARKERS) %>%
        dplyr::mutate(NUMBER_INDIVIDUALS = length(INDIVIDUALS)) %>%
        dplyr::ungroup(.) %>%
        dplyr::mutate(
          ALLELE_RATIO_LIK = ALLELE_ALT_DEPTH / ALLELE_REF_DEPTH,
          ALLELE_RATIO_LIK = dplyr::if_else(ALLELE_RATIO_LIK > 1, 1 / ALLELE_RATIO_LIK, ALLELE_RATIO_LIK)
        ) %>%
        dplyr::mutate_at(
          .tbl = .,
          .vars = c("NUMBER_INDIVIDUALS", "GENOTYPED_PROP_MARKERS", "GENOTYPED_PROP_INDIVIDUALS"),
          .funs = gl_relative) %>%
        dplyr::mutate(
          GT_BIN = factor(GT_BIN),
          # Different weight
          # Very primitive GL but really works well
          # Note to myself: z-score could also be used and explored here
          # similar to AMOVA with missing
          GL = ((ALLELE_RATIO_LIK * 4) +# The ratio between REF and ALT x4
                  (NUMBER_INDIVIDUALS * 3) +# The number of individuals with same genotypes x3
                  (GENOTYPED_PROP_INDIVIDUALS * 2) +# The number of individuals with same genotypes x3
                  GENOTYPED_PROP_MARKERS) / 10 # the proportion of genotypes within markers x1
        ) %>%
        dplyr::mutate_at(
          .tbl = .,
          .vars = "GL",
          .funs = gl_relative) %>%
        dplyr::select(MARKERS, INDIVIDUALS, GT_BIN, READ_DEPTH, ALLELE_REF_DEPTH,
                      ALLELE_ALT_DEPTH, GL, NUMBER_INDIVIDUALS,
                      GENOTYPED_PROP_MARKERS, GENOTYPED_PROP_INDIVIDUALS) %>%
        dplyr::mutate(GL = log10(GL)) %>%
        dplyr::arrange(GL))

    gl.data <- geno.coverage %>%
      dplyr::select(GT_BIN, ALLELE_REF_DEPTH, ALLELE_ALT_DEPTH, GL) %>%
      data.table::as.data.table(.) %>%
      data.table::melt.data.table(
        data = .,
        id.vars = c("GT_BIN", "GL"),
        variable.name = "ALLELES",
        value.name = "READ_DEPTH"
      ) %>%
      tibble::as_data_frame(.) %>%
      dplyr::filter(READ_DEPTH <= threshold.low.coverage)

    min.rd <- min(gl.data$READ_DEPTH)
    max.rd <- max(gl.data$READ_DEPTH)
    overall.range <- stringi::stri_join(min.rd, max.rd, sep = "-")
    overall.levels <- seq(from = min.rd, to = max.rd, by = 1)
    overall.levels <- c(overall.levels, overall.range)
    gl.data$READ_DEPTH <- as.character(gl.data$READ_DEPTH)
    gl.data <- suppressWarnings(
      dplyr::bind_rows(
        gl.data,
        gl.data %>%
          dplyr::mutate(
            ALLELES = rep("OVERALL", n()),
            READ_DEPTH = rep(overall.range, n()))
      ) %>%
        dplyr::mutate(
          ALLELES = factor(
            x = ALLELES,
            levels = c("ALLELE_REF_DEPTH", "ALLELE_ALT_DEPTH", "OVERALL"),
            labels = c("REF", "ALT", "OVERALL")),
          READ_DEPTH = factor(x = READ_DEPTH, levels = overall.levels)))

    gl.stats <- dplyr::filter(gl.data, ALLELES == "OVERALL") %>%
      dplyr::select(GL) %>%
      dplyr::summarise(
        GL_MEAN = mean(GL, na.rm = TRUE),
        GL_MEDIAN = stats::median(GL, na.rm = TRUE),
        GL_SD = stats::sd(GL, na.rm = TRUE),
        GL_IQR = stats::quantile(GL, 0.75, na.rm = TRUE) - stats::quantile(GL, 0.25, na.rm = TRUE),
        GL_MIN = min(GL, na.rm = TRUE),
        GL_MAX = max(GL, na.rm = TRUE),
        OUTLIERS = length(GL[GL < (stats::quantile(GL, 0.25, na.rm = TRUE) - (1.5 * GL_IQR))]),
        OUTLIERS_PROP = round(OUTLIERS / length(GL), 3)
      ) %>%
      readr::write_tsv(x = ., path = file.path(path.folder.coverage,"het.genotypes.coverage.gl.tsv"))
    print(gl.stats)
    gl.stats <- NULL

    plot.gl.violinplot <- ggplot2::ggplot(
      gl.data, ggplot2::aes(x = READ_DEPTH, y = GL, na.rm = TRUE)) +
      ggplot2::geom_violin(trim = TRUE) +
      ggplot2::geom_boxplot(width = 0.1, fill = "black", outlier.colour = NA) +
      ggplot2::stat_summary(fun.y = "mean", geom = "point", shape = 21,
                            size = 2.5, fill = "white") +
      ggplot2::labs(x = "Alleles read depth of heterozygous genotypes",
                    y = "Genotype Likelihood (GL)") +
      ggplot2::theme(
        legend.position = "none",
        axis.title.y = element.text,
        axis.title.x = element.text,
        axis.text.x = element.text
      ) +
      ggplot2::facet_wrap(~ ALLELES, scales = "free")
    print(plot.gl.violinplot)
    suppressWarnings(ggplot2::ggsave(
      filename = file.path(path.folder.coverage, "plot.gl.violinplot.pdf"),
      plot = plot.gl.violinplot,
      width = length(overall.levels) * 1.8, height = 10, dpi = 300, units = "cm",
      useDingbats = FALSE))

    plot.gl.violinplot <- gl.data <- NULL

    # GL and coverage correlation statistics------------------------------------
    cor_ref <- function(x) {
      stats::cor.test(~ ALLELE_REF_DEPTH + VALUE, data = x)
    }

    cor_alt <- function(x) {
      stats::cor.test(~ ALLELE_ALT_DEPTH + VALUE, data = x)
    }

    cor.data <- suppressWarnings(
      geno.coverage %>%
        dplyr::mutate(GENOTYPE = seq(from = 1, to = n(), by = 1)) %>%
        dplyr::select(GENOTYPE, ALLELE_REF_DEPTH, ALLELE_ALT_DEPTH,
                      NUMBER_INDIVIDUALS, READ_DEPTH, GENOTYPED_PROP_MARKERS,
                      GENOTYPED_PROP_INDIVIDUALS) %>%
        data.table::as.data.table(.) %>%
        data.table::melt.data.table(
          data = .,
          id.vars = c("GENOTYPE", "ALLELE_REF_DEPTH", "ALLELE_ALT_DEPTH"),
          variable.name = "GROUP",
          value.name = "VALUE"
        ) %>%
        tibble::as_data_frame(.) %>%
        dplyr::select(-GENOTYPE))

    ref.cor <- suppressWarnings(
      cor.data %>%
        dplyr::group_by(GROUP) %>%
        tidyr::nest(.key = DATA) %>%
        dplyr::mutate(
          MODEL = purrr::map(purrr::map(.x = DATA, .f = cor_ref), broom::tidy)
        ) %>%
        tidyr::unnest(MODEL) %>%
        dplyr::select(-DATA)) %>%
      tibble::add_column(.data = ., ALLELE = rep("REF", nrow(.)), .before = 1)
    colnames(ref.cor) <- stringi::stri_trans_toupper(colnames(ref.cor))

    alt.cor <- suppressWarnings(
      cor.data %>%
        dplyr::group_by(GROUP) %>%
        tidyr::nest(.key = DATA) %>%
        dplyr::mutate(
          MODEL = purrr::map(purrr::map(.x = DATA, .f = cor_alt), broom::tidy)
        ) %>%
        tidyr::unnest(MODEL) %>%
        dplyr::select(-DATA)) %>%
      tibble::add_column(.data = ., ALLELE = rep("ALT", nrow(.)), .before = 1)
    colnames(alt.cor) <- stringi::stri_trans_toupper(colnames(alt.cor))

    depth.cor <- dplyr::bind_rows(ref.cor, alt.cor)
    ref.cor <- alt.cor <- NULL
    # View(depth.cor)
    readr::write_tsv(
      x = depth.cor,
      path = file.path(path.folder.coverage, "het.geno.correlation.tsv"))

    depth.cor <- cor.data <- NULL

    if (interactive.filter) {
      threshold.gl <- -1000000
      message("    Enter the gl threshold (close to 0 the better)")
      message("    Below this threshold, heterozygous genotypes are erased: ")
      threshold.gl <- as.double(readLines(n = 1))
    }

    n.genotypes <- nrow(dplyr::filter(input, !is.na(GT_BIN)))
    blacklist.genotypes.gl <- geno.coverage %>%
      dplyr::select(MARKERS, INDIVIDUALS, GL) %>%
      dplyr::filter(GL < threshold.gl) %>%
      dplyr::distinct(MARKERS, INDIVIDUALS)

    if (nrow(blacklist.genotypes.gl) > 0) {
      n.blacklist.genotypes <- nrow(blacklist.genotypes.gl)
      message("    number of blacklisted (erased) genotypes (%): ",
              n.blacklist.genotypes, " (",
              round(n.blacklist.genotypes / n.genotypes * 100, 2),")")

      blacklist.genotypes.gl <- blacklist.genotypes.gl %>%
        dplyr::mutate(BLACKLIST_GENOTYPES_COMMENT = rep("bad.gl", n()))

      input <- dplyr::left_join(
        input,
        blacklist.genotypes.gl, by = c("MARKERS", "INDIVIDUALS"))

      blacklist.genotypes.gl <- dplyr::filter(
        input, BLACKLIST_GENOTYPES_COMMENT == "bad.gl") %>%
        readr::write_tsv(
          x = .,
          path = file.path(path.folder.coverage, "blacklist.genotypes.tsv"),
          append = TRUE) %>%
        dplyr::select(-BLACKLIST_GENOTYPES_COMMENT) %>%
        dplyr::mutate(
          GT = rep("000000", n()),
          GT_VCF = rep("./.", n()),
          GT_VCF_NUC = rep("./.", n()),
          GT_BIN = rep(as.numeric(NA_integer_, n())),
          ALLELE_REF_DEPTH = NA_integer_,
          ALLELE_ALT_DEPTH = NA_integer_,
          READ_DEPTH = NA_integer_
        )

      input <- input %>%
        dplyr::filter(
          is.na(BLACKLIST_GENOTYPES_COMMENT) | BLACKLIST_GENOTYPES_COMMENT != "bad.gl") %>%
        dplyr::bind_rows(blacklist.genotypes.gl)
      blacklist.genotypes.gl <- geno.coverage <- NULL


      # new.data.info <- data_info(metadata) # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "heterozygous genotypes low gl",
        PARAMETERS = "low gl",
        VALUES = threshold.gl,
        BEFORE = n.genotypes,
        AFTER = n.genotypes - n.blacklist.genotypes,
        BLACKLIST = n.blacklist.genotypes,
        UNITS = "genotypes",
        COMMENTS = ""
      ) %>%
        readr::write_tsv(
          x = .,
          path = filters.parameters.path, append = TRUE,
          col_names = FALSE)
    }

    #3. High coverage genotypes ------------------------------------------------
    if (interactive.filter) message("Exploration of high coverage genotypes")

    data.high.cov <- input %>%
      dplyr::select(MARKERS, CHROM, LOCUS, POS, GENOTYPES = READ_DEPTH,
                    REF = ALLELE_REF_DEPTH, ALT = ALLELE_ALT_DEPTH) %>%
      data.table::as.data.table(.) %>%
      data.table::melt.data.table(
        data = .,
        id.vars = c("MARKERS", "CHROM", "LOCUS", "POS"),
        variable.name = "GROUP",
        value.name = "COVERAGE"
      ) %>%
      tibble::as_data_frame(.) %>%
      dplyr::mutate(GROUP = factor(GROUP, levels = c("GENOTYPES", "REF", "ALT"),
                                   ordered = TRUE)) %>%
      dplyr::filter(COVERAGE > 0)

    data.high.cov.stats <- data.high.cov %>%
      dplyr::group_by(GROUP) %>%
      dplyr::summarise(
        MEAN = mean(COVERAGE, na.rm = TRUE),
        MEDIAN = stats::median(COVERAGE, na.rm = TRUE),
        SD = stats::sd(COVERAGE, na.rm = TRUE),
        Q25 = stats::quantile(COVERAGE, 0.25, na.rm = TRUE),
        Q75 = stats::quantile(COVERAGE, 0.75, na.rm = TRUE),
        IQR = Q75 - Q25,
        MIN = min(COVERAGE, na.rm = TRUE),
        MAX = max(COVERAGE, na.rm = TRUE),
        OUTLIERS_COVERAGE = Q75 + (1.5 * IQR),
        OUTLIERS_N = length(COVERAGE[COVERAGE > OUTLIERS_COVERAGE]),
        OUTLIERS_PROP = round(OUTLIERS_N / length(COVERAGE), 3)
      ) %>%
      readr::write_tsv(x = ., path = file.path(path.folder.coverage,"genotypes.high.coverage.stats.tsv"))

    message("generating plot...")
    plot.high.coverage.boxplot <- ggplot2::ggplot(
      data.high.cov.stats,
      ggplot2::aes(factor(GROUP), na.rm = TRUE)) +
      ggplot2::geom_boxplot(
        ggplot2::aes(ymin = MIN, lower = Q25, middle = MEDIAN, upper = Q75, ymax = MAX), stat = "identity") +
      ggplot2::labs(
        x = "Coverage groups",
        y = "Coverage (read depth)",
        title = "Genotypes coverage information") +
      ggplot2::theme(
        plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
        legend.position = "none",
        axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica"),
        legend.title = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        legend.text = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
      )

    # with data, but way too long
    # plot.high.coverage.boxplot <- ggplot2::ggplot(
    #   data.high.cov,
    #   ggplot2::aes(x = factor(GROUP), y = COVERAGE, na.rm = TRUE)) +
    #   ggplot2::geom_boxplot() +
    #   ggplot2::labs(
    #     x = "Coverage groups",
    #     y = "Coverage (read depth)",
    #     title = "Genotypes coverage information") +
    #   ggplot2::theme(
    #     plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
    #     legend.position = "none",
    #     axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
    #     axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
    #     axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica"),
    #     legend.title = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
    #     legend.text = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
    #     strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
    #   )
    print(plot.high.coverage.boxplot)
    suppressMessages(ggplot2::ggsave(
      filename = file.path(path.folder.coverage, "plot.high.coverage.boxplot.pdf"),
      plot = plot.high.coverage.boxplot,
      width = 15, height = 10, dpi = 300, units = "cm", useDingbats = FALSE))
    plot.high.coverage.boxplot <- NULL


    # Same plot, but with outliers removed
    coverage.outliers <- data.high.cov.stats %>%
      dplyr::filter(GROUP == "GENOTYPES") %>%
      dplyr::select(OUTLIERS_COVERAGE) %>%
      purrr::flatten_dbl(.)

    plot.high.coverage.filtered.boxplot <- data.high.cov %>%
      dplyr::filter(COVERAGE <= coverage.outliers) %>%
      dplyr::group_by(GROUP) %>%
      dplyr::summarise(
        MEAN = mean(COVERAGE, na.rm = TRUE),
        MEDIAN = stats::median(COVERAGE, na.rm = TRUE),
        SD = stats::sd(COVERAGE, na.rm = TRUE),
        Q25 = stats::quantile(COVERAGE, 0.25, na.rm = TRUE),
        Q75 = stats::quantile(COVERAGE, 0.75, na.rm = TRUE),
        IQR = Q75 - Q25,
        MIN = min(COVERAGE, na.rm = TRUE),
        MAX = max(COVERAGE, na.rm = TRUE),
        OUTLIERS_COVERAGE = Q75 + (1.5 * IQR),
        OUTLIERS_N = length(COVERAGE[COVERAGE > OUTLIERS_COVERAGE]),
        OUTLIERS_PROP = round(OUTLIERS_N / length(COVERAGE), 3)
      ) %>%
      ggplot2::ggplot(
        data = .,
        ggplot2::aes(factor(GROUP), na.rm = TRUE)) +
      ggplot2::geom_boxplot(
        ggplot2::aes(ymin = MIN, lower = Q25, middle = MEDIAN, upper = Q75, ymax = MAX), stat = "identity") +
      ggplot2::labs(
        x = "Coverage groups",
        y = "Coverage (read depth)",
        title = "Genotypes coverage information",
        subtitle = stringi::stri_join("(outliers genotypes > ", coverage.outliers, " read depth removed)")) +
      ggplot2::theme(
        plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
        plot.subtitle = ggplot2::element_text(size = 10, family = "Helvetica", hjust = 0.5),
        legend.position = "none",
        axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica"),
        legend.title = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        legend.text = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
      )
    # plot.high.coverage.filtered.boxplot <- data.high.cov %>%
    #   dplyr::filter(COVERAGE <= coverage.outliers) %>%
    #   ggplot2::ggplot(
    #     data = .,
    #     ggplot2::aes(x = factor(GROUP), y = COVERAGE, na.rm = TRUE)) +
    #   ggplot2::geom_boxplot() +
    #   ggplot2::labs(
    #     x = "Coverage groups",
    #     y = "Coverage (read depth)",
    #     title = "Genotypes coverage information",
    #     subtitle = stringi::stri_join("(outliers genotypes > ", coverage.outliers, " read depth removed)")) +
    #   ggplot2::theme(
    #     plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
    #     plot.subtitle = ggplot2::element_text(size = 10, family = "Helvetica", hjust = 0.5),
    #     legend.position = "none",
    #     axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
    #     axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
    #     axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica"),
    #     legend.title = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
    #     legend.text = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
    #     strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
    #   )
    print(plot.high.coverage.filtered.boxplot)
    suppressMessages(ggplot2::ggsave(
      filename = file.path(path.folder.coverage, "plot.high.coverage.filtered.boxplot.pdf"),
      plot = plot.high.coverage.filtered.boxplot,
      width = 15, height = 10, dpi = 300, units = "cm", useDingbats = FALSE))

    data.high.cov.stats <- data.high.cov <- plot.high.coverage.filtered.boxplot <- NULL

    if (interactive.filter) {
      threshold.high.coverage <- 1000
      message("    Inspect plots to help choose high coverage thresholds")
      message("    Enter the maximum read depth threshold to call a genotype")
      message("    Above this threshold, genotypes are erased (e.g. 300): ")
      threshold.high.coverage <- as.numeric(readLines(n = 1))
    }

    n.genotypes <- nrow(dplyr::filter(input, !is.na(GT_BIN)))
    blacklist.genotypes <- input %>%
      dplyr::filter(READ_DEPTH > threshold.high.coverage) %>%
      dplyr::mutate(BLACKLIST_GENOTYPES_COMMENT = "high.coverage")

    if (nrow(blacklist.genotypes) > 0) {
      n.blacklist.genotypes <- nrow(blacklist.genotypes)
      message("    number of blacklisted (erased) genotypes (%): ",
              n.blacklist.genotypes, " (",
              round(n.blacklist.genotypes / n.genotypes * 100, 2),")")
      readr::write_tsv(
        x = blacklist.genotypes,
        path = file.path(path.folder.coverage, "blacklist.genotypes.tsv"),
        append = TRUE)

      blacklist.genotypes <- blacklist.genotypes %>%
        dplyr::select(-BLACKLIST_GENOTYPES_COMMENT) %>%
        dplyr::mutate(
          GT = rep("000000", n()),
          GT_VCF = rep("./.", n()),
          GT_VCF_NUC = rep("./.", n()),
          GT_BIN = rep(as.numeric(NA_integer_, n())),
          ALLELE_REF_DEPTH = NA_integer_,
          ALLELE_ALT_DEPTH = NA_integer_,
          READ_DEPTH = NA_integer_
        )
      input <- input %>%
        dplyr::filter(is.na(READ_DEPTH) | READ_DEPTH <= threshold.high.coverage) %>%
        dplyr::bind_rows(blacklist.genotypes)
      blacklist.genotypes <- NULL

      # new.data.info <- data_info(metadata) # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "high coverage",
        PARAMETERS = "high",
        VALUES = threshold.high.coverage,
        BEFORE = n.genotypes,
        AFTER = n.genotypes - n.blacklist.genotypes,
        BLACKLIST = n.blacklist.genotypes,
        UNITS = "genotypes",
        COMMENTS = ""
      ) %>%
        readr::write_tsv(
          x = .,
          path = filters.parameters.path, append = TRUE,
          col_names = FALSE)
    }
  }#End filter coverage counts data

  # change to the new directory
  old.dir <- getwd()
  setwd(path.folder)

  # Filter monomorphic markers  ------------------------------------------------
  if (monomorphic.out) {
    input <- discard_monomorphic_markers(data = input, verbose = verbose)
    blacklist.monomorphic.markers <- input$blacklist.monomorphic.markers
    whitelist.markers <- input$whitelist.polymorphic.markers
    input <- input$input

    # update blacklist.markers
    if (nrow(blacklist.monomorphic.markers) > 0) {
      readr::write_tsv(x = blacklist.monomorphic.markers,
                       path = file.path(path.folder, "blacklist.monomorphic.markers.tsv"))
      if (verbose) message("    Blacklist of monomorphic markers written in: blacklist.monomorphic.markers.tsv")

      if (is.null(blacklist.markers)) {
        blacklist.markers<- blacklist.monomorphic.markers
      } else {
        blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.monomorphic.markers)
      }

      new.data.info <- data_info(input)

      # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "removing monomorphic markers",
        PARAMETERS = "",
        VALUES = "",
        BEFORE = stringi::stri_join(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
        AFTER = stringi::stri_join(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
        BLACKLIST = stringi::stri_join(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
        UNITS = "CHROM/LOCUS/SNP",
        COMMENTS = ""
      )
      readr::write_tsv(x = filters.parameters,
                       path = filters.parameters.path, append = TRUE,
                       col_names = FALSE)
      # update data.info
      data.info <- new.data.info
    }
    blacklist.monomorphic.markers <- NULL
  }# End monomorphic.out

  # Filter common markers between all populations  -----------------------------
  if (common.markers) {
    input <- keep_common_markers(data = input, plot = FALSE,
                                 verbose = verbose)
    blacklist.not.in.common.markers <- input$blacklist.not.in.common.markers
    whitelist.markers <- input$whitelist.common.markers
    input <- input$input

    if (nrow(blacklist.not.in.common.markers) > 0) {
      readr::write_tsv(x = blacklist.not.in.common.markers,
                       path = file.path(path.folder, "blacklist.not.in.common.markers.tsv"))
      if (verbose) message("    Blacklist of markers not in common written in: blacklist.not.in.common.markers.tsv")

      new.data.info <- data_info(input) # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "keeping common markers",
        PARAMETERS = "",
        VALUES = "",
        BEFORE = stringi::stri_join(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
        AFTER = stringi::stri_join(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
        BLACKLIST = stringi::stri_join(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
        UNITS = "CHROM/LOCUS/SNP",
        COMMENTS = ""
      )
      readr::write_tsv(x = filters.parameters,
                       path = filters.parameters.path, append = TRUE,
                       col_names = FALSE)
      # update data.info
      data.info <- new.data.info
      if (!is.null(blacklist.markers)) {
        blacklist.markers <- dplyr::bind_rows(blacklist.markers,
                                              blacklist.not.in.common.markers)
      } else {
        blacklist.markers <- blacklist.not.in.common.markers
      }
    }
    blacklist.not.in.common.markers <- NULL
  } #End common.markers

  # Back to the old dir...
  setwd(old.dir)

  # Filter individuals with too many missing -----------------------------------
  if (!is.null(filter.individuals.missing) || interactive.filter) {
    message("Filtering individuals with too many missing genotypes")
    folder.extension <- stringi::stri_join("filter_individuals_missing_dart_", file.date, sep = "")
    path.folder.id.missing <- file.path(path.folder, folder.extension)
    dir.create(path.folder.id.missing)
    message("Folder created: \n", folder.extension)

    ind.missing <-  input %>%
      dplyr::select(INDIVIDUALS, POP_ID, GT_BIN) %>%
      dplyr::group_by(INDIVIDUALS, POP_ID) %>%
      dplyr::summarise(
        GENOTYPED_PROP_INDIVIDUALS = length(GT_BIN[!is.na(GT_BIN)]) / length(GT_BIN)
      ) %>%
      dplyr::ungroup(.) %>%
      readr::write_tsv(x = ., path = file.path(path.folder.id.missing, "individuals.genotyping.info.tsv"))
    pop.levels.missing <- c(levels(ind.missing$POP_ID), "OVERALL")

    overall <- ind.missing %>%
      dplyr::mutate(POP_ID = rep("OVERALL", n()))

    ind.missing <- suppressWarnings(dplyr::bind_rows(ind.missing, overall) %>%
                                      dplyr::mutate(POP_ID = factor(POP_ID, levels = pop.levels.missing)))
    overall <- pop.levels.missing <- NULL
    message("generating plot...")
    missing.ind.plot <- suppressWarnings(
      ggplot2::ggplot(
        ind.missing, ggplot2::aes(x = POP_ID, y = GENOTYPED_PROP_INDIVIDUALS, na.rm = TRUE)) +
        ggplot2::geom_boxplot() +
        ggplot2::labs(x = "Populations",
                      y = "Individuals genotyped (proportion)",
                      title = "Genotyped/missing information",
                      subtitle = "to remove outliers individuals with too many missing genotypes") +
        ggplot2::theme(
          legend.position = "none",
          plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
          plot.subtitle = ggplot2::element_text(size = 10, family = "Helvetica", hjust = 0.5),
          axis.title.y = element.text,
          axis.title.x = element.text,
          axis.text.x = element.text))
    # missing.ind.plot
    suppressWarnings(
      ggplot2::ggsave(
        plot = missing.ind.plot,
        filename = file.path(path.folder.id.missing, "plot.missing.ind.pdf"),
        width = data.info$n.pop * 2, height = 10, dpi = 300, units = "cm",
        useDingbats = FALSE)
    )
    missing.ind.plot <- NULL

    if (interactive.filter) {
      filter.individuals.missing <- 0
      message("    Inspect plot and tables to help choose threshold to blacklist individuals")
      message("    Enter the ind minimum genotyped proportion threshold")
      message("    Below this threshold, individuals are blacklisted (e.g. 0.5): ")
      filter.individuals.missing <- as.double(readLines(n = 1))
    }

    blacklist.id <- ind.missing %>%
      dplyr::filter(GENOTYPED_PROP_INDIVIDUALS < filter.individuals.missing) %>%
      dplyr::select(INDIVIDUALS)

    if (nrow(blacklist.id) > 0) {
      res$blacklist.id <- dplyr::bind_rows(res$blacklist.id, blacklist.id)
      n.ind.blacklisted <- length(blacklist.id$INDIVIDUALS)
      if (verbose) message("\nBlacklisted individuals: ", n.ind.blacklisted, " ind.")
      if (verbose) message("    Filtering with blacklist of individuals")
      readr::write_tsv(x = blacklist.id, path = file.path(path.folder.id.missing, "blacklist.id.missing.tsv"))

      n.id.before <- dplyr::n_distinct(input$INDIVIDUALS)
      input <- dplyr::filter(input, !INDIVIDUALS %in% blacklist.id$INDIVIDUALS)
      n.id.after <- dplyr::n_distinct(input$INDIVIDUALS)
      # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "Filter individuals missing (blacklisted ids)",
        PARAMETERS = "filter.individuals.missing",
        VALUES = filter.individuals.missing,
        BEFORE = n.id.before,
        AFTER = n.id.after,
        BLACKLIST = n.ind.blacklisted,
        UNITS = "individuals",
        COMMENTS = ""
      )
      readr::write_tsv(x = filters.parameters, path = filters.parameters.path,
                       append = TRUE, col_names = FALSE)
      # update data.info
      data.info$n.ind <- n.id.after
    } else {
      if (verbose) message("\nBlacklisted individuals: no")
    }
  }#End filter missing per id

  # Filtering markers with too many missing ------------------------------------
  if (!is.null(filter.markers.missing) || interactive.filter) {
    ind.approach <- as.character(filter.markers.missing[1])
    ind.threshold <- as.numeric(filter.markers.missing[2])
    prob.pop.threshold <- as.integer(filter.markers.missing[3])

    if (interactive.filter) {
      message("2 steps to visualize and filter markers based on the number of genotyped individuals:")
      message("Step 1. Impact of individual threshold on marker discovery")
      message("Step 2. Choose the filtering approach and thresholds")
    }

    # Folder
    folder.extension <- stringi::stri_join("filter_markers_missing_dart_", file.date, sep = "")
    path.folder.ind.filter <- file.path(path.folder, folder.extension)
    dir.create(path.folder.ind.filter)
    message("Folder created: \n", folder.extension)

    # prepare filter, table and figure
    ind.total <- dplyr::n_distinct(input$INDIVIDUALS) # total number of individuals
    pop.number <- dplyr::n_distinct(input$POP_ID) # number of pop

    # individuals per pop
    ind.pop <- input %>%
      dplyr::distinct(POP_ID, INDIVIDUALS) %>%
      dplyr::group_by(POP_ID) %>%
      dplyr::tally(.) %>%
      dplyr::rename(N_IND = n)

    # input genotyped
    input.genotyped <- input %>%
      dplyr::filter(GT != "000000")

    # overall genotyped individuals
    overall <- input.genotyped %>%
      dplyr::select(MARKERS, INDIVIDUALS) %>%
      dplyr::group_by(MARKERS) %>%
      dplyr::tally(.) %>%
      dplyr::rename(GENOTYPED = n) %>%
      dplyr::mutate(PERCENT = ceiling(GENOTYPED/ind.total*100))

    # number of pop. genotyped per marker
    pop.genotyped.marker <- input.genotyped %>%
      dplyr::distinct(MARKERS, POP_ID) %>%
      dplyr::group_by(MARKERS) %>%
      dplyr::tally(.) %>%
      dplyr::rename(POP_GENOTYPED = n)

    # genotyped individuals per pop
    pop <- input.genotyped %>%
      dplyr::select(MARKERS, INDIVIDUALS, POP_ID) %>%
      dplyr::group_by(MARKERS, POP_ID) %>%
      dplyr::tally(.) %>%
      dplyr::rename(GENOTYPED = n) %>%
      dplyr::inner_join(ind.pop, by = "POP_ID") %>%
      dplyr::mutate(PERCENT = ceiling(GENOTYPED/N_IND*100))

    input.genotyped <- NULL # unused object

    # Step 1. Impact of individual threshold on marker discovery
    threshold.helper.overall <- overall %>%
      dplyr::ungroup(.) %>%
      dplyr::summarise(
        `10` = length(PERCENT[PERCENT >= 10]),
        `20` = length(PERCENT[PERCENT >= 20]),
        `30` = length(PERCENT[PERCENT >= 30]),
        `40` = length(PERCENT[PERCENT >= 40]),
        `50` = length(PERCENT[PERCENT >= 50]),
        `60` = length(PERCENT[PERCENT >= 60]),
        `70` = length(PERCENT[PERCENT >= 70]),
        `80` = length(PERCENT[PERCENT >= 80]),
        `90` = length(PERCENT[PERCENT >= 90]),
        `100` = length(PERCENT[PERCENT == 100])
      ) %>%
      tidyr::gather(data = ., key = IND_THRESHOLD, value = MARKER_NUMBER) %>%
      dplyr::mutate(POP_ID = rep("OVERALL", n()))

    threshold.helper.pop <- pop %>%
      dplyr::group_by(POP_ID) %>%
      dplyr::summarise(
        `10` = length(PERCENT[PERCENT >= 10]),
        `20` = length(PERCENT[PERCENT >= 20]),
        `30` = length(PERCENT[PERCENT >= 30]),
        `40` = length(PERCENT[PERCENT >= 40]),
        `50` = length(PERCENT[PERCENT >= 50]),
        `60` = length(PERCENT[PERCENT >= 60]),
        `70` = length(PERCENT[PERCENT >= 70]),
        `80` = length(PERCENT[PERCENT >= 80]),
        `90` = length(PERCENT[PERCENT >= 90]),
        `100` = length(PERCENT[PERCENT == 100])
      ) %>%
      tidyr::gather(data = ., key = IND_THRESHOLD, value = MARKER_NUMBER, -POP_ID)

    mean.pop <- threshold.helper.pop %>%
      dplyr::group_by(IND_THRESHOLD) %>%
      dplyr::summarise(
        MARKER_NUMBER = round(mean(MARKER_NUMBER), 0)
      ) %>%
      dplyr::mutate(POP_ID = rep("MEAN_POP", n()))

    # Make sure POP_ID is factor
    if (!is.factor(input$POP_ID)) {
      input$POP_ID <- factor(input$POP_ID)
    }

    threshold.helper <- suppressWarnings(
      dplyr::bind_rows(threshold.helper.pop, mean.pop, threshold.helper.overall) %>%
        dplyr::mutate(
          IND_THRESHOLD = as.numeric(IND_THRESHOLD),
          POP_ID = factor(POP_ID, levels = c(levels(input$POP_ID), "MEAN_POP", "OVERALL"), ordered = TRUE)
        ))

    # Set the breaks for the figure
    max.markers <- dplyr::n_distinct(input$MARKERS)

    #Function to replace plyr::round_any
    rounder <- function(x, accuracy, f = round) {
      f(x / accuracy) * accuracy
    }

    # max.markers <- 658
    if (max.markers >= 1000) {
      y.breaks.by <- rounder(max.markers/10, 100, ceiling)
      y.breaks.max <- rounder(max.markers, 1000, ceiling)
      y.breaks <- seq(0, y.breaks.max, by = y.breaks.by)
    } else {
      y.breaks.by <- rounder(max.markers/10, 10, ceiling)
      y.breaks.max <- rounder(max.markers, 100, ceiling)
      y.breaks <- seq(0, y.breaks.max, by = y.breaks.by)
    }

    plot.ind.threshold <- ggplot2::ggplot(threshold.helper, ggplot2::aes(x = IND_THRESHOLD, y = MARKER_NUMBER)) +
      ggplot2::geom_line() +
      ggplot2::geom_point(size = 2, shape = 21, fill = "white") +
      ggplot2::scale_x_continuous(name = "Individual threshold (percent)", breaks = seq(10, 100, by = 10)) +
      ggplot2::scale_y_continuous(name = "Number of markers", breaks = y.breaks, limits = c(0, y.breaks.max)) +
      ggplot2::theme(
        axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica", angle = 90, hjust = 1, vjust = 0.5),
        strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
      ) +
      ggplot2::facet_grid(~POP_ID)
    ggplot2::ggsave(file.path(path.folder.ind.filter, "plot.ind.threshold.pdf"), width = pop.number*4, height = 10, dpi = 600, units = "cm", useDingbats = FALSE)

    if (interactive.filter) {
      message("Step 1. Impact of individual threshold on marker discovery")
      print(plot.ind.threshold)
      message("Look at the plot and inspect the change in the number of markers
in relation to the individual percentage thresholds\n")
    }

    # Helper table for individual thresholds
    ind.threshold.helper.table <- threshold.helper %>%
      dplyr::group_by(POP_ID) %>%
      tidyr::spread(data = ., key = IND_THRESHOLD, MARKER_NUMBER)

    readr::write_tsv(
      x = ind.threshold.helper.table,
      path = file.path(path.folder.ind.filter, "ind.threshold.helper.table.tsv"))

    if (interactive.filter) {
      message("\nInspect the table (ind.threshold.helper.table) to help you view
the relation between individual thresholds and marker discovery:")
      message("First column: POP_ID")
      message("Remaining columns: the individual thresholds in percent
with the value = the number of markers discovered")
      message("The last 2 rows: MEAN_POP is the mean across your populations
and OVERALL is if you had 1 large population")
    }

    # Step 2. Choose the filtering approach and thresholds
    # 2 approach: filtering with the overall n. ind. ("overall") or by pop ("pop")
    if (interactive.filter) {
      message("Step 2. Choose the filtering approach and thresholds")
      message("The approach to filter a marker: do you want it based on the overall
number of genotyped individuals or
on the number of genotyped individuals per pop ? (overall or pop):")
      ind.approach <- as.character(readLines(n = 1))

      message("Enter the individual threshold percentage: ")
      ind.threshold <- as.numeric(readLines(n = 1))
      if (ind.approach == "pop") {
        message("Tolerance for deviation: look at the plot produced ealier and if you see some populations dragging down
                the number of markers for certain percentage thresholds, you have 3 options:\n
                1. remove the population (use pop.select argument to keep the desired populations)
                2. remove individuals with too many missing genotypes (use blacklist.id argument)
                3. use the next threshold (below) to allow variance and then
                manage the missing values with blacklist of individuals and/or
                missing data imputations.\n
                Enter the number of problematic population that you allow to deviate from the threshold:")
        prob.pop.threshold <- as.numeric(readLines(n = 1))
      }
    }
    if (verbose) message("Filtering data")
    # some discrepencies need to be highllighted here. If you have entire pop not genotyped for a markers
    # this will compute them when doing the filtering:
    # summarise(GENOTYPED = length(INDIVIDUALS[GT != "000000"]))
    # if we first remove the individuals not genotyped with :
    # filter(GT != "000000")
    # the pop not genotyped are not accounted for. And this is what we want here.
    # filter_populations take care the ungenotyped pop and common.markers make sure that for certain analysis
    # you can have common markers or not.
    # so here we focus on when pop got a marker is it at 50% 60% 70%  ... genotyped?
    if (ind.approach == "overall") {
      threshold.id <- "(percent)"
      prob.pop.threshold <- "NA"
      ind.approach <- "overall individuals (no pop)"
      filter <- overall %>%
        dplyr::filter(PERCENT >= ind.threshold) %>%
        dplyr::distinct(MARKERS)
    } else {# approach by pop
      threshold.id <- "(percent)"
      ind.approach <- "individuals by pop"
      # ind.threshold <- 0.6
      # prob.pop.threshold <- 3
      filter <- pop %>%
        dplyr::ungroup(.) %>%
        dplyr::filter(PERCENT >= ind.threshold) %>%
        dplyr::group_by(MARKERS) %>%
        dplyr::tally(.) %>%
        dplyr::inner_join(pop.genotyped.marker, by = "MARKERS") %>%
        dplyr::mutate(PROB_POP = POP_GENOTYPED - n) %>%
        dplyr::filter(PROB_POP <= prob.pop.threshold) %>%
        dplyr::distinct(MARKERS)
    }

    # Apply the filter to the tidy data
    input <- dplyr::left_join(x = filter, input, by = "MARKERS")
    new.data.info <- data_info(input) # updating parameters

    n.snp.before <- data.info$n.snp
    if (verbose) message("    Number of markers before = ", n.snp.before)
    n.snp.blacklist <- n.snp.before - new.data.info$n.snp
    if (verbose) message("    Number of markers removed = ", n.snp.blacklist)
    if (verbose) message("    Number of markers after = ", n.snp.before - n.snp.blacklist)

    filters.parameters <- tibble::data_frame(
      FILTERS = "Filter markers missing",
      PARAMETERS = "ind.approach/ind.threshold/prob.pop.threshold",
      VALUES = stringi::stri_join(ind.approach, ind.threshold, prob.pop.threshold, sep = "/"),
      BEFORE = stringi::stri_join(data.info$n.chrom, data.info$n.locus, n.snp.before, sep = "/"),
      AFTER = stringi::stri_join(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
      BLACKLIST = stringi::stri_join(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, n.snp.blacklist, sep = "/"),
      UNITS = "CHROM/LOCUS/SNP",
      COMMENTS = ""
    )
    # update data.info
    data.info <- new.data.info
    readr::write_tsv(x = filters.parameters,
                     path = filters.parameters.path, append = TRUE,
                     col_names = FALSE)
    new.whitelist.markers <- dplyr::select(input, dplyr::one_of(want)) %>%
      dplyr::distinct(MARKERS, .keep_all = TRUE)

    blacklist.markers.geno <- dplyr::setdiff(whitelist.markers, new.whitelist.markers)
    if (nrow(blacklist.markers.geno) > 0) {
      readr::write_tsv(x = blacklist.markers.geno, path = file.path(path.folder.ind.filter, "blacklist.markers.geno.tsv"))
      if (!is.null(blacklist.markers)) {
        blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.markers.geno)
      } else {
        blacklist.markers <- blacklist.markers.geno
      }
    }
    whitelist.markers <- new.whitelist.markers
    new.whitelist.markers <- blacklist.markers.geno <- ind.total <- NULL
    pop.number <- ind.pop <- input.genotyped <- overall <- pop.genotyped.marker <- NULL
    pop <- threshold.helper.overall <- threshold.helper.pop <- NULL
    mean.pop <- threshold.helper <- max.markers <- filter <- ind.threshold.helper.table <- NULL
    plot.ind.threshold <- NULL
  }#End filter.markers.missing

  # change to the new directory for MAF filtering
  old.dir <- getwd()
  setwd(path.folder)

  # Filter Minor Allele Frequency  ---------------------------------------------
  if (!is.null(maf.thresholds) || interactive.filter) {

    if (interactive.filter) {
      maf.info <- radiator::filter_maf(
        data = input,
        maf.thresholds = c("SNP", 1, "OR", 1, 1),
        parallel.core = parallel.core,
        interactive.filter = TRUE)
    } else {
      maf.info <- radiator::filter_maf(
        data = input,
        maf.thresholds = maf.thresholds,
        parallel.core = parallel.core,
        interactive.filter = FALSE)
    }

    param.delete <- list.files(path = path.folder, pattern = "filters_parameters.tsv", full.names = TRUE)
    suppressWarnings(param.delete <- file.remove(param.delete))
    param.delete <- NULL

    param <- maf.info$filters.parameters

    blacklist.markers.maf <- maf.info$blacklist.markers
    whitelist.markers <- maf.info$whitelist.markers
    input <- maf.info$tidy.filtered.maf
    maf.info <- NULL
    if (nrow(blacklist.markers.maf) > 0) {
      readr::write_tsv(x = param,
                       path = filters.parameters.path, append = TRUE,
                       col_names = FALSE)
      n.snp.before <- data.info$n.snp
      n.snp.blacklist <- nrow(blacklist.markers.maf)
      data.info <- data_info(input)
      if (!is.null(blacklist.markers)) {
        blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.markers.maf)
      } else {
        blacklist.markers <- blacklist.markers.maf
      }
    }
    blacklist.markers.maf <- param <- NULL
    # change to the new directory
    old.dir <- getwd()
    setwd(path.folder)
  }# End maf.thresholds

  # Filter snp number  ---------------------------------------------------------
  setwd(old.dir)
  if (!is.null(number.snp.reads) || interactive.filter) {
    message("Filtering markers based on the number of SNP on the read/locus")
    folder.extension <- stringi::stri_join("filter_snp_number_dart_", file.date, sep = "")
    path.folder.snp.number <- file.path(path.folder, folder.extension)
    dir.create(path.folder.snp.number)
    message("Folder created: \n", folder.extension)

    # get the number of SNP per reads/haplotypes/locus
    number.snp <- dplyr::distinct(input, MARKERS, CHROM, LOCUS, POS) %>%
      dplyr::group_by(LOCUS) %>%
      dplyr::mutate(SNP_N = dplyr::n_distinct(POS))

    number.snp.plot.data <- number.snp %>% dplyr::distinct(LOCUS, SNP_N)

    number.snp.reads.plot <- ggplot2::ggplot(number.snp.plot.data, ggplot2::aes(factor(SNP_N))) +
      ggplot2::geom_bar() +
      ggplot2::labs(x = "Number of SNP per haplotypes (reads)") +
      ggplot2::labs(y = "Distribution (number)") +
      ggplot2::theme(
        axis.title.x = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold"),
        legend.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold"),
        legend.text = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold"),
        strip.text.x = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold"))

    # save
    ggplot2::ggsave(
      filename = file.path(path.folder.snp.number, "number.snp.locus.plot.pdf"),
      plot = number.snp.reads.plot,
      width = 20, height = 10, dpi = 600, units = "cm", useDingbats = FALSE)

    if (interactive.filter) {
      print(number.snp.reads.plot)
      message("Based on the plot, choose the threshold in maximum number of SNP per locus allowed (an integer): ")
      number.snp.reads <- as.integer(readLines(n = 1))
    }

    blacklist.snp.number.markers <- number.snp %>%
      dplyr::filter(SNP_N > number.snp.reads) %>%
      dplyr::distinct(LOCUS, .keep_all = TRUE) %>%
      dplyr::select(-SNP_N)

    if (nrow(blacklist.snp.number.markers) > 0) {
      n.snp.before <- data.info$n.snp
      readr::write_tsv(blacklist.snp.number.markers, path = file.path(path.folder.snp.number, "blacklist.snp.number.markers.tsv"))
      input <- dplyr::anti_join(input, blacklist.snp.number.markers, by = "LOCUS")
      whitelist.markers <- dplyr::select(input, dplyr::one_of(c("MARKERS", "CHROM", "LOCUS", "POS"))) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE)
      new.data.info <- data_info(input) # updating parameters

      if (verbose) message("    Number of markers before = ", n.snp.before)
      if (verbose) message("    Number of markers removed = ", data.info$n.snp - new.data.info$n.snp)
      if (verbose) message("    Number of markers after = ", new.data.info$n.snp)

      filters.parameters <- tibble::data_frame(
        FILTERS = "SNP number per reads/locus",
        PARAMETERS = "",
        VALUES = number.snp.reads,
        BEFORE = stringi::stri_join(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
        AFTER = stringi::stri_join(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
        BLACKLIST = stringi::stri_join(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
        UNITS = "CHROM/LOCUS/SNP",
        COMMENTS = ""
      )
      readr::write_tsv(x = filters.parameters,
                       path = filters.parameters.path, append = TRUE,
                       col_names = FALSE)
      # update data.info
      data.info <- new.data.info
      if (!is.null(blacklist.markers)) {
        blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.snp.number.markers)
      } else {
        blacklist.markers <- blacklist.snp.number.markers
      }
    }
    blacklist.snp.number.markers <- number.snp <- number.snp.reads.plot <- NULL
  }#End number.snp.reads

  # # update metadata info
  # metadata <- dplyr::filter(metadata, !MARKERS %in% blacklist.markers$MARKERS)
  # write_rad(
  #   data = metadata,
  #   path = file.path(
  #     path.folder,
  #     stringi::stri_replace_all_fixed(metadata.file, ".rad", "_filtered.rad",
  #                                     vectorize_all = FALSE)))

  # Data quality AFTER filters --------------------------------------------------
  setwd(path.folder)

  # Detect mixed genomes -------------------------------------------------------
  if (interactive.filter || mixed.genomes.analysis) {
    if (verbose) message("Mixed genomes analysis ...")
    mixed.genomes.analysis <- radiator::detect_mixed_genomes(
      data = input,
      ind.heterozygosity.threshold = ind.heterozygosity.threshold)

    blacklist.ind.het <- mixed.genomes.analysis$blacklist.ind.het

    if (interactive.filter) {
      message("\n\nInspect plots and tables in folder created...")
      message("    Do you want to exclude individuals based on heterozygosity ? (y/n): ")
      mixed.gen.analysis <- as.character(readLines(n = 1))
      if (mixed.gen.analysis == "y") {
        message("    Enter the min value for ind.heterozygosity.threshold argument (0 turns off): ")
        threshold.min <- as.numeric(readLines(n = 1))
        message("    Enter the max value for ind.heterozygosity.threshold argument (1 turns off): ")
        threshold.max <- as.numeric(readLines(n = 1))
        blacklist.ind.het  <- dplyr::ungroup(mixed.genomes.analysis$individual.heterozygosity) %>%
          dplyr::filter(HET_PROP > threshold.max | HET_PROP < threshold.min) %>%
          dplyr::distinct(INDIVIDUALS)
        ind.heterozygosity.threshold <- as.numeric(c(threshold.min, threshold.max))
      }
    }


    if (!is.null(nrow(blacklist.ind.het)) &&
        nrow(blacklist.ind.het > 0)) {
      n.ind.blacklisted <- length(blacklist.ind.het$INDIVIDUALS)
      message("Filter individual's heterozygosity: ", n.ind.blacklisted, " individual(s) blacklisted")
      mixed.genome.folder <- list.files(path = path.folder, pattern = "detect_mixed_genomes", full.names = TRUE)

      if (length(mixed.genome.folder) > 1) {
        mixed.genome.folder <- file.info(mixed.genome.folder) %>%
          tibble::rownames_to_column(df = ., var = "FILE") %>%
          dplyr::filter(mtime == max(mtime))
        mixed.genome.folder <- mixed.genome.folder$FILE
      }

      readr::write_tsv(
        x = blacklist.ind.het,
        path = stringi::stri_join(mixed.genome.folder, "/blacklist.ind.het.tsv"),
        col_names = TRUE)

      res$blacklist.id <- res$blacklist.id %>% dplyr::bind_rows(blacklist.ind.het)

      input <- dplyr::anti_join(
        input,
        blacklist.ind.het, by = "INDIVIDUALS")

      # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "detect mixed genomes",
        PARAMETERS = "ind.heterozygosity.threshold (min/max)",
        VALUES = stringi::stri_join(ind.heterozygosity.threshold, collapse = "/"),
        BEFORE = data.info$n.ind,
        AFTER = data.info$n.ind - n.ind.blacklisted,
        BLACKLIST = n.ind.blacklisted,
        UNITS = "individuals",
        COMMENTS = ""
      )
      readr::write_tsv(x = filters.parameters, path = filters.parameters.path,
                       append = TRUE, col_names = FALSE)
      # update data.info
      data.info$n.ind <- data.info$n.ind - n.ind.blacklisted

      # Filter monomorphic markers again
      if (monomorphic.out) {
        input <- discard_monomorphic_markers(data = input, verbose = verbose)
        blacklist.monomorphic.markers <- input$blacklist.monomorphic.markers
        whitelist.markers <- input$whitelist.polymorphic.markers
        input <- input$input

        # update blacklist.markers
        if (nrow(blacklist.monomorphic.markers) > 0) {
          readr::write_tsv(x = blacklist.monomorphic.markers,
                           path = file.path(path.folder, "blacklist.monomorphic.markers.tsv"))
          if (verbose) message("    Blacklist of monomorphic markers written in: blacklist.monomorphic.markers.tsv")

          if (is.null(blacklist.markers)) {
            blacklist.markers<- blacklist.monomorphic.markers
          } else {
            blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.monomorphic.markers)
          }

          new.data.info <- data_info(input)

          # updating parameters
          filters.parameters <- tibble::data_frame(
            FILTERS = "removing monomorphic markers",
            PARAMETERS = "",
            VALUES = "",
            BEFORE = stringi::stri_join(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
            AFTER = stringi::stri_join(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
            BLACKLIST = stringi::stri_join(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
            UNITS = "CHROM/LOCUS/SNP",
            COMMENTS = ""
          )
          readr::write_tsv(x = filters.parameters,
                           path = filters.parameters.path, append = TRUE,
                           col_names = FALSE)
          # update data.info
          data.info <- new.data.info
        }
        blacklist.monomorphic.markers <- NULL
      }# End monomorphic.out
    }
    mixed.genomes.analysis <- NULL
  }# End mixed genomes

  # Detect duplicate genomes ---------------------------------------------------
  genome <- duplicate.genomes.analysis[2]
  duplicate.genomes.analysis <- duplicate.genomes.analysis[1]

  if (interactive.filter || duplicate.genomes.analysis) {
    if (verbose) message("Duplicate genomes analysis...")
    duplicate.genomes <- radiator::detect_duplicate_genomes(
      data = input,
      distance.method = "manhattan",
      genome = genome,
      blacklist.duplicates = TRUE,
      parallel.core = parallel.core)

    # subsample.markers = NULL # test
    # random.seed = NULL # test

    if (interactive.filter) {
      message("\n\n    Inspect plots and tables")
      # filtering by distance or pairwise genome similarity ?

      message("    Suspicious about the duplicates analysis?")
      message("    Run the full pairwise genome comparisons")
      message("    This approach integrates markers in common & missing data\n")

      message("    Do you want to run the pairwise genome comparison (y/n): ")
      genome <- as.character(readLines(n = 1))
      if (genome == "y") {
        duplicate.genomes <- radiator::detect_duplicate_genomes(
          data = input,
          distance.method = "manhattan",
          genome = TRUE,
          blacklist.duplicates = TRUE,
          parallel.core = parallel.core)
      }
      dup.genome.folder <- list.files(
        path = path.folder,
        pattern = "detect_duplicate_genomes", full.names = TRUE)

      if (length(dup.genome.folder) > 1) {
        dup.genome.folder <- file.info(dup.genome.folder) %>%
          tibble::rownames_to_column(df = ., var = "FILE") %>%
          dplyr::filter(mtime == max(mtime))
        dup.genome.folder <- dup.genome.folder$FILE
      }

      # Check for a blacklist
      blacklist.id.similar.path <- list.files(
        path = dup.genome.folder,
        pattern = "blacklist.id.similar",
        full.names = TRUE)
      if (length(blacklist.id.similar.path) > 0) {
        blacklist.id.similar <- suppressMessages(readr::read_tsv(blacklist.id.similar.path, col_names = TRUE))
        n.ind.blacklisted <- length(blacklist.id.similar$INDIVIDUALS)
        if (n.ind.blacklisted > 0) {
          if (verbose) message("Blacklisted individuals: ", n.ind.blacklisted, " ind.")
          if (verbose) message("    Filtering with blacklist of individuals")
          input <- suppressWarnings(dplyr::anti_join(input, blacklist.id.similar, by = "INDIVIDUALS"))

          res$blacklist.id <- res$blacklist.id %>% dplyr::bind_rows(blacklist.id.similar)
          blacklist.id.similar <- NULL

          # updating parameters
          filters.parameters <- tibble::data_frame(
            FILTERS = "detect duplicate genomes",
            PARAMETERS = "",
            VALUES = "",
            BEFORE = data.info$n.ind,
            AFTER = data.info$n.ind - n.ind.blacklisted,
            BLACKLIST = n.ind.blacklisted,
            UNITS = "individuals",
            COMMENTS = ""
          )
          readr::write_tsv(x = filters.parameters, path = filters.parameters.path,
                           append = TRUE, col_names = FALSE)
          # update data.info
          data.info$n.ind <- data.info$n.ind - n.ind.blacklisted

          # After removing individuals => check for monomorphic markers
          message("\nScan and remove monomorphic markers, again...")
          input <- discard_monomorphic_markers(data = input, verbose = verbose)
          blacklist.monomorphic.markers <- input$blacklist.monomorphic.markers
          whitelist.markers <- input$whitelist.polymorphic.markers
          input <- input$input
          if (nrow(blacklist.monomorphic.markers) > 0) {
            new.data.info <- data_info(input)

            # updating parameters
            filters.parameters <- tibble::data_frame(
              FILTERS = "removing monomorphic markers",
              PARAMETERS = "",
              VALUES = "",
              BEFORE = stringi::stri_join(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
              AFTER = stringi::stri_join(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
              BLACKLIST = stringi::stri_join(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
              UNITS = "CHROM/LOCUS/SNP",
              COMMENTS = ""
            )
            readr::write_tsv(x = filters.parameters,
                             path = filters.parameters.path, append = TRUE,
                             col_names = FALSE)
            # update data.info
            data.info <- new.data.info
            if (!is.null(blacklist.markers)) {
              blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.monomorphic.markers)
            } else {
              blacklist.markers <- blacklist.monomorphic.markers
            }
          }
        }
      }
    }
    duplicate.genomes <- blacklist.monomorphic.markers <- NULL
  }#End duplicate.genomes.analysis

  # Missing visualization analysis before filters------------------------------
  # if (missing.analysis) {
  #   if (verbose) message("Missing data analysis: after filters")
  #   missing.visualization <- grur::missing_visualization(data = input, write.plot = TRUE)
  # }

  # Writing to working directory the filtered data frame -----------------------
  # Whitelist
  res$whitelist.markers <- whitelist.markers
  readr::write_tsv(x = res$whitelist.markers, path = "whitelist.markers.tsv", col_names = TRUE)
  if (verbose) message("Writing the whitelist of markers: whitelist.markers.tsv")

  if (nrow(blacklist.markers) > 0) {
    res$blacklist.markers <- blacklist.markers
    readr::write_tsv(x = res$blacklist.markers, path = "blacklist.markers.tsv", col_names = TRUE)
    if (verbose) message("Writing the blacklist of markers: blacklist.markers.tsv")
  }

  # writing the blacklist of id
  if (nrow(res$blacklist.id) > 0) {
    readr::write_tsv(x = res$blacklist.id, path = "blacklist.id.tsv", col_names = TRUE)
    if (verbose) message("Writing the blacklist of ids: blacklist.id.tsv")
  }
  # tidy data
  want <- c("MARKERS", "CHROM", "LOCUS", "POS", "INDIVIDUALS", "POP_ID", "REF", "ALT", "GT", "GT_VCF", "GT_VCF_NUC", "GT_BIN")
  res$tidy.data <- dplyr::select(input, dplyr::one_of(want)) %>%
    dplyr::arrange(MARKERS, POP_ID, INDIVIDUALS)
  input <- NULL

  # write tidy to working directory
  if (!is.null(filename)) {
    tidy.name <- stringi::stri_join(filename, ".filtered.rad")
    write_rad(data = res$tidy.data, path = tidy.name)
    message("Tidy DArT data, filtered, written to folder: \n", tidy.name)
  }


  # Import back the filter parameter file
  res$filters.parameters <- readr::read_tsv(file = filters.parameters.path, col_types = "cccccccc")

  # Generate new strata --------------------------------------------------------
  res$strata <-res$tidy.data %>%
    dplyr::distinct(INDIVIDUALS, POP_ID) %>%
    dplyr::rename(STRATA = POP_ID) %>%
    readr::write_tsv(x = ., path = "new_filtered_strata.tsv")

  # genomic_converter & Imputations --------------------------------------------
  if (!is.null(output)) {
    res$output <- radiator::genomic_converter(
      data = res$tidy.data,
      output = output,
      snp.ld = snp.ld,
      imputation.method = imputation.method,
      hierarchical.levels = hierarchical.levels,
      num.tree = num.tree,
      parallel.core = parallel.core,
      verbose = verbose)
  }

  if (verbose) {
    last.data.info <- data_info(res$tidy.data)
    cat("\n\n\n############################### RESULTS ###############################\n")
    message("DArT data info (before -> after) filters: ")
    message("Number of populations: ", first.data.info$n.pop, " -> ", last.data.info$n.pop)
    message("Number of individuals: ", first.data.info$n.ind, " -> ", last.data.info$n.ind)
    message("Number of chrom: ", first.data.info$n.chrom, " -> ", last.data.info$n.chrom)
    message("Number of locus: ", first.data.info$n.locus, " -> ", last.data.info$n.locus)
    message("Number of SNPs: ", first.data.info$n.snp, " -> ", last.data.info$n.snp)
    timing <- proc.time() - timing
    message("\nComputation time: ", round(timing[[3]]), " sec")
    cat("############################ completed ################################\n")
  }
  setwd(working.dir) #back to the original working directory
  options(width = opt.change)
  return(res)
}#End filter_dart
